/*
 * ici.h - ICI exports for C and C++ interfacing to ICI.
 *
 * This file is automatically generated from internal ICI include files.
 * It is platform specific. This file is based on "conf-w32.h".
 */

#ifndef ICI_ICI_H
#define ICI_ICI_H

#ifdef __cplusplus
extern "C" {
#endif


/* From conf-w32.h */


/*
 * The following macros control the inclusion of various ICI intrinsic
 * functions. If the macro is defined the functions are NOT include
 * (hence the NO at the start of the name). By undef'ing the macro you
 * are stating that the functions should be included and compile (and
 * possibly even work) for the particular port of ICI.
 */
#undef  NOMATH          /* Trig and etc. */
#define NOTRACE         /* For debugging. */
#define NOWAITFOR       /* Requires select() or similar system primitive. */
#undef  NOSYSTEM        /* Command interpreter (shell) escape. */
#undef  NOPIPES         /* Requires popen(). */
#undef  NOSKT           /* BSD style network interface. */
#undef  NODIR           /* Directory reading function, dir(). */
#define NOPASSWD        /* UNIX password file access */
#undef  NODLOAD         /* Dynamic loading of native machine code modules. */
#undef  NOSTARTUPFILE   /* Parse a standard file of ICI code at init time. */
#undef  NODEBUGGING     /* Debugger interface and functions */
#undef  NOEVENTS        /* Event loop and associated processing. */
#define NOPROFILE       /* Profiler, see profile.c. */
#define NOSIGNALS       /* ICI level signal handling */
#undef  NOFASTFREELISTS /* Fast free lists: +8bytes per malloc, more speed. */
#define NOCLASSPROTO
/*
 * Mentioned in the version string.
 */
#define CONFIG_STR      "Microsoft Win32 platforms"

#define popen           _popen
#define pclose          _pclose
#define access          _access
#define ICI_PATH_SEP    ';'
#define ICI_DLL_EXT     ".dll"

/*
 * ICI_CORE is defined by core language files, as opposed to builds of
 * extension libraries that are including the same include files but are
 * destined for dynamic loading against the core language at run-time.
 * This allows us to declare data items as imports into the DLL.
 * Otherwise they are not visible. See fwd.h.
 *
 * Every core language source code file defines this before including
 * any includes.
 */
#ifndef ICI_CORE
#define DLI   __declspec(dllimport) /* See DLI in fwd.h. */
#endif

#ifndef PREFIX
#define PREFIX "C:/ICI"
#endif

#ifndef _WIN32
#define _WIN32
#endif

int ici_get_last_win32_error(void);


/* From fwd.h */


/*
 * Define SMALL to reduce the use of macros and thus reduce code size.
 * But it causes considerable speed degradation.
 */


#include <stddef.h>
#include <stdlib.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>
#ifndef NOSIGNALS
# ifdef SUNOS5
#  include <signal.h>
# endif
#endif
/*
 * DLI is defined in some configurations (Windows, in the conf include file)
 * to be a declaration modifyer which must be applied to data objects being
 * referenced from a dynamically loaded DLL.
 *
 * If it hasn't been defined yet, define it to be null. Most system don't
 * need it.
 */
#ifndef DLI
#define DLI
#endif

/*
 * The character which seperates directories in a path list on this
 * architecture. This is the default value, it may have been set in
 * the config file.
 */
#ifndef ICI_PATH_SEP
#define ICI_PATH_SEP    ':'
#endif

/*
 * The string which is the extension of a dynamicly loaded library on this
 * architecture. This is the default value, it may have been set in
 * the config file.
 */
#ifndef ICI_DLL_EXT
#define ICI_DLL_EXT     ".so"
#endif

/*
 * A 'random' value for Windows event handling functions to return
 * to give a better indication that an ICI style error has occured which
 * should be propagated back. See events.c
 */
#define ICI_EVENT_ERROR 0x7A41B291

/*
 * An integer conversion of a pointer that throws away low bits (with
 * high coherence) to form a starting point for hash functions based
 * on pointer values.
 */
#define ICI_PTR_HASH_BITS(p)    ((unsigned long)(p) >> 6)

#define nels(a)         (sizeof a / sizeof a[0])

typedef struct array    array_t;
typedef struct catchs   catch_t;
typedef struct slot     slot_t;
typedef struct sets     set_t;
typedef struct structs  struct_t;
typedef struct exec     exec_t;
typedef struct floats   float_t;
typedef struct file     file_t;
typedef struct func     func_t;
typedef struct cfunc    cfunc_t;
typedef struct method   method_t;
typedef struct ints     int_t;
typedef struct marks    mark_t;
typedef struct null     null_t;
typedef struct object   object_t;
typedef struct objwsup  objwsup_t;
typedef struct op       op_t;
typedef struct pc       pc_t;
typedef struct ptr      ptr_t;
typedef struct regexpo  regexp_t;
typedef struct src      src_t;
typedef struct string   string_t;
typedef struct type     type_t;
typedef struct wrap     wrap_t;
typedef struct ftype    ftype_t;
typedef struct forall   forall_t;
typedef struct parse    parse_t;
typedef struct mem      mem_t;
typedef struct expr     expr_t;
typedef union  ostemp   ostemp_t;
typedef struct ici_handle ici_handle_t;
#ifndef NOSKT
typedef struct skt      skt_t;
#endif
#ifndef NODEBUGGING
typedef struct debug    debug_t;
#endif

extern DLI object_t     **objs;
extern DLI object_t     **objs_top;
extern DLI object_t     **objs_limit;
extern DLI object_t     **atoms;
extern DLI int          atomsz;
extern DLI int_t        *o_zero;
extern DLI int_t        *o_one;
extern DLI char         *ici_error;
extern DLI exec_t       *ici_execs;
extern DLI exec_t       *ici_exec;
extern DLI array_t      ici_xs;
extern DLI array_t      ici_os;
extern DLI array_t      ici_vs;

extern DLI long         ici_vsver;

#define NSUBEXP         (10)
extern DLI int  re_bra[(NSUBEXP + 1) * 3];
extern DLI int  re_nbra;

extern DLI volatile int ici_aborted;            /* See exec.c */

extern DLI int  ici_dont_record_line_nums;      /* See lex.c */
extern DLI char *ici_buf;                       /* See buf.h */
extern DLI int  ici_bufz;                       /* See buf.h */

extern DLI type_t       ici_array_type;
extern DLI type_t       ici_catch_type;
extern DLI type_t       ici_exec_type;
extern DLI type_t       set_type;
extern DLI type_t       struct_type;
extern DLI type_t       float_type;
extern DLI type_t       file_type;
extern DLI type_t       ici_func_type;
extern DLI type_t       ici_cfunc_type;
extern DLI type_t       ici_method_type;
extern DLI type_t       forall_type;
extern DLI type_t       int_type;
extern DLI type_t       mark_type;
extern DLI type_t       null_type;
extern DLI type_t       op_type;
extern DLI type_t       pc_type;
extern DLI type_t       ptr_type;
extern DLI type_t       regexp_type;
extern DLI type_t       src_type;
extern DLI type_t       string_type;
extern DLI type_t       parse_type;
extern DLI type_t       ostemp_type;
extern DLI type_t       ici_handle_type;
extern DLI type_t       profilecall_type;
#ifndef NOSKT
extern DLI type_t       socket_type;
#endif
extern DLI type_t       mem_type;

extern DLI ftype_t      stdio_ftype;
extern DLI ftype_t      ici_popen_ftype;

/*
 * ###These shouldn't really be in fwd.h. They are very specific to
 * parse/exec.
 */
extern DLI op_t o_quote;
extern DLI op_t o_looper;
extern DLI op_t o_loop;
extern DLI op_t o_break;
extern DLI op_t o_continue;
extern DLI op_t o_offsq;
extern DLI op_t o_exec;
extern DLI op_t o_mkfunc;
extern DLI op_t o_return;
extern DLI op_t o_call;
extern DLI op_t o_method_call;
extern DLI op_t o_super_call;
extern DLI op_t o_if;
extern DLI op_t o_ifnot;
extern DLI op_t o_ifnotbreak;
extern DLI op_t o_ifbreak;
extern DLI op_t o_ifelse;
extern DLI op_t o_pop;
extern DLI op_t o_colon;
extern DLI op_t o_coloncaret;
extern DLI op_t o_dot;
extern DLI op_t o_dotkeep;
extern DLI op_t o_dotrkeep;
extern DLI op_t o_mkptr;
extern DLI op_t o_openptr;
extern DLI op_t o_fetch;
extern DLI op_t o_for;
extern DLI op_t o_mklvalue;
extern DLI op_t o_rematch;
extern DLI op_t o_renotmatch;
extern DLI op_t o_reextract;
extern DLI op_t o_onerror;
extern DLI op_t o_andand;
extern DLI op_t o_barbar;
extern DLI op_t o_namelvalue;
extern DLI op_t o_switch;
extern DLI op_t o_switcher;
extern DLI null_t       o_null;
extern DLI mark_t       o_mark;
extern DLI op_t o_critsect;
extern DLI op_t o_waitfor;
#ifndef NODEBUGGING
extern DLI debug_t *ici_debug;
#endif

extern char     ici_version_string[];

#define null_ret() ici_ret_no_decref(objof(&o_null))

extern char     **smash(char *, int);
extern char     **ssmash(char *, char *);
extern char     *ici_binop_name(int);
extern object_t *ici_evaluate(object_t *, int);
extern object_t *copy_simple(object_t *);
extern object_t *fetch_simple(object_t *, object_t *);
extern slot_t   *find_slot(struct_t **, object_t *);
extern slot_t   *find_raw_slot(struct_t *, object_t *);
extern object_t *get_token(file_t *);
extern object_t *get_value(struct_t *, object_t *);
extern object_t *atom(object_t *, int);
extern object_t *atom_probe(object_t *);
extern int_t    *atom_int(long);
extern int      parse_exec(void);
extern int      parse_module(file_t *, objwsup_t *);
extern int      parse_file(char *, char *, ftype_t *);
extern parse_t  *new_parse(file_t *);
extern array_t  *new_array(ptrdiff_t);
extern mem_t    *new_mem(void *, size_t, int, void (*)());
extern catch_t  *new_catch(object_t *, int, int, int);
extern string_t *new_cname(char *);
extern string_t *get_cname(char *);
extern int      need_string(string_t **, char *);
extern unsigned long    ici_hash_string(object_t *);
extern set_t    *new_set(void);
extern struct_t *new_struct(void);
extern exec_t   *new_exec(void);
extern float_t  *new_float(double);
extern file_t   *new_file(char *, ftype_t *, string_t *);
extern func_t   *new_func(void);
extern int_t    *new_int(long);
extern string_t *new_string(int);
extern string_t *new_name(char *, int);
extern op_t     *new_op(int (*)(), int, int);
extern int      new_pc(array_t *, object_t **);
extern ptr_t    *new_ptr(object_t *, object_t *);
extern src_t    *new_src(int, string_t *);
extern regexp_t *new_regexp(string_t *, int);
extern int      assign_simple(object_t *, object_t *, object_t *);
extern file_t   *ici_sopen(char *, int);
extern catch_t  *ici_unwind(void);
extern void     collect(void);
extern unsigned long hash_unique(object_t *);
extern int      cmp_unique(object_t *, object_t *);
extern int      exec_simple(void);
extern void     free_simple(object_t *);
extern int      ici_growarray(array_t *, ptrdiff_t);
extern int      ici_op_binop(void);
extern int      ici_op_mklvalue(void);
extern int      ici_op_onerror(void);
extern int      ici_op_for(void);
extern int      ici_op_looper(void);
extern int      ici_op_continue(void);
extern int      ici_op_andand(void);
extern int      ici_op_switcher(void);
extern int      ici_op_switch(void);
extern int      ici_op_pop(void);
extern int      ici_op_forall(void);
extern int      ici_op_return(void);
extern int      ici_op_call(void);
extern int      ici_op_mkptr(void);
extern int      ici_op_openptr(void);
extern int      ici_op_fetch(void);
extern int      ici_op_unary(void);
extern char     *syserr(void);
extern int      ici_argcount(int);
extern int      ici_argerror(int);
extern array_t  *mk_strarray(char **);
extern int      f_simple(void);
extern int      f_vsimple(void);
extern void     unassign_struct(struct_t *, object_t *);
extern int      unassign_set(set_t *, object_t *);
extern void     grow_objs(object_t *);
extern char     *objname(char *, object_t *);
extern void     expand_error(int, string_t *);
extern int      lex(parse_t *, array_t *);
extern struct_t *statics_struct(struct_t *, struct_t *);
extern void     wrapup(void);
extern int      f_close(file_t *f);
extern int      ici_ret_with_decref(object_t *);
extern int      int_ret(long);
extern int      ici_ret_no_decref(object_t *);
extern void     uninit_cfunc(void);
extern int      ici_typecheck(char *, ...);
extern int      ici_retcheck(char *, ...);
extern int      ici_op_call(void);
extern int      nptrs(char **);
extern int      ici_badindex(void);
extern int      mkstream(char *, FILE *);
extern int      ici_init(void);
extern void     ici_uninit(void);
extern int      exec_forall(void);
extern exec_t   *ici_new_exec(void);
extern int      compile_expr(array_t *, expr_t *, int);
extern void     uninit_compile(void);
extern file_t   *need_stdin(void);
extern file_t   *need_stdout(void);
extern int      set_issubset(set_t *, set_t *);
extern int      set_ispropersubset(set_t *, set_t *);
extern void     ici_reclaim(void);
extern int      str_ret(char *);
extern int      float_ret(double);
extern char     *ici_func(object_t *, char *, ...);
extern char     *ici_funcv(object_t *, char *, va_list);
extern char     *ici_call(char *, char *, ...);
extern char     *ici_callv(char *, char *, va_list);
extern int      ici_cmkvar(objwsup_t *, char *, int, void *);
extern int      ici_set_val(objwsup_t *, string_t *, int, void *);
extern int      ici_fetch_num(object_t *, object_t *, double *);
extern int      ici_fetch_int(object_t *, object_t *, long *);
extern long     ici_strtol(char const *, char **, int);
extern int      ici_load(string_t *);
extern char     *ici_get_dll_path(void);
extern int      ici_find_on_path(char *, char [FILENAME_MAX], char *);
extern int      ici_assign_cfuncs(objwsup_t *, cfunc_t *);
extern int      def_cfuncs(cfunc_t *);
extern int      ici_main(int, char **);
extern int      ici_init_sstrings(void);
extern method_t *ici_new_method(object_t *, object_t *);
extern int      ici_get_foreign_source_code(parse_t *, array_t *, int, int, int, int, int, unsigned long *);
extern ici_handle_t *ici_new_handle(void *, string_t *, objwsup_t *);
extern int      ici_register_type(type_t *t);
extern ptrdiff_t ici_array_nels(array_t *);
extern int      ici_grow_stack(array_t *, ptrdiff_t);
extern int      ici_fault_stack(array_t *, ptrdiff_t);
extern void     ici_array_gather(object_t **, array_t *, ptrdiff_t, ptrdiff_t);
extern int      ici_array_push(array_t *, object_t *);
extern int      ici_array_rpush(array_t *, object_t *);
extern object_t *ici_array_pop(array_t *);
extern object_t *ici_array_rpop(array_t *);
extern object_t *ici_array_get(array_t *, ptrdiff_t);
extern void     ici_invalidate_struct_lookaside(struct_t *);
extern void     ici_drop_all_small_allocations(void);

extern exec_t   *ici_leave(void);
extern void     ici_enter(exec_t *);
extern void     ici_yield(void);
extern int      ici_waitfor(object_t *);
extern int      ici_wakeup(object_t *);
extern int      ici_init_thread_stuff(void);

#ifndef NODEBUGGING
extern int      ici_maind(int, char **, int);
extern DLI int  ici_debug_enabled;
extern int  ici_debug_ign_err;
extern DLI void ici_debug_ignore_errors(void);
extern DLI void ici_debug_respect_errors(void);
#else
/*
 * We let the compiler use it's sense to remove a lot of debug
 * code base on a constant expression for ici_debug_enabled. Just
 * to save on lots of idefs.
 */
#define ici_debug_enabled 0
#endif

#ifndef NOSIGNALS
#ifdef SUNOS5
extern volatile sigset_t ici_signals_pending;
#else
extern volatile long    ici_signals_pending;
#endif
extern volatile long    ici_signals_count[];
extern void     ici_signals_init(void);
extern int      ici_signals_invoke_handlers(void);
extern int      ici_signals_blocking_syscall(int);
#else
/*
 * Let compiler remove code without resorting to ifdefs as for debug.
 */
#define ici_signals_pending 0
#define ici_signals_blocking_syscall(x)
#define ici_signals_invoke_handlers()
#endif

#ifndef NOSKT
extern int      skt_close(skt_t *);
#endif

#ifdef BSD
extern int      select();
#endif

#ifdef  sun
double strtod(const char *ptr, char **endptr);
#endif

#ifndef NOTRACE
extern void     trace_pcall(object_t *);
#endif


/* From object.h */


#define ICI_MAX_TYPES   64

extern type_t           *ici_types[ICI_MAX_TYPES];

#define ICI_OBJNAMEZ    30

/*
 * Every object has a header. In the header the o_tcode (type code) field
 * can be used to index the ici_types[] array to discover the obejct's
 * type structure. This is the type structure. See detailed comments below.
 */
struct type
{
    unsigned long (*t_mark)(object_t *);
    void        (*t_free)(object_t *);
    unsigned long (*t_hash)(object_t *);
    int         (*t_cmp)(object_t *, object_t *);
    object_t    *(*t_copy)(object_t *);
    int         (*t_assign)(object_t *, object_t *, object_t *);
    object_t    *(*t_fetch)(object_t *, object_t *);
    char        *t_name;
    void        (*t_objname)(object_t *, char [ICI_OBJNAMEZ]);
    int         (*t_call)(object_t *, object_t *);
    string_t    *t_ici_name;
    int         (*t_assign_super)(object_t *, object_t *, object_t *, struct_t *);
    int         (*t_fetch_super)(object_t *, object_t *, object_t **, struct_t *);
    int         (*t_assign_base)(object_t *, object_t *, object_t *);
    object_t    *(*t_fetch_base)(object_t *, object_t *);
    void        *t_reserved1;   /* MBZ. Probably forall generalisation. */
    void        *t_reserved2;   /* Must be zero. */
    void        *t_reserved3;   /* Must be zero. */
    void        *t_reserved4;   /* Must be zero. */
};
/*
 * t_mark(o)    Sets the O_MARK flag in o->o_flags of this object and
 *              all objects referenced by this one which don't already
 *              have O_MARK set. Returns the approximate memory cost
 *              of this and all other objects it sets the O_MARK of.
 *              Typically recurses on all referenced objects which
 *              don't already have O_MARK set (this recursion is a
 *              potential problem due to the uncontrolled stack depth
 *              it can create). This is used in the marking phase of
 *              garbage collection.
 *
 *              The macro mark() calls the t_mark function of the object
 *              (based on object type) if the O_MARK flag of the object
 *              is clear, else it returns 0. This is the usual interface
 *              to an object's mark function.
 *
 *              The mark function implemantation of objects can assume
 *              the O_MARK flag of the object they are being invoked
 *              on is clear.
 *
 * t_free(o)    Frees the object o and all associated data, but not
 *              other objects which are referenced from it. This is only
 *              called from garbage collection. Care should be taken
 *              to remember that errors can occur during object creation
 *              and that the free function might be asked to free a
 *              partially allocated object.
 *
 *              Simple object types which just have to free their data
 *              can use the existing function free_simple() as their
 *              implementation of this function.
 *
 * t_cmp(o1, o2) Compare o1 and o2 and return 0 if they are the same, else
 *              non zero. This similarity is the basis for merging objects
 *              into single atomic objects and the implementation of the ==
 *              operator.
 *
 *              Some objects are by nature both unique and intrinsically
 *              atomic (for example, objects which are one-to-one with
 *              some other allocated data which they alloc when the are
 *              created and free when they die). For these objects the
 *              existing function cmp_unique() can be used as their
 *              implementation of this function.
 *
 *              It is very important in implementing this function not to
 *              miss any fields which may otherwise distinguish two obejcts.
 *              The cmp, hash and copy operations of an object are all
 *              related. It is useful to check that they all regard the
 *              same data fields as significant in performing their
 *              operation.
 *
 * t_copy(o)    Returns a copy of the given object. This is the basis for
 *              the implementation of the copy() function. On failure, NULL
 *              is returned and error is set. The returned object has been
 *              incref'ed. The returned object should cmp() as being equal,
 *              but be a distinct object for object which are not
 *              intrinsically atomic.
 *
 *              Intrinsically atomic objects may use the existing function
 *              copy_simple() as their implemenation of this function.
 *
 * t_hash(o)    Return an unsigned long hash which is sensitive to the
 *              value of the object. Two objects which cmp() equal should
 *              return the same hash.
 *
 *              The returned hash is used in a hash table shared by objects
 *              of all types. So, somewhat problematically, it is desireable
 *              to generate hashes which have good spread and seperation
 *              across all objects.
 *
 *              Some objects are by nature both unique and intrinsically
 *              atomic (for example, objects which are one-to-one with
 *              some other allocated data which they alloc when the are
 *              created and free when they die). For these objects the
 *              existing function hash_unique() can be used as their
 *              implementation of this function.
 *
 * t_assign(o, k, v) Assign to key k of the object o the value v. Return
 *              1 on error, else 0.
 *
 *              The existing function assign_simple() may be used both as
 *              the implementation of this function for object types which
 *              do not support any assignment, and as a simple method of
 *              generating an error for particular assignments which break
 *              some rule of the object.
 *
 *              Not that it is not necessarilly wrong for an intrinsically
 *              atomic object to support some form of assignment. Only for
 *              the modified field to be significant in a cmp() operation.
 *              Objects which are intrinsically unique and atomic often
 *              support assignments.
 *
 * t_fetch(o, k) Fetch the value of key k of the object o. Return NULL on
 *              error.
 *
 *              The existing function fetch_simple() may be used both as
 *              the implementation of this function for object types which
 *              do not support any assignment, and as a simple method of
 *              generating an error for particular fetches which break
 *              some rule of the object.
 *
 * t_name       The name of this type. Use for the implementation of
 *              typeof() and in error messages. But apart from that, type
 *              names have no fundamental importance in the langauge and
 *              need not even be unique.
 *
 * t_objname(o, p) Place a short (30 chars or less) human readable
 *              representation of the object in the given buffer. This
 *              is not intended as a basis for re-parsing or serialisation.
 *              It is just for diagnostics and debug.
 *
 * t_call(o, s) Call the object o. If s is non-NULL this is a method call
 *              and s is the subject object of the call. Return 1 on error,
 *              else 0.
 *
 * t_ici_name   A string_t copy of the name. This is just a cached version
 *              so that typeof() doesn't keep re-computing the string.
 *
 */

#ifndef SMALL
/*
 * Macros to perform the operation on the object.
 */
/*
 * mark()
 *
 * The recursive traversal of all objects performed by marking is particularly
 * expensive. So we take pains to cut short function calls wherever possible.
 * Thus the size of this macro. The o_leafz field of an object tells us it
 * doesn't reference any other objects and is of small (ie o_leafz) size.
 */
#if 1
#define mark(o)         ((objof(o)->o_flags & O_MARK) == 0 \
                            ? (objof(o)->o_leafz != 0 \
                                ? (objof(o)->o_flags |= O_MARK, objof(o)->o_leafz) \
                                : (*ici_typeof(o)->t_mark)(objof(o))) \
                            : 0L)
#else
#define mark(o)         ((objof(o)->o_flags & O_MARK) == 0 \
                            ? (*ici_typeof(o)->t_mark)(objof(o)) \
                            : 0L)
#endif
#define freeo(o)        ((*ici_typeof(o)->t_free)(objof(o)))
#define hash(o)         ((*ici_typeof(o)->t_hash)(objof(o)))
#define cmp(o1,o2)      ((*ici_typeof(o1)->t_cmp)(objof(o1), objof(o2)))
#define fetch(o,k)      ((*ici_typeof(o)->t_fetch)(objof(o), objof(k)))
#define copy(o)         ((*ici_typeof(o)->t_copy)(objof(o)))
#define assign(o,k,v)   ((*ici_typeof(o)->t_assign)(objof(o), objof(k), objof(v)))
#define assign_super(o,k,v,b) ((*ici_typeof(o)->t_assign_super)(objof(o), objof(k), objof(v), b))
#define fetch_super(o,k,v,b) ((*ici_typeof(o)->t_fetch_super)(objof(o), objof(k), v, b))
#define assign_base(o,k,v) ((*ici_typeof(o)->t_assign_base)(objof(o), objof(k), objof(v)))
#define fetch_base(o,k) ((*ici_typeof(o)->t_fetch_base)(objof(o), objof(k)))

/*
 * Link an object into the list of objects. We clear the o_leafz field
 * here because that is the safe thing to do and, as of the introduction
 * of this field, much code does not set this field to zero. Objects
 * that want to take advantage of o_leafz must set it after calling rego().
 */
#define rego(o)         (objof(o)->o_leafz = 0, \
                          (objs_top < objs_limit \
                            ? (void)(*objs_top++ = objof(o)) \
                            : grow_objs(objof(o))))
#else
/*
 * Functions to performs operations on the object.
 */
extern unsigned long    mark(object_t *);
extern void             freeo(object_t *);
extern unsigned long    hash(object_t *);
extern int              cmp(object_t *, object_t *);
extern object_t         *copy(object_t *);
extern object_t         *fetch(object_t *, object_t *);
extern int              assign(object_t *, object_t *, object_t *);
extern void             rego(object_t *);
#endif

#define ici_atom_hash_index(h)  (ICI_PTR_HASH_BITS(h) & (atomsz - 1))


/*
 * References from ordinary machine data objects (ie. variables and stuff,
 * not other objects) are invisible to the garbage collector.  These refs
 * must be accounted for if there is a possibility of garbage collection.
 * Note that most routines that make objects (new_*(), copy() etc...)
 * return objects with 1 ref.  The caller is expected to decref() it when
 * they attach it into wherever it is going.
 */
#ifndef BUGHUNT
#define incref(o)       (++objof(o)->o_nrefs)
#define decref(o)       (--objof(o)->o_nrefs)
#else
void bughunt_incref(object_t *o);
void bughunt_decref(object_t *o);
#define incref(o) bughunt_incref(objof(o))
#define decref(o) bughunt_decref(objof(o))
#endif

/*
 * This is the universal header of all objects.
 */
struct object
{
    char        o_tcode;        /* See TC_* below. */
    char        o_flags;        /* See O_* below. */
    char        o_nrefs;        /* No. of refs invisible to collect. */
    char        o_leafz;        /* Iff a leaf object, its size, else 0. */
    /*
     * Each object includes this as a header.  In the real structures
     * associated with each object type the type specific stuff follows...
     */
};
#define objof(x)        ((object_t *)(x))

/*
 * "Object with super." This is a specialised header for all objects
 * that support a super pointer. All such objects must have the
 * O_SUPER flag set in o_flags and provide the t_fetch_super() and
 * t_assign_super() functions.
 */
struct objwsup
{
    object_t    o_head;         /* Universal header. */
    objwsup_t   *o_super;       /* Out super. May be NULL. */
    /*
     * Each object that supports a super type includes this as a
     * header. In the real structures associated with each such object
     * the type specific stuff follows...
     */
};
#define objwsupof(o)    ((objwsup_t *)(o))
#define hassuper(o)     (objof(o)->o_flags & O_SUPER)

#define ici_typeof(o)   (ici_types[(int)objof(o)->o_tcode])

/*
 * For static object initialisations...
 */
#define OBJ(tc)    {(tc), 0, 1, 0}

/*
 * Flags that may appear in o_flags. The upper nibble is considered available
 * for type specific use.
 */
#define O_MARK          0x01    /* Garbage collection mark. */
#define O_ATOM          0x02    /* Is a member of the atom pool. */
#define O_TEMP          0x04    /* Is a re-usable temp (flag for asserts). */
#define O_SUPER         0x08    /* Has super (is objwsup_t derived). */

/*
 * The o_tcode field is a small int which allows bypassing the o_type
 * pointer for some types.  Any type not listed here will have a value
 * of 0.  The types listed will set a code here to allow some time
 * critical areas of code to make quicker decisions (typically a switch)
 * based on the type.  It also allows faster decisions based on type
 * combinations (see PAIR() and TRI() below).
 */
#define TC_OTHER        0
#define TC_PC           1
#define TC_SRC          2
#define TC_PARSE        3
#define TC_OP           4
#define TC_STRING       5
#define TC_CATCH        6
#define TC_FORALL       7
#define TC_INT          8
#define TC_FLOAT        9
#define TC_REGEXP       10
#define TC_PTR          11
#define TC_ARRAY        12
#define TC_STRUCT       13
#define TC_SET          14

#define TC_MAX_BINOP    14

#define TC_EXEC         15
#define TC_FILE         16
#define TC_FUNC         17
#define TC_CFUNC        18
#define TC_METHOD       19
#define TC_MARK         20
#define TC_NULL         21
#define TC_HANDLE       22
#define TC_SOCKET       23
#define TC_MEM          24

#define TC_MAX_CORE     24

/* Max value of 15 dictated by PAIR (below). */

#define TRI(a,b,t)      (((((a) << 4) + b) << 6) + t_subtype(t))

#define isfalse(o)      ((o) == objof(o_zero) || (o) == objof(&o_null))


/* From alloc.h */


/*
 * Is an object of this type of a size suitable for one of the
 * fast free lists?
 */
#define ICI_FLOK(t)     (sizeof(t) <= 64)

/*
 * Determine what free list an object of the given type is appropriate
 * for, of the size of the object if it is too big. We assume the
 * compiler will reduce this constant expression to a constant at
 * compile time.
 */
#define ICI_FLIST(t)    (sizeof(t) <=  8 ? 0  \
                        : sizeof(t) <= 16 ? 1 \
                        : sizeof(t) <= 32 ? 2 \
                        : sizeof(t) <= 64 ? 3 \
                        : sizeof(t))

/*
 * Allocate an object of the given type. Return NULL on failure, usual
 * conventions. The resulting object *must* be freed with ici_tfree().
 * Note that ici_tfree() also requires to know the type of the object
 * being freed.
 *
 * If the object is too big for a fast free list, this macro should
 * reduce to a simple function call. If it is small, it will reduce
 * to an attempt to pop a block off the correct fast free list, but
 * call the function if the list is empty.
 */
#if     !ICI_ALLALLOC

#define ici_talloc(t)   \
    (ICI_FLOK(t) && (ici_fltmp = ici_flists[ICI_FLIST(t)]) != NULL  \
        ? (ici_flists[ICI_FLIST(t)] = *(char **)ici_fltmp,          \
            ici_mem += sizeof(t),                                   \
            ici_fltmp)                                              \
        : ici_talloc_work(ICI_FLIST(t), sizeof(t)))

#define ici_tfree(p, t) \
    (ICI_FLOK(t)                                        \
        ? (*(char **)(p) = ici_flists[ICI_FLIST(t)],    \
            ici_flists[ICI_FLIST(t)] = (char *)(p),     \
            ici_mem -= sizeof(t))                       \
        : ici_nfree((p), sizeof(t)))

#else

#define ici_talloc(t)   ici_talloc_work(ICI_FLIST(t), sizeof(t))
#define ici_tfree(p, t) ici_nfree((p), sizeof(t))

#endif  /* ICI_ALLALLOC */

extern char             *ici_flists[4];
extern char             *ici_fltmp;
extern long             ici_mem;
extern long             ici_mem_limit;
extern void             *ici_talloc_work(int fi, size_t z);
extern void             *ici_nalloc(size_t z);
extern void             ici_nfree(void *p, size_t z);
extern void             *ici_alloc(size_t z);
extern void             ici_free(void *p);


/* From buf.h */

/*
 * Ensure that buf points to enough memory to hold index n (plus room for
 * a '\0' at the end).
 */
#ifdef  SMALL
#define ici_chkbuf(n)       ici_growbuf(n)
#else
#define ici_chkbuf(n)       (ici_bufz > (int)(n) ? 0 : ici_growbuf(n))
#endif

extern int      ici_growbuf(int);


/* From catch.h */

struct catchs
{
    object_t    o_head;
    object_t    *c_catcher;
    short       c_odepth;       /* Operand stack depth. */
    short       c_vdepth;       /* Variable stack depth. */
};
#define catchof(o)      ((catch_t *)(o))
#define iscatch(o)      ((o)->o_tcode == TC_CATCH)

/*
 * Flags set stored in the upper nibble of o_head.o_flags (which is
 * allowed to be used by objects.
 */
#define CF_EVAL_BASE    0x10    /* ici_evaluate should return. */
#define CF_CRIT_SECT    0x20    /* Critical section guard. */


/* From cfunc.h */


struct cfunc
{
    object_t    o_head;
    char        *cf_name;
    int         (*cf_cfunc)();
    void        *cf_arg1;
    void        *cf_arg2;
};
#define cfuncof(o)      ((cfunc_t *)(o))
#define iscfunc(o)      (objof(o)->o_tcode == TC_CFUNC)

/*
 * Convienience macro for the object header for use in static
 * initialisations of cfunc_t objects.
 */
#define CF_OBJ          {TC_CFUNC, 0, 1, 0}

/*
 * The operand stack on entry to an intrinsic function:
 *
 * arg(n-1) ... arg(1) arg(0) NARGS FUNC
 *                                        ^-ici_os.a_top
 *
 * NARGS is an ICI int and FUNC is the function object (us).
 */

/*
 * The i-th argument (first is 0) during execution of a
 * function's C code.
 */
#define ARG(n)          (ici_os.a_top[-3 - (n)])

/*
 * Count of actual arguments to this C function.
 */
#define NARGS()         ((int)intof(ici_os.a_top[-2])->i_value)

/*
 * A pointer to the first arg to this C function, decrement for next
 * and subsequent.
 */
#define ARGS()          (&ici_os.a_top[-3])

/*
 * Return the cf_arg1 and cf_arg2 fields of the current C function.
 * The first is a function pointer, the second a char *.
 */
#define CF_ARG1()       (cfuncof(ici_os.a_top[-1])->cf_arg1)
#define CF_ARG2()       (cfuncof(ici_os.a_top[-1])->cf_arg2)


/* From array.h */

/*
 * The ICI array object. Array objects are implemented in a manner to
 * make them efficient to use as stacks. And they are used that way in the
 * execution engine. A single contiguous array of object pointers is
 * associated with the array. a_base points to its start, a_limit one
 * past its end and a_bot and a_top somewhere in the middle.
 *
 * In the general case, arrays are growable circular buffers (queues). Thus
 * allowing efficient addition and removal from both ends. However, their
 * use in the internals of the execution engine is only as stacks. For
 * efficiency, we desire to be able to ensure that there is some amount of
 * contiguous space available on a stack by just making a single efficient
 * check.
 *
 * This is easy if they really are stacks, and the bottom is always anchored
 * to the start of allocation. (See Case 1 below.) This condition will
 * be true if *no* rpop() or rpush() operations have been done on the array.
 * Thus we conceptually consider arrays to have two forms. Ones that are
 * stacks (never had rpop() or rpush() done) and ones that are queues
 * (may, possibly, have had rpop() or rpush() done).
 *
 * Now, if an array is still a stack, you can use the functions (macros):
 *     ici_stk_push_chk(a, n)
 *     ici_stk_pop_chk(a, n)
 * to ensure that there are n spaces or objects available, then just
 * increment/decrement a_top as you push and pop things on the stack.
 * Basically you can assume that object pointers and empty slots are
 * contiguous around a_top.
 *
 * But, if you can not guarantee (by context) that the array is a stack,
 * you can only push, pop, rpush or rpop single object pointers at a time.
 * Basically, the end you are dealing with may be near the wrap point of
 * the circular buffer.
 *
 * Case 1: Pure stack. Only ever been push()ed and pop()ed.
 *   ooooooooooooooooooooo.....................
 *   ^a_base              ^a_top               ^a_limit
 *   ^a_bot
 *
 * Case 2: Queue. rpush() and/or rpop()s have been done.
 *   ..........ooooooooooooooooooo.............
 *   ^a_base   ^a_bot             ^a_top       ^a_limit
 *
 * Case 3: Queue that has wrapped.
 *   oooooooooooooo.................ooooooooooo
 *   ^a_base       ^a_top           ^a_bot     ^a_limit
 *
 * A data structure such as this should really use an integer count
 * to indicate how many used elements there are. By using pure pointers
 * we have to keep one empty slot so we don't find ourselves unable
 * to distinguish full from empty (a_top == a_bot). But by using simple
 * pointers, only a_top needs to change as we push and pop elements.
 * If a_top == a_bot, the array is empty.
 *
 * Note that one must never take the atomic form of a stack, and
 * assume the result is still a stack.
 */
struct array
{
    object_t    o_head;
    object_t    **a_top;    /* The next free slot. */
    object_t    **a_bot;    /* The first used slot. */
    object_t    **a_base;   /* The base of allocation. */
    object_t    **a_limit;  /* Allocation limit, first one you can't use. */
};
#define arrayof(o)  ((array_t *)(o))
#define isarray(o)  ((o)->o_tcode == TC_ARRAY)

/*
 * Check that there is room for n new elements on the end of a.  May
 * reallocate array memory to get more room. Return non-zero on failure,
 * usual conventions.
 *
 * This macro can only be used where the array has never had elements
 * rpush()ed or rpop()ed.
 */
#define ici_stk_push_chk(a, n) \
                ((a)->a_limit - (a)->a_top < (n) ? ici_grow_stack((a), (n)) : 0)

/*
 * Ensure that the stack a has i as a valid index.  Will grow and NULL fill
 * as necessary. Return non-zero on failure, usual conventions.
 */
#define ici_stk_probe(a, i) ((a)->a_top - (a)->a_bot <= (i) \
                ? ici_fault_stack((a), (i)) \
                : 0)

/*
 * Macros to assist in doing for for loop over the elements of an array.
 * Use as:
 *    object **e;
 *    for (e = ici_astart(a); e < ici_alimit(a); e = ici_anext(a, e))
 *        ...
 */
#define ici_astart(a)   ((a)->a_bot == (a)->a_limit ? (a)->a_base : (a)->a_bot)
#define ici_alimit(a)   ((a)->a_top)
#define ici_anext(a, e) ((e) + 1 == (a)->a_limit && (a)->a_limit != (a)->a_top \
                            ? (a)->a_base : (e) + 1)

/* From int.h */

struct ints
{
    object_t    o_head;
    long        i_value;
};
#define intof(o)        ((int_t *)(o))
#define isint(o)        ((o)->o_tcode == TC_INT)

/* From float.h */

struct floats
{
    object_t    o_head;
    double      f_value;
};
#define floatof(o)      ((float_t *)o)
#define isfloat(o)      ((o)->o_tcode == TC_FLOAT)

/* From exec.h */

#ifndef NODEBUGGING

/*
 * ICI debug interface.  exec() calls the functions in this interface
 * if debugging is enabled.  A default interface, with stubbed
 * implementations of these functions, is provided in the ICI core
 * (in idb2.c).  Debuggers will normally override the default with
 * a more useful set of functions.
 */
struct debug
{
    void    (*idbg_error)(char *, src_t *);
    void    (*idbg_fncall)(object_t *, object_t **, int);
    void    (*idbg_fnresult)(object_t *);
    void    (*idbg_src)(src_t *);
    void    (*idbg_watch)(object_t *, object_t *, object_t *);
};

#endif

/* From file.h */


struct ftype
{
    int         (*ft_getch)();
    int         (*ft_ungetch)();
    int         (*ft_putch)();
    int         (*ft_flush)();
    int         (*ft_close)();
    long        (*ft_seek)();
    int         (*ft_eof)();
    int         (*ft_write)();
};

struct file
{
    object_t    o_head;
    char        *f_file;
    ftype_t     *f_type;
    string_t    *f_name;    /* Reasonable name to call it by. */
};
#define fileof(o)   ((file_t *)(o))
#define isfile(o)   (objof(o)->o_tcode == TC_FILE)

#define F_CLOSED    0x10

/* From forall.h */

struct forall
{
    object_t    o_head;
    int         fa_index;
    object_t    *fa_objs[6];
};
#define fa_aggr         fa_objs[0]
#define fa_code         fa_objs[1]
#define fa_vaggr        fa_objs[2]
#define fa_vkey         fa_objs[3]
#define fa_kaggr        fa_objs[4]
#define fa_kkey         fa_objs[5]

#define forallof(o)     ((forall_t *)o)
#define isforall(o)     ((o)->o_tcode == TC_FORALL)

/* From func.h */

struct func
{
    object_t    o_head;
    array_t     *f_code;        /* The code of this function, atom. */
    array_t     *f_args;        /* Array of argument names. */
    struct_t    *f_autos;       /* Prototype struct of autos (incl. args). */
    string_t    *f_name;        /* Some name for the function (diagnostics). */
};

#define funcof(o)       ((func_t *)(o))
#define isfunc(o)       (objof(o)->o_tcode == TC_FUNC)


/* From handle.h */

/*
 * A handle is a generic object that can be used to refer to some C data
 * object. It supports a super pointer. This can be used to (a) identify
 * a handle as being associated with a particular C data type, and (b) to
 * provide objects of the same type with a class full of methods to operate
 * on the objects of that type.
 */
struct ici_handle
{
    objwsup_t   o_head;
    void        *h_ptr;
    string_t    *h_name;
};
#define handleof(o)        ((ici_handle_t *)(o))
#define ishandle(o)        (objof(o)->o_tcode == TC_HANDLE)

/* From mark.h */


/*
 * Mark objects are used in a few placed in the interpreter when we need
 * an object that we can guarantee is distinct from any object a user
 * could give us. One use is as the 'label' on the default clause of
 * the struct that represents a switch statement.
 */
struct marks
{
    object_t    o_head;
};
#define markof(o)       ((mark_t *)o)
#define ismark(o)       ((o) == objof(&o_mark))

/* From mem.h */

struct mem
{
    object_t            o_head;
    void                *m_base;
    size_t              m_length;       /* In m_accessz units. */
    int                 m_accessz;      /* Read/write size. */
    void                (*m_free)();
};

#define memof(o)        ((mem_t *)o)
#define ismem(o)        (objof(o)->o_tcode == TC_MEM)

/* From method.h */

struct method
{
    object_t    o_head;
    object_t    *m_subject;
    object_t    *m_callable;
};
#define methodof(o)     ((method_t *)(o))
#define ismethod(o)     (objof(o)->o_tcode == TC_METHOD)


/* From null.h */

struct null
{
    object_t    o_head;
};
#define nullof(o)       ((null_t *)o)
#define isnull(o)       ((o) == objof(&o_null))


/* From op.h */

struct op
{
    object_t    o_head;
    int         (*op_func)();
    int         op_ecode;       /* See OP_* below. */
    int         op_code;
};
#define opof(o) ((op_t *)o)
#define isop(o) ((o)->o_tcode == TC_OP)


/* From parse.h */

typedef struct
{
    int         t_what;         /* See TM_* and T_* below. */
    union
    {
        long    tu_int;
        double  tu_float;
        char    *tu_str;        /* Malloced string. */
        object_t *tu_obj;
    }
        tu;
}
    token_t;

#define t_int   tu.tu_int
#define t_float tu.tu_float
#define t_str   tu.tu_str
#define t_obj   tu.tu_obj

struct parse
{
    object_t    o_head;
    file_t      *p_file;
    int         p_lineno;       /* Diagnostic information. */
    short       p_sol;          /* At first char in line. */
    short       p_cr;           /* New-line cause by \r, not \n. */
    token_t     p_got;
    token_t     p_ungot;
    func_t      *p_func;        /* NULL when not within scope. */
    int         p_module_depth; /* Depth within module, 0 is file level. */
};
#define isparse(o)      (objof(o)->o_tcode == TC_PARSE)
#define parseof(o)      ((parse_t *)(o))

/* From pc.h */

struct pc
{
    object_t    o_head;
    array_t     *pc_code;
    object_t    **pc_next;
    object_t    **pc_limit;
};
#define pcof(o)         ((pc_t *)o)
#define ispc(o)         ((o)->o_tcode == TC_PC)

/* From ptr.h */

struct ptr
{
    object_t    o_head;
    object_t    *p_aggr;        /* The aggregate which contains the object. */
    object_t    *p_key;         /* The key which references it. */
};
#define ptrof(o)        ((ptr_t *)o)
#define isptr(o)        ((o)->o_tcode == TC_PTR)

/* From re.h */

#define regexpof(o)     ((regexp_t *)(o))
#define isregexp(o)     ((o)->o_tcode == TC_REGEXP)

extern int
ici_pcre(regexp_t *r,
    const char *subject, int length, int start_offset,
    int options, int *offsets, int offsetcount);



/* From set.h */

struct sets
{
    object_t    o_head;
    int         s_nels;         /* How many slots used. */
    int         s_nslots;       /* How many slots allocated. */
    object_t    **s_slots;
};
#define setof(o)        ((set_t *)(o))
#define isset(o)        ((o)->o_tcode == TC_SET)

/* From skt.h */


#ifdef _WIN32
/*
 * Windows uses a special type to represent its SOCKET descriptors.
 * For correctness we include winsock.h here. Other platforms (i.e.,
 * BSD) are easier and use integers.
 */
#include <winsock.h>
#else
#define SOCKET  int
#endif

struct skt
{
    object_t    o_head;
    SOCKET      s_skt;
    int         s_closed;
};
#define sktof(o)        ((skt_t *)(o))
#define isskt(o)        (objof(o)->o_tcode == TC_SOCKET)

/* From src.h */


struct src
{
    object_t    s_head;
    int         s_lineno;
    string_t    *s_filename;
};
#define srcof(o)        ((src_t *)o)
#define issrc(o)        ((o)->o_tcode == TC_SRC)

/* From str.h */


struct string
{
    object_t    o_head;
    struct_t    *s_struct;      /* Where we were last found on the vs. */
    slot_t      *s_slot;        /* And our slot. */
    long        s_vsver;        /* The vs version at that time. */
    unsigned long s_hash;       /* String hash code or 0 if not yet computed */
    int         s_nchars;
    char        s_chars[1];     /* And following bytes. */
};
#define stringof(o)     ((string_t *)o)
#define isstring(o)     ((o)->o_tcode == TC_STRING)

/*
 * This flag indicates that the lookup-lookaside mechanism is referencing
 * an atomic struct. It is stored in the allowed area of o_flags in o_head.
 */
#define S_LOOKASIDE_IS_ATOM 0x10

/*
 * Macros to assist external modules in getting ICI strings. To use, make
 * an include file called "icistr.h" with your strings, and what you want to
 * call them by, formatted like this:
 *
 *  ICI_STR(fred, "fred")
 *  ICI_STR(amp, "&")
 *
 * etc. Include that file in any files that access ICI strings.
 * Access them with either ICIS(fred) or ICISO(fred) which return
 * string_t* and object_t* pointers respectively. For example:
 *
 *  o = fetch(s, ICIS(fred));
 *
 * Next, in one of your source file, include the special include file
 * "icistr-setup.h". This will (a) declare pointers to the string objects,
 * and (b) define a function (init_ici_str()) that initialises those pointers.
 *
 * Finally, call init_ici_str() at startup. It returns 1 on error, usual
 * conventions.
 */
#define ICIS(name)              (ici_str_##name)
#define ICISO(name)             (objof(ICIS(name)))
#define ICI_STR_NORM(name, str) extern string_t *ici_str_##name;
#define ICI_STR_DECL(name, str) string_t *ici_str_##name;
#define ICI_STR_MAKE(name, str) (ICIS(name) = new_cname(str)) == NULL ||
#define ICI_STR_REL(name, str)  decref(ICIS(name));
#define ICI_STR                 ICI_STR_NORM

/* From struct.h */


struct slot
{
    object_t    *sl_key;
    object_t    *sl_value;
};

struct structs
{
    objwsup_t   o_head;
    int         s_nels;         /* How many slots used. */
    int         s_nslots;       /* How many slots allocated. */
    slot_t      *s_slots;
};
#define structof(o)     ((struct_t *)(o))
#define isstruct(o)     (objof(o)->o_tcode == TC_STRUCT)


/* From trace.h */


extern int trace_yes;
extern int trace_flags;

#define TRACE_LEXER         1
#define TRACE_EXPR          2
#define TRACE_INTRINSICS    4
#define TRACE_FUNCS         8
#define TRACE_MEM           16
#define TRACE_SRC           32
#define TRACE_GC            64

#define TRACE_ALL       (TRACE_EXPR|TRACE_FUNCS|TRACE_GC)

/* From wrap.h */


struct wrap
{
    wrap_t      *w_next;
    int         (*w_func)();
};

extern DLI wrap_t       *wraps;

#ifdef __cplusplus
}
#endif

#endif /* ICI_ICI_H */
