<MML>
<Include "ici-fmt.mml">
<Heading2><Marker <MType 2> <MText `ICI_NO_OLD_NAMES, C API macro'> >ICI_NO_OLD_NAMES
<CodeIn1cm>\ <bold>#define\ ICI_NO_OLD_NAMES<HardSpace><HardSpace>...<nobold>
<Comment From fwd.h>
<Body>This define may be made before an include of <italic>ici.h<noitalic> to suppress a group
of old (backward compatible) names. These names have been upgraded to
have <italic>ici_<noitalic> prefixes since version 4.0.4. These names don't effect the
binary interface of the API; they are all type or macro names. But you
might want to suppress them if you get a clash with some other include
file (for example, <italic>file_t<noitalic> has been known to clash with defines in
<italic>\<file.h\><noitalic> on some systems).
<Body>If you just was to get rid of one or two defines, you can <italic>#undef<noitalic> them
after the include of <italic>ici.h<noitalic>.
<Body>The names this define supresses are:
<CodeIn1cm>\ array_t\ \ \ \ \ float_t\ \ \ \ \ object_t\ \ \ \ catch_t<HardReturn>
slot_t\ \ \ \ \ \ set_t\ \ \ \ \ \ \ struct_t\ \ \ \ exec_t<HardReturn>
file_t\ \ \ \ \ \ func_t\ \ \ \ \ \ cfunc_t\ \ \ \ \ method_t<HardReturn>
int_t\ \ \ \ \ \ \ mark_t\ \ \ \ \ \ null_t\ \ \ \ \ \ objwsup_t<HardReturn>
op_t\ \ \ \ \ \ \ \ pc_t\ \ \ \ \ \ \ \ ptr_t\ \ \ \ \ \ \ regexp_t<HardReturn>
src_t\ \ \ \ \ \ \ string_t\ \ \ \ type_t\ \ \ \ \ \ wrap_t<HardReturn>
ftype_t\ \ \ \ \ forall_t\ \ \ \ parse_t\ \ \ \ \ mem_t<HardReturn>
debug_t
<Heading2><Marker <MType 2> <MText `ici_alloc, C API function'> >ici_alloc
<CodeIn1cm>\ <bold>void\ *\ ici_alloc(size_t\ z)
<nobold>
<Comment From alloc.c>
<Body>Allocate a block of size <italic>z<noitalic>. This just maps to a raw malloc() but
does garbage collection as necessary and attempts to track memory
usage to control when the garbage collector runs. Blocks allocated
with this must be freed with ici_free().
<Body>It is preferable to use ici_talloc(), or failing that, ici_nalloc(),
instead of this function. But both require that you can match the
allocation by calling ici_tfree() or ici_nalloc() with the original
type/size you passed in the allocation call. Those functions use
dense fast free lists for small objects, and track memory usage
better.
<Body>See also: <italic>ICIs allocation functions<noitalic>, ici_free(), ici_talloc(),
ici_nalloc().
<Heading2><Marker <MType 2> <MText `ici_argcount, C API function'> >ici_argcount
<CodeIn1cm>\ <bold>int\ ici_argcount(int\ n)
<nobold>
<Comment From cfunc.c>
<Body>Generate a generic error message to indicate that the wrong number of
arguments have been supplied to an intrinsic function, and that it really
(or most commonly) takes <italic>n<noitalic>.  This function sets the error descriptor
(ici_error) to a message like:
<CodeIn1cm>\ %d\ arguments\ given\ to\ %s,\ but\ it\ takes\ %d
<Body>and then returns 1.
<Body>This function may only be called from the implementation of an intrinsic
function.  It takes the number of actual argument and the function name
from the current operand stack, which therefore should not have been
distured (which is normal for intrincic functions).  It takes the number of
arguments the function should have been supplied with (or typically is)
from <italic>n<noitalic>.  This function is typically used from C coded functions that are
not using ici_typecheck() to process arguments.  For example, a function
that just takes a single object as an argument might start:
<CodeIn1cm>\ static\ int<HardReturn>
myfunc()<HardReturn>
{<HardReturn>
\ \ \ \ ici_obj_t\ \ *o;
<HardReturn><HardReturn>
\ \ \ \ if\ (NARGS()\ !=\ 1)<HardReturn>
\ \ \ \ \ \ \ \ return\ ici_argcount(1);<HardReturn>
\ \ \ \ o\ =\ ARG(0);<HardReturn>
\ \ \ \ .\ .\ .
<Heading2><Marker <MType 2> <MText `ici_argerror, C API function'> >ici_argerror
<CodeIn1cm>\ <bold>int\ ici_argerror(int\ i)
<nobold>
<Comment From cfunc.c>
<Body>Generate a generic error message to indicate that argument i of the current
intrinsic function is bad.  Despite being generic, this message is
generally pretty informative and useful.  It has the form:
<CodeIn1cm>\ argument\ %d\ of\ %s\ incorrectly\ supplied\ as\ %s
<Body>The argument number is base 0.  I.e.  ici_argerror(0) indicates the 1st
argument is bad.
<Body>The function returns 1, for use in a direct return from an intrinsic
function.
<Body>This function may only be called from the implementation of an intrinsic
function.  It takes the function name from the current operand stack, which
therefore should not have been distured (which is normal for intrincic
functions).  This function is typically used from C coded functions that
are not using ici_typecheck() to process arguments.  For example, a
function that just takes a single mem object as an argument might start:
<CodeIn1cm>\ static\ int<HardReturn>
myfunc()<HardReturn>
{<HardReturn>
\ \ \ \ ici_obj_t\ \ *o;
<HardReturn><HardReturn>
\ \ \ \ if\ (NARGS()\ !=\ 1)<HardReturn>
\ \ \ \ \ \ \ \ return\ ici_argcount(1);<HardReturn>
\ \ \ \ if\ (!ismem(ARG(0)))<HardReturn>
\ \ \ \ \ \ \ \ return\ ici_argerror(0);<HardReturn>
\ \ \ \ .\ .\ .
<Heading2><Marker <MType 2> <MText `ici_array_gather, C API function'> >ici_array_gather
<CodeIn1cm>\ <bold>void\ ici_array_gather(ici_obj_t\ **b,\ ici_array_t\ *a,\ ptrdiff_t\ start,\ ptrdiff_t\ n)
<nobold>
<Comment From array.c>
<Body>Copy <italic>n<noitalic> object pointers from the given array, starting at index <italic>start<noitalic>,
to <italic>b<noitalic>.  The span must cover existing elements of the array (that is, don't
try to read from negative or excessive indexes).
<Body>This function is used to copy objects out of an array into a contiguous
destination area.  You can't easily just memcpy, because the span of
elements you want may wrap around the end.  For example, the implementaion
of interval() uses this to copy the span of elements it wants into a new
array.
<Heading2><Marker <MType 2> <MText `ici_array_get, C API function'> >ici_array_get
<CodeIn1cm>\ <bold>ici_obj_t\ *\ ici_array_get(ici_array_t\ *a,\ ptrdiff_t\ i)
<nobold>
<Comment From array.c>
<Body>Return the element or the array <italic>a<noitalic> from index <italic>i<noitalic>, or <italic>ici_null<noitalic> if out of
range.  No incref is done on the object.
<Heading2><Marker <MType 2> <MText `ici_array_nels, C API function'> >ici_array_nels
<CodeIn1cm>\ <bold>ptrdiff_t\ ici_array_nels(ici_array_t\ *a)
<nobold>
<Comment From array.c>
<Body>Return the number of elements in the array <italic>a<noitalic>.
<Heading2><Marker <MType 2> <MText `ici_array_new, C API function'> >ici_array_new
<CodeIn1cm>\ <bold>ici_array_t\ *\ ici_array_new(ptrdiff_t\ n)
<nobold>
<Comment From array.c>
<Body>Return a new array.  It will have room for at least <italic>n<noitalic> elements to be
pushed contigously (that is, there is no need to use ici_stk_push_chk() for
objects pushed immediately, up to that limit).  If <italic>n<noitalic> is 0 an internal
default will be used.  The returned array has ref count 1.  Returns NULL on
failure, usual conventions.
<Heading2><Marker <MType 2> <MText `ici_array_new, C API function'> >ici_array_new
<CodeIn1cm>\ <bold>ici_array_t\ *\ ici_array_new(ptrdiff_t\ n)
<nobold>
<Comment From array.c>
<Body>Return a new array.  It will have room for at least <italic>n<noitalic> elements to be
pushed contigously (that is, there is no need to use ici_stk_push_chk() for
objects pushed immediately, up to that limit).  If <italic>n<noitalic> is 0 an internal
default will be used.  The returned array has ref count 1.  Returns NULL on
failure, usual conventions.
<Heading2><Marker <MType 2> <MText `ici_array_pop, C API function'> >ici_array_pop
<CodeIn1cm>\ <bold>ici_obj_t\ *\ ici_array_pop(ici_array_t\ *a)
<nobold>
<Comment From array.c>
<Body>Pop and return the top of the given array, or <italic>ici_null<noitalic> if it is empty.
Returns NULL on error (for example, attempting to pop and atomic array).
Usual error conventions.
<Heading2><Marker <MType 2> <MText `ici_array_push, C API function'> >ici_array_push
<CodeIn1cm>\ <bold>int\ ici_array_push(ici_array_t\ *a,\ ici_obj_t\ *o)
<nobold>
<Comment From array.c>
<Body>Push the object <italic>o<noitalic> onto the end of the array <italic>a<noitalic>. This is the general
case that works for any array whether it is a stack or a queue.
On return, o_top[-1] is the object pushed. Returns 1 on error, else 0,
usual error conventions.
<Heading2><Marker <MType 2> <MText `ici_array_rpop, C API function'> >ici_array_rpop
<CodeIn1cm>\ <bold>ici_obj_t\ *\ ici_array_rpop(ici_array_t\ *a)
<nobold>
<Comment From array.c>
<Body>Pop and return the front of the given array, or <italic>ici_null<noitalic> if it is empty.
Returns NULL on error (for example, attempting to pop and atomic array).
Usual error conventions.
<Heading2><Marker <MType 2> <MText `ici_array_rpush, C API function'> >ici_array_rpush
<CodeIn1cm>\ <bold>int\ ici_array_rpush(ici_array_t\ *a,\ ici_obj_t\ *o)
<nobold>
<Comment From array.c>
<Body>Push the object <italic>o<noitalic> onto the front of the array <italic>a<noitalic>. Return 1 on failure,
else 0, usual error conventions.
<Heading2><Marker <MType 2> <MText `ici_assign_cfuncs, C API function'> >ici_assign_cfuncs
<CodeIn1cm>\ <bold>int\ ici_assign_cfuncs(ici_objwsup_t\ *s,\ ici_cfunc_t\ *cf)
<nobold>
<Comment From cfunco.c>
<Body>Assign the structure s all the intrinsic functions listed in the array
of ici_cfunc_t structures pointed to by cf. The array must be terminated by
an entry with a cf_name of NULL. Typically, entries in the array are
formated as:
<CodeIn1cm>\ {CF_OBJ,\ \ \ \ "func",\ \ \ \ \ f_func},
<Body>Where CF_OBJ is a convenience macro from to take care of the
normal object header, "func" is the name your function will be assigned
to in the given struct, and <italic>f_func<noitalic> is a C function obeying the rules
of ICI intrinsic functions.
<Body>Returns non-zero on error, in which case error is set, else zero.
<Heading2><Marker <MType 2> <MText `ici_call, C API function'> >ici_call
<CodeIn1cm>\ <bold>int\ ici_call(ici_str_t\ *func_name,\ char\ *types,\ ...)
<nobold>
<Comment From call.c>
<Body>Call an ICI function by name from C with simple argument types and
return value.  The name (<italic>func_name<noitalic>) is looked up in the current scope.
<Body>See <italic>ici_func()<noitalic> for an explanation of <italic>types<noitalic>. Apart from taking a name,
rather than an ICI function object, this function behaves in the same
manner as <italic>ici_func()<noitalic>.
<Body>There is some historical support for <italic>@<noitalic> operators, but it is deprecated
and may be removed in future versions.
<Heading2><Marker <MType 2> <MText `ici_call, C API function'> >ici_call
<CodeIn1cm>\ <bold>int\ ici_call(ici_str_t\ *func_name,\ char\ *types,\ ...)
<nobold>
<Comment From call.c>
<Body>Call an ICI function by name from C with simple argument types and
return value.  The name (<italic>func_name<noitalic>) is looked up in the current scope.
<Body>See <italic>ici_func()<noitalic> for an explanation of <italic>types<noitalic>. Apart from taking a name,
rather than an ICI function object, this function behaves in the same
manner as <italic>ici_func()<noitalic>.
<Body>There is some historical support for <italic>@<noitalic> operators, but it is deprecated
and may be removed in future versions.
<Heading2><Marker <MType 2> <MText `ici_callv, C API function'> >ici_callv
<CodeIn1cm>\ <bold>int\ ici_callv(ici_str_t\ *func_name,\ char\ *types,\ va_list\ va)
<nobold>
<Comment From call.c>
<Body>Varient of <italic>ici_call()<noitalic> (see) taking a variable argument list.
<Body>There is some historical support for <italic>@<noitalic> operators, but it is deprecated
and may be removed in future versions.
<Heading2><Marker <MType 2> <MText `ici_chkbuf, C API macro'> >ici_chkbuf
<CodeIn1cm>\ <bold>#define\ ici_chkbuf(n)<HardSpace><HardSpace>...<nobold>
<Comment From buf.h>
<Body>Ensure that <italic>ici_buf<noitalic> points to enough memory to hold index <italic>n<noitalic> (plus
room for a nul char at the end). Returns 0 on success, else 1 and
sets <italic>ici_error<noitalic>.
<Body>See also: <italic>The error return convention<noitalic>.
<Heading2><Marker <MType 2> <MText `ici_chkbuf, C API macro'> >ici_chkbuf
<CodeIn1cm>\ <bold>#define\ ici_chkbuf(n)<HardSpace><HardSpace>...<nobold>
<Comment From buf.h>
<Body>Ensure that <italic>ici_buf<noitalic> points to enough memory to hold index <italic>n<noitalic> (plus
room for a nul char at the end). Returns 0 on success, else 1 and
sets <italic>ici_error<noitalic>.
<Body>See also: <italic>The error return convention<noitalic>.
<Heading2><Marker <MType 2> <MText `ici_class_new, C API function'> >ici_class_new
<CodeIn1cm>\ <bold>ici_objwsup_t\ *\ ici_class_new(ici_cfunc_t\ *cf,\ ici_objwsup_t\ *super)
<nobold>
<Comment From cfunco.c>
<Body>Create a new class struct and assign the given cfuncs into it (as in
ici_assign_cfuncs()).  If <italic>super<noitalic> is NULL, the super of the new struct is
set to the outer-most writeable struct in the current scope.  Thus this is
a new top-level class (not derived from anything).  If super is non-NULL,
it is presumably the parent class and is used directly as the super.
Returns NULL on error, usual conventions.  The returned struct has an
incref the caller owns.
<Heading2><Marker <MType 2> <MText `ici_def_cfuncs, C API function'> >ici_def_cfuncs
<CodeIn1cm>\ <bold>int\ ici_def_cfuncs(ici_cfunc_t\ *cf)
<nobold>
<Comment From cfunco.c>
<Body>Define the given intrinsic functions in the current static scope.
See ici_assign_cfuncs() for details.
<Body>Returns non-zero on error, in which case error is set, else zero.
<Heading2><Marker <MType 2> <MText `ici_float_ret, C API function'> >ici_float_ret
<CodeIn1cm>\ <bold>int\ ici_float_ret(double\ ret)
<nobold>
<Comment From cfunc.c>
<Body>Use <italic>return ici_float_ret(n);<noitalic> to return a float from an intrinsic fuction.
<Heading2><Marker <MType 2> <MText `ici_free, C API function'> >ici_free
<CodeIn1cm>\ <bold>void\ ici_free(void\ *p)
<nobold>
<Comment From alloc.c>
<Body>Free a block allocated with ici_alloc().
<Body>See also: <italic>ICIs allocation functions<noitalic>, ici_alloc(), ici_tfree(),
ici_nfree().
<Heading2><Marker <MType 2> <MText `ici_free, C API function'> >ici_free
<CodeIn1cm>\ <bold>void\ ici_free(void\ *p)
<nobold>
<Comment From alloc.c>
<Body>Free a block allocated with ici_alloc().
<Body>See also: <italic>ICIs allocation functions<noitalic>, ici_alloc(), ici_tfree(),
ici_nfree().
<Heading2><Marker <MType 2> <MText `ici_func, C API function'> >ici_func
<CodeIn1cm>\ <bold>int\ ici_func(ici_obj_t\ *callable,\ char\ *types,\ ...)
<nobold>
<Comment From call.c>
<Body>Call a callable ICI object <italic>callable<noitalic> from C with simple argument
marshalling and an optional return value.  The callable object is typically
a function (but not a function name, see <italic>ici_call<noitalic> for that case).
<Body><italic>types<noitalic> is a string that indicates what C values are being supplied as
arguments.  It can be of the form ".=..." or "..." where the dots represent
type key letters as described below.  In the first case the 1st extra
argument is used as a pointer to store the return value through.  In the
second case, the return value of the ICI function is not provided.
<Body>Type key letters are:
<TagIn4cm><italic>i<noitalic><Tab>The corresponding argument should be a C long
                     (a pointer to a long in the case of a return value).
                     It will be converted to an ICI <italic>int<noitalic> and passed
                     to the function.
<TagIn4cm><italic>f<noitalic><Tab>The corresponding argument should be a C double.
                     (a pointer to a double in the case of a return value).
                     It will be converted to an ICI <italic>float<noitalic> and passed
                     to the function.
<TagIn4cm><italic>s<noitalic><Tab>The corresponding argument should be a nul
                     terminated string (a pointer to a char * in the case
                     of a return value).  It will be converted to an ICI
                     <italic>string<noitalic> and passed to the function.
<TagIn4cm><Tab>                     When a string is returned it is a pointer to the
                     character data of an internal ICI string object.  It
                     will only remain valid until the next call to any ICI
                     function.
<TagIn4cm><italic>o<noitalic><Tab>The corresponding argument should be a pointer
                     to an ICI object (a pointer to an object in the case
                     of a return value).  It will be passed directly to the
                     ICI function.
<TagIn4cm><Tab>                     When an object is returned it has been ici_incref()ed
                     (that is, it is held against garbage collection).
<Body>Returns 0 on success, else 1, in which case ici_error has been set.
<Body>See also: ici_callv(), ici_method(), ici_call(), ici_funcv().
<Heading2><Marker <MType 2> <MText `ici_funcv, C API function'> >ici_funcv
<CodeIn1cm>\ <bold>int\ ici_funcv(ici_obj_t\ *subject,\ ici_obj_t\ *callable,\ char\ *types,\ va_list\ va)
<nobold>
<Comment From call.c>
<Body>This function is a variation on <italic>ici_func()<noitalic>. See that function for details
on the meaning of the <italic>types<noitalic> argument.
<Body><italic>va<noitalic> is a va_list (variable argument list) passed from an outer var-args
function.
<Body>If <italic>subject<noitalic> is NULL, then <italic>callable<noitalic> is taken to be a callable object
(could be a function, a method, or something else) and is called directly.
If <italic>subject<noitalic> is non-NULL, it is taken to be an instance object and
<italic>callable<noitalic> should be the name of one of its methods (i.e. an <italic>ici_str_t *<noitalic>).
<Heading2><Marker <MType 2> <MText `ici_incref, C API macro'> >ici_incref
<CodeIn1cm>\ <bold>#define\ ici_incref(o)<HardSpace><HardSpace>...<nobold>
<Comment From object.h>
<Body>References from ordinary machine data objects (ie. variables and stuff,
not other objects) are invisible to the garbage collector.  These refs
must be accounted for if there is a possibility of garbage collection.
Note that most routines that make objects (new_*(), copy() etc...)
return objects with 1 ref.  The caller is expected to ici_decref() it when
they attach it into wherever it is going.
<Heading2><Marker <MType 2> <MText `ici_init, C API function'> >ici_init
<CodeIn1cm>\ <bold>int\ ici_init(void)
<nobold>
<Comment From init.c>
<Body>Perform basic interpreter setup. Return non-zero on failure, usual
conventions.
<Body>After calling this the scope stack has a struct for autos on it, and
the super of that is for statics. That struct for statics is where
global definitions that are likely to be visible to all code tend
to get set. All the intrinsic functions for example. It forms the
extern scope of any files parsed at the top level.
<Body>In systems supporting threads, on exit, the global ICI mutex has been
acquired (with ici_enter()).
<Heading2><Marker <MType 2> <MText `ici_int_ret, C API function'> >ici_int_ret
<CodeIn1cm>\ <bold>int\ ici_int_ret(long\ ret)
<nobold>
<Comment From cfunc.c>
<Body>Use <italic>return ici_int_ret(n);<noitalic> to return an integer from an intrinsic fuction.
<Heading2><Marker <MType 2> <MText `ici_interface_check, C API function'> >ici_interface_check
<CodeIn1cm>\ <bold>int\ ici_interface_check(unsigned\ long\ mver,\ unsigned\ long\ bver,\ char\ const\ *name)
<nobold>
<Comment From init.c>
<Body>Check that the seperately compiled module that calls this function has been
compiled against a compatible versions of the ICI core that is now trying
to load it. An external module should call this like:
<CodeIn1cm>\ if\ (ici_interface_check(ICI_VER,\ ICI_BACK_COMPAT_VER,\ "myname"))<HardReturn>
\ \ \ \ return\ NULL;
<Body>As soon as it can on load.  ICI_VER and ICI_BACK_COMPAT_VER come from ici.h
at the time that module was compiled.  This functions compares the values
passed from the external modules with the values the core was compiled
with, and fails (usual conventions) if there is any incompatibility.
<Heading2><Marker <MType 2> <MText `ici_interface_check, C API function'> >ici_interface_check
<CodeIn1cm>\ <bold>int\ ici_interface_check(unsigned\ long\ mver,\ unsigned\ long\ bver,\ char\ const\ *name)
<nobold>
<Comment From init.c>
<Body>Check that the seperately compiled module that calls this function has been
compiled against a compatible versions of the ICI core that is now trying
to load it. An external module should call this like:
<CodeIn1cm>\ if\ (ici_interface_check(ICI_VER,\ ICI_BACK_COMPAT_VER,\ "myname"))<HardReturn>
\ \ \ \ return\ NULL;
<Body>As soon as it can on load.  ICI_VER and ICI_BACK_COMPAT_VER come from ici.h
at the time that module was compiled.  This functions compares the values
passed from the external modules with the values the core was compiled
with, and fails (usual conventions) if there is any incompatibility.
<Heading2><Marker <MType 2> <MText `ici_method, C API function'> >ici_method
<CodeIn1cm>\ <bold>int\ ici_method(ici_obj_t\ *inst,\ ici_str_t\ *mname,\ char\ *types,\ ...)
<nobold>
<Comment From call.c>
<Body>Call the method <italic>mname<noitalic> of the object <italic>inst<noitalic> with simple argument
marshalling.
<Body>See <italic>ici_func()<noitalic> for an explanation of <italic>types<noitalic>. Apart from calling
a method, this function behaves in the same manner as <italic>ici_func()<noitalic>.
<Heading2><Marker <MType 2> <MText `ici_module_new, C API function'> >ici_module_new
<CodeIn1cm>\ <bold>ici_objwsup_t\ *\ ici_module_new(ici_cfunc_t\ *cf)
<nobold>
<Comment From cfunco.c>
<Body>Create a new module struct and assign the given cfuncs into it (as in
ici_assign_cfuncs()).  Returns NULL on error, usual conventions.  The
returned struct has an incref the caller owns.
<Heading2><Marker <MType 2> <MText `ici_module_new, C API function'> >ici_module_new
<CodeIn1cm>\ <bold>ici_objwsup_t\ *\ ici_module_new(ici_cfunc_t\ *cf)
<nobold>
<Comment From cfunco.c>
<Body>Create a new module struct and assign the given cfuncs into it (as in
ici_assign_cfuncs()).  Returns NULL on error, usual conventions.  The
returned struct has an incref the caller owns.
<Heading2><Marker <MType 2> <MText `ici_nalloc, C API function'> >ici_nalloc
<CodeIn1cm>\ <bold>void\ *\ ici_nalloc(size_t\ z)
<nobold>
<Comment From alloc.c>
<Body>Allocate an object of the given <italic>size<noitalic>.  Return NULL on failure, usual
conventions.  The resulting object must be freed with ici_nfree() and only
ici_nfree().  Note that ici_nfree() also requires to know the size of the
object being freed.
<Body>This function is preferable to ici_alloc(). It should be used if
you can know the size of the allocation when the free happens so
you can call ici_nfree(). If this isn't the case you will have to
use ici_alloc().
<Body>See also: <italic>ICIs allocation functions<noitalic>, ici_talloc(), ici_alloc(),
ici_nfree().
<Heading2><Marker <MType 2> <MText `ici_nfree, C API function'> >ici_nfree
<CodeIn1cm>\ <bold>void\ ici_nfree(void\ *p,\ size_t\ z)
<nobold>
<Comment From alloc.c>
<Body>Free an object allocated with ici_nalloc(). The <italic>size<noitalic> passed here
must be exactly the same size passed to ici_nalloc() when the
allocation was made. If you don't know the size, you should have
called ici_alloc() in the first place.
<Body>See also: <italic>ICIs allocation functions<noitalic>, ici_nalloc().
<Heading2><Marker <MType 2> <MText `ici_obj, C API struct'> >ici_obj
<CodeIn1cm>\ <bold>struct\ ici_obj<HardReturn>
{<HardReturn>
\ \ \ \ char\ \ \ \ \ \ \ \ o_tcode;<HardReturn>
\ \ \ \ char\ \ \ \ \ \ \ \ o_flags;<HardReturn>
\ \ \ \ char\ \ \ \ \ \ \ \ o_nrefs;<HardReturn>
\ \ \ \ char\ \ \ \ \ \ \ \ o_leafz;<HardReturn>
}<nobold>
<Comment From object.h>
<Body>This is the universal header of all objects.  Each object includes this as
a header.  In the real structures associated with each object type the type
specific stuff follows
<Comment From object.h>
<TagIn4cm><italic>o_tcode<noitalic><Tab>The small integer type code that characterises
                     this object. Standard core types have well known
                     codes identified by the TC_* defines below. Other
                     types are registered at run-time and are given
                     the next available code.
<TagIn4cm><Tab>                     This code can be used to index ici_types[] to discover
                     a pointer to the type structure (see above).
<TagIn4cm><italic>o_flags<noitalic><Tab>Some boolean flags. Well known flags that apply to
                     all object occupy the lower 4 bits of this byte.
                     The upper four bits are available for object specific
                     use. See O_* below.
<TagIn4cm><italic>o_nrefs<noitalic><Tab>A small integer count of the number of references
                     to this object that are *not* otherwise visible
                     to the garbage collector.
<TagIn4cm><italic>o_leafz<noitalic><Tab>If (and only if) this object does not reference any
                     other objects (i.e. its t_mark() function just sets
                     the O_MARK flag), and its memory cost fits in this
                     signed byte (\< 127), then its size can be set here
                     to accelerate the marking phase of the garbage
                     collector. Else it must be zero.
<Heading2><Marker <MType 2> <MText `ici_obj, C API struct'> >ici_obj
<CodeIn1cm>\ <bold>struct\ ici_obj<HardReturn>
{<HardReturn>
\ \ \ \ char\ \ \ \ \ \ \ \ o_tcode;<HardReturn>
\ \ \ \ char\ \ \ \ \ \ \ \ o_flags;<HardReturn>
\ \ \ \ char\ \ \ \ \ \ \ \ o_nrefs;<HardReturn>
\ \ \ \ char\ \ \ \ \ \ \ \ o_leafz;<HardReturn>
}<nobold>
<Comment From object.h>
<Body>This is the universal header of all objects.  Each object includes this as
a header.  In the real structures associated with each object type the type
specific stuff follows
<Comment From object.h>
<TagIn4cm><italic>o_tcode<noitalic><Tab>The small integer type code that characterises
                     this object. Standard core types have well known
                     codes identified by the TC_* defines below. Other
                     types are registered at run-time and are given
                     the next available code.
<TagIn4cm><Tab>                     This code can be used to index ici_types[] to discover
                     a pointer to the type structure (see above).
<TagIn4cm><italic>o_flags<noitalic><Tab>Some boolean flags. Well known flags that apply to
                     all object occupy the lower 4 bits of this byte.
                     The upper four bits are available for object specific
                     use. See O_* below.
<TagIn4cm><italic>o_nrefs<noitalic><Tab>A small integer count of the number of references
                     to this object that are *not* otherwise visible
                     to the garbage collector.
<TagIn4cm><italic>o_leafz<noitalic><Tab>If (and only if) this object does not reference any
                     other objects (i.e. its t_mark() function just sets
                     the O_MARK flag), and its memory cost fits in this
                     signed byte (\< 127), then its size can be set here
                     to accelerate the marking phase of the garbage
                     collector. Else it must be zero.
<Heading2><Marker <MType 2> <MText `ici_objname, C API function'> >ici_objname
<CodeIn1cm>\ <bold>char\ *\ ici_objname(char\ p[ICI_OBJNAMEZ],\ ici_obj_t\ *o)
<nobold>
<Comment From object.c>
<Body>Format a human readable version of the object in less than 30 chars.
Returns <italic>p<noitalic>.
<Heading2><Marker <MType 2> <MText `ici_register_type, C API function'> >ici_register_type
<CodeIn1cm>\ <bold>int\ ici_register_type(ici_type_t\ *t)
<nobold>
<Comment From object.c>
<Body>Register a new <italic>ici_type_t<noitalic> structure and return a new small int type code
to use in the header of objects of that type. The pointer <italic>t<noitalic> passed to
this function is retained and assumed to remain valid indefinetly
(it is normally a statically initialised structure).
<Body>Returns the new type code, or zero on error in which case ici_error
has been set.
<Heading2><Marker <MType 2> <MText `ici_register_type, C API function'> >ici_register_type
<CodeIn1cm>\ <bold>int\ ici_register_type(ici_type_t\ *t)
<nobold>
<Comment From object.c>
<Body>Register a new <italic>ici_type_t<noitalic> structure and return a new small int type code
to use in the header of objects of that type. The pointer <italic>t<noitalic> passed to
this function is retained and assumed to remain valid indefinetly
(it is normally a statically initialised structure).
<Body>Returns the new type code, or zero on error in which case ici_error
has been set.
<Heading2><Marker <MType 2> <MText `ici_ret_no_decref, C API function'> >ici_ret_no_decref
<CodeIn1cm>\ <bold>int\ ici_ret_no_decref(ici_obj_t\ *o)
<nobold>
<Comment From cfunc.c>
<Body>General way out of an intrinsic function returning the object o where
the given object has no extra refernce count. Returns 0 indicating no
error.
<Body>This is suitable for using as a return from an intrinsic function
as say:
<CodeIn1cm>\ return\ ici_ret_no_decref(o);
<Body>If the object you are returning has an extra reference which must be
decremented as part of the return, use ici_ret_with_decref() (above).
<Heading2><Marker <MType 2> <MText `ici_ret_with_decref, C API function'> >ici_ret_with_decref
<CodeIn1cm>\ <bold>int\ ici_ret_with_decref(ici_obj_t\ *o)
<nobold>
<Comment From cfunc.c>
<Body>General way out of an intrinsic function returning the object <italic>o<noitalic>, but
the given object has a reference count which must be decref'ed on the
way out. Return 0 unless the given <italic>o<noitalic> is NULL, in which case it returns
1 with no other action.
<Body>This is suitable for using as a return from an intrinsic function
as say:
<CodeIn1cm>\ return\ ici_ret_with_decref(objof(ici_int_new(2)));
<Body>(Although see ici_int_ret().) If the object you wish to return does
not have an extra reference, use ici_ret_no_decref().
<Heading2><Marker <MType 2> <MText `ici_str_alloc, C API function'> >ici_str_alloc
<CodeIn1cm>\ <bold>ici_str_t\ *\ ici_str_alloc(int\ nchars)
<nobold>
<Comment From string.c>
<Body>Allocate a new string object (single allocation) large enough to hold
nchars characters, and register it with the garbage collector.  Note: This
string is not yet an atom, but must become so as it is *not* mutable.
<Body>WARINING: This is *not* the normal way to make a string object. See
ici_str_new().
<Heading2><Marker <MType 2> <MText `ici_str_buf_new, C API function'> >ici_str_buf_new
<CodeIn1cm>\ <bold>ici_str_t\ *\ ici_str_buf_new(int\ n)
<nobold>
<Comment From string.c>
<Body>Return a new mutable string (i.e. one with a seperate growable allocation).
The initially allocated space is n, but the length is 0 until it has been
set by the caller.
<Body>The returned string has a reference count of 1 (which is caller is
expected to decrement, eventually).
<Body>Returns NULL on error, usual conventions.
<Heading2><Marker <MType 2> <MText `ici_str_get_nul_term, C API function'> >ici_str_get_nul_term
<CodeIn1cm>\ <bold>ici_str_t\ *\ ici_str_get_nul_term(char\ *p)
<nobold>
<Comment From string.c>
<Body>Make a new atomic immutable string from the given characters.
<Body>The returned string has a reference count of 0, unlike
ici_str_new_nul_term() which is exactly the same in other respects.
<Body>Returns NULL on error, usual conventions.
<Heading2><Marker <MType 2> <MText `ici_str_need_size, C API function'> >ici_str_need_size
<CodeIn1cm>\ <bold>int\ ici_str_need_size(ici_str_t\ *s,\ int\ n)
<nobold>
<Comment From string.c>
<Body>Ensure that the given string has enough allocated memory to hold a string
of n characters (and a guard <italic>\0<noitalic> which this routine stores).  Grows ths
string as necessary.  Returns 0 on success, 1 on error, usual conventions.
Checks that the string is mutable and not atomic.
<Heading2><Marker <MType 2> <MText `ici_str_need_size, C API function'> >ici_str_need_size
<CodeIn1cm>\ <bold>int\ ici_str_need_size(ici_str_t\ *s,\ int\ n)
<nobold>
<Comment From string.c>
<Body>Ensure that the given string has enough allocated memory to hold a string
of n characters (and a guard <italic>\0<noitalic> which this routine stores).  Grows ths
string as necessary.  Returns 0 on success, 1 on error, usual conventions.
Checks that the string is mutable and not atomic.
<Heading2><Marker <MType 2> <MText `ici_str_new, C API function'> >ici_str_new
<CodeIn1cm>\ <bold>ici_str_t\ *\ ici_str_new(char\ *p,\ int\ nchars)
<nobold>
<Comment From string.c>
<Body>Make a new atomic immutable string from the given characters.
<Body>Note that the memory allocated to a string is always at least one byte
larger than the listed size and the extra byte contains a <italic>\0<noitalic>.  For
when a C string is needed.
<Body>The returned string has a reference count of 1 (which is caller is
expected to decrement, eventually).
<Body>Returns NULL on error, usual conventions.
<Heading2><Marker <MType 2> <MText `ici_str_new_nul_term, C API function'> >ici_str_new_nul_term
<CodeIn1cm>\ <bold>ici_str_t\ *\ ici_str_new_nul_term(char\ *p)
<nobold>
<Comment From string.c>
<Body>Make a new atomic immutable string from the given characters.
<Body>The returned string has a reference count of 1 (which is caller is
expected to decrement, eventually).
<Body>Returns NULL on error, usual conventions.
<Heading2><Marker <MType 2> <MText `ici_str_ret, C API function'> >ici_str_ret
<CodeIn1cm>\ <bold>int\ ici_str_ret(char\ *str)
<nobold>
<Comment From cfunc.c>
<Body>Use <italic>return ici_str_ret(n);<noitalic> to return a string from an intrinsic fuction.
<Heading2><Marker <MType 2> <MText `ici_str_ret, C API function'> >ici_str_ret
<CodeIn1cm>\ <bold>int\ ici_str_ret(char\ *str)
<nobold>
<Comment From cfunc.c>
<Body>Use <italic>return ici_str_ret(n);<noitalic> to return a string from an intrinsic fuction.
<Heading2><Marker <MType 2> <MText `ici_type, C API struct'> >ici_type
<CodeIn1cm>\ <bold>struct\ ici_type<HardReturn>
{<HardReturn>
\ \ \ \ unsigned\ long\ (*t_mark)(ici_obj_t\ *);<HardReturn>
\ \ \ \ void\ \ \ \ \ \ \ \ (*t_free)(ici_obj_t\ *);<HardReturn>
\ \ \ \ unsigned\ long\ (*t_hash)(ici_obj_t\ *);<HardReturn>
\ \ \ \ int\ \ \ \ \ \ \ \ \ (*t_cmp)(ici_obj_t\ *,\ ici_obj_t\ *);<HardReturn>
\ \ \ \ ici_obj_t\ \ \ *(*t_copy)(ici_obj_t\ *);<HardReturn>
\ \ \ \ int\ \ \ \ \ \ \ \ \ (*t_assign)(ici_obj_t\ *,\ ici_obj_t\ *,\ ici_obj_t\ *);<HardReturn>
\ \ \ \ ici_obj_t\ \ \ *(*t_fetch)(ici_obj_t\ *,\ ici_obj_t\ *);<HardReturn>
\ \ \ \ char\ \ \ \ \ \ \ \ *t_name;<HardReturn>
\ \ \ \ void\ \ \ \ \ \ \ \ (*t_objname)(ici_obj_t\ *,\ char\ [ICI_OBJNAMEZ]);<HardReturn>
\ \ \ \ int\ \ \ \ \ \ \ \ \ (*t_call)(ici_obj_t\ *,\ ici_obj_t\ *);<HardReturn>
\ \ \ \ ici_str_t\ \ \ *t_ici_name;<HardReturn>
\ \ \ \ int\ \ \ \ \ \ \ \ \ (*t_assign_super)(ici_obj_t\ *,\ ici_obj_t\ *,\ ici_obj_t\ *,\ ici_struct_t\ *);<HardReturn>
\ \ \ \ int\ \ \ \ \ \ \ \ \ (*t_fetch_super)(ici_obj_t\ *,\ ici_obj_t\ *,\ ici_obj_t\ **,\ ici_struct_t\ *);<HardReturn>
\ \ \ \ int\ \ \ \ \ \ \ \ \ (*t_assign_base)(ici_obj_t\ *,\ ici_obj_t\ *,\ ici_obj_t\ *);<HardReturn>
\ \ \ \ ici_obj_t\ \ \ *(*t_fetch_base)(ici_obj_t\ *,\ ici_obj_t\ *);<HardReturn>
\ \ \ \ ici_obj_t\ \ \ *(*t_fetch_method)(ici_obj_t\ *,\ ici_obj_t\ *);<HardReturn>
\ \ \ \ void\ \ \ \ \ \ \ \ *t_reserved2;\ \ \ /*\ Must\ be\ zero.\ */<HardReturn>
\ \ \ \ void\ \ \ \ \ \ \ \ *t_reserved3;\ \ \ /*\ Must\ be\ zero.\ */<HardReturn>
\ \ \ \ void\ \ \ \ \ \ \ \ *t_reserved4;\ \ \ /*\ Must\ be\ zero.\ */<HardReturn>
}<nobold>
<Comment From object.h>
<Body>Every object has a header. In the header the o_tcode (type code) field
can be used to index the ici_types[] array to discover the obejct's
type structure. This is the type structure. See detailed comments below.
<Comment From object.h>
<TagIn4cm><italic>t_mark(o)<noitalic><Tab>Sets the O_MARK flag in o-\>o_flags of this object and
                     all objects referenced by this one which don't already
                     have O_MARK set.  Returns the approximate memory cost
                     of this and all other objects it sets the O_MARK of.
                     Typically recurses on all referenced objects which
                     don't already have O_MARK set (this recursion is a
                     potential problem due to the uncontrolled stack depth
                     it can create).  This is used in the marking phase of
                     garbage collection.
<TagIn4cm><Tab>                     The macro ici_mark() calls the t_mark function of the
                     object (based on object type) if the O_MARK flag of
                     the object is clear, else it returns 0.  This is the
                     usual interface to an object's mark function.
<TagIn4cm><Tab>                     The mark function implemantation of objects can assume
                     the O_MARK flag of the object they are being invoked
                     on is clear.
<TagIn4cm><italic>t_free(o)<noitalic><Tab>Frees the object o and all associated data, but not
                     other objects which are referenced from it.  This is
                     only called from garbage collection.  Care should be
                     taken to remember that errors can occur during object
                     creation and that the free function might be asked to
                     free a partially allocated object.
<TagIn4cm><italic>t_cmp(o1, o2)<noitalic><Tab>Compare o1 and o2 and return 0 if they are the same,
                     else non zero.  This similarity is the basis for
                     merging objects into single atomic objects and the
                     implementation of the == operator.
<TagIn4cm><Tab>                     Some objects are by nature both unique and
                     intrinsically atomic (for example, objects which are
                     one-to-one with some other allocated data which they
                     alloc when the are created and free when they die).
                     For these objects the existing function
                     ici_cmp_unique() can be used as their implementation
                     of this function.
<TagIn4cm><Tab>                     It is very important in implementing this function not
                     to miss any fields which may otherwise distinguish two
                     obejcts.  The cmp, hash and copy operations of an
                     object are all related.  It is useful to check that
                     they all regard the same data fields as significant in
                     performing their operation.
<TagIn4cm><italic>t_copy(o)<noitalic><Tab>Returns a copy of the given object. This is the basis
                     for the implementation of the copy() function.  On
                     failure, NULL is returned and error is set.  The
                     returned object has been ici_incref'ed.  The returned
                     object should cmp() as being equal, but be a distinct
                     object for objects that are not intrinsically atomic.
<TagIn4cm><Tab>                     Intrinsically atomic objects may use the existing
                     function ici_copy_simple() as their implemenation of
                     this function.
<TagIn4cm><italic>t_hash(o)<noitalic><Tab>Return an unsigned long hash which is sensitive to the
                     value of the object.  Two objects which cmp() equal
                     should return the same hash.
<TagIn4cm><Tab>                     The returned hash is used in a hash table shared by
                     objects of all types.  So, somewhat problematically,
                     it is desireable to generate hashes which have good
                     spread and seperation across all objects.
<TagIn4cm><Tab>                     Some objects are by nature both unique and
                     intrinsically atomic (for example, objects which are
                     one-to-one with some other allocated data which they
                     alloc when the are created and free when they die).
                     For these objects the existing function hash_unique()
                     can be used as their implementation of this function.
<TagIn4cm><italic>t_assign(o, k, v)<noitalic><Tab>Assign to key k of the object o the value v. Return
                     1 on error, else 0.
<TagIn4cm><Tab>                     The existing function ici_assign_fail() may be used
                     both as the implementation of this function for object
                     types which do not support any assignment, and as a
                     simple method of generating an error for particular
                     assignments which break some rule of the object.
<TagIn4cm><Tab>                     Not that it is not necessarilly wrong for an
                     intrinsically atomic object to support some form of
                     assignment.  Only for the modified field to be
                     significant in a cmp() operation.  Objects which are
                     intrinsically unique and atomic often support
                     assignments.
<TagIn4cm><italic>t_fetch(o, k)<noitalic><Tab>Fetch the value of key k of the object o.  Return
                     NULL on error.
<TagIn4cm><Tab>                     Note that the returned object does not have any extra
                     reference count; however, in some circumstances it may
                     not have any garbage collector visible references to
                     it.  That is, it may be vunerable to a garbage
                     collection if it is not either incref()ed or hooked
                     into a referenced object immediately.  Callers are
                     responsible for taking care.
<TagIn4cm><Tab>                     The existing function ici_fetch_fail() may be used
                     both as the implementation of this function for object
                     types which do not support any assignment, and as a
                     simple method of generating an error for particular
                     fetches which break some rule of the object.
<TagIn4cm><italic>t_name<noitalic><Tab>The name of this type. Use for the implementation of
                     typeof() and in error messages.  But apart from that,
                     type names have no fundamental importance in the
                     langauge and need not even be unique.
<TagIn4cm><italic>t_objname(o, p)<noitalic><Tab>Place a short (30 chars or less) human readable
                     representation of the object in the given buffer.
                     This is not intended as a basis for re-parsing or
                     serialisation.  It is just for diagnostics and debug.
                     An implementation of t_objname() must not allocate
                     memory or otherwise allow the garbage collector to
                     run.  It is often used to generate formatted failure
                     messages after an error has occured, but before
                     cleanup has completed.
<TagIn4cm><italic>t_call(o, s)<noitalic><Tab>Call the object o. If s is non-NULL this is a method
                     call and s is the subject object of the call.  Return
                     1 on error, else 0.
<TagIn4cm><italic>t_ici_name<noitalic><Tab>A ici_str_t copy of the name. This is just a cached
                     version so that typeof() doesn't keep re-computing the
                     string.
<TagIn4cm><italic>t_fetch_method<noitalic><Tab>An optional alternative to the basic t_fetch() that
                     will be called (if supplied) when doing a fetch for
                     the purpose of forming a method.  This is really only
                     a hack to support COM under Windows.  COM allows
                     remote objects to have properties, like
                     object.property, and methods, like object:method().
                     But without this special hack, we can't tell if a
                     fetch operation is supposed to perform the COM get/set
                     property operation, or return a callable object for a
                     future method call.  Most objects will leave this
                     NULL.
<Heading2><Marker <MType 2> <MText `ici_typecheck, C API function'> >ici_typecheck
<CodeIn1cm>\ <bold>int\ ici_typecheck(char\ *types,\ ...)
<nobold>
<Comment From cfunc.c>
<Body>Marshall function argument in a call from ICI to C.  The argspec is a
character string.  Each character corresponds to an actual argument to the
ICI function which will (may) be assigned through the corresponding pointer
taken from the subsequent arguments.  Any detected type mismatches result
in a non-zero return.  If all types match, all assignments will be made and
zero will be returned.
<Body>The argspec key letters and their meaning are:
<TagIn4cm><italic>o<noitalic><Tab>Any ICI object is required in the actuals, the
                     corresponding pointer must be a pointer to an
                     <italic>(ici_obj_t *)<noitalic>; which will be set to the actual
                     argument.
<TagIn4cm><italic>h<noitalic><Tab>An ICI handle object, that has the name given by
                     the corresponding argument, is required. The next
                     argument is a pointer to store the <italic>(handle_t *)<noitalic>
                     through.
<TagIn4cm><italic>p<noitalic><Tab>An ICI ptr object is required in the actuals, then as
                     for o.
<TagIn4cm><italic>d<noitalic><Tab>An ICI struct object is required in the actuals, then
                     as for o.
<TagIn4cm><italic>a<noitalic><Tab>An ICI array object is required in the actuals, then
                     as for o.
<TagIn4cm><italic>u<noitalic><Tab>An ICI file object is required in the actuals, then as
                     for o.
<TagIn4cm><italic>r<noitalic><Tab>An ICI regexp object is required in the actuals, then
                     as for o.
<TagIn4cm><italic>m<noitalic><Tab>An ICI mem object is required in the actuals, then as
                     for o.
<TagIn4cm><italic>i<noitalic><Tab>An ICI int object is required in the actuals, the
                     value of this int will be stored through the
                     corresponding pointer which must be a (long *).
<TagIn4cm><italic>f<noitalic><Tab>An ICI float object is required in the actuals, the
                     value of this float will be stored through the
                     corresponding pointer which must be a (double *).
<TagIn4cm><italic>n<noitalic><Tab>An ICI float or int object is required in the actuals,
                     the value of this float or int will be stored through
                     the corresponding pointer which must be a (double *).
<TagIn4cm><italic>s<noitalic><Tab>An ICI string object is required in the actuals, the
                     corresponding pointer must be a (char **).  A pointer
                     to the raw characters of the string will be stored
                     through this (this will be <italic>\0<noitalic> terminated by virtue
                     of all ICI strings having a gratuitous <italic>\0<noitalic> just past
                     their real end).
<TagIn4cm><italic>-<noitalic><Tab>The acutal parameter at this position is skipped, but
                     it must be present.
<TagIn4cm><italic>*<noitalic><Tab>All remaining actual parametes are ignored (even if
                     there aren't any).
<Body>The capitalisation of any of the alphabetic key letters above changes
their meaning.  The acutal must be an ICI ptr type.  The value this
pointer points to is taken to be the value which the above descriptions
concern themselves with (i.e. in place of the raw actual parameter).
<Body>There must be exactly as many actual arguments as key letters unless
the last key letter is a *.
<Body>Error returns have the usual ICI error conventions.
