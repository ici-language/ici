<MML>
<Include "ici-fmt.mml">
<Heading2><Marker <MType 2> <MText `ICI_NO_OLD_NAMES, C API macro'> >ICI_NO_OLD_NAMES
<CodeIn1cm>\ <bold>#define\ ICI_NO_OLD_NAMES<HardSpace><HardSpace>...<nobold>
<Comment From fwd.h>
<Body>This define may be made before an include of <italic>ici.h<noitalic> to suppress a group
of old (backward compatible) names. These names have been upgraded to
have <italic>ici_<noitalic> prefixes since version 4.0.4. These names don't effect the
binary interface of the API; they are all type or macro names. But you
might want to suppress them if you get a clash with some other include
file (for example, <italic>file_t<noitalic> has been known to clash with defines in
<italic>\<file.h\><noitalic> on some systems).
<Body>If you just was to get rid of one or two defines, you can <italic>#undef<noitalic> them
after the include of <italic>ici.h<noitalic>.
<Body>The names this define supresses are:
<CodeIn1cm>\ array_t\ \ \ \ \ float_t\ \ \ \ \ object_t\ \ \ \ catch_t<HardReturn>
slot_t\ \ \ \ \ \ set_t\ \ \ \ \ \ \ struct_t\ \ \ \ exec_t<HardReturn>
file_t\ \ \ \ \ \ func_t\ \ \ \ \ \ cfunc_t\ \ \ \ \ method_t<HardReturn>
int_t\ \ \ \ \ \ \ mark_t\ \ \ \ \ \ null_t\ \ \ \ \ \ objwsup_t<HardReturn>
op_t\ \ \ \ \ \ \ \ pc_t\ \ \ \ \ \ \ \ ptr_t\ \ \ \ \ \ \ regexp_t<HardReturn>
src_t\ \ \ \ \ \ \ string_t\ \ \ \ type_t\ \ \ \ \ \ wrap_t<HardReturn>
ftype_t\ \ \ \ \ forall_t\ \ \ \ parse_t\ \ \ \ \ mem_t<HardReturn>
debug_t
<Heading2><Marker <MType 2> <MText `ICI_NO_OLD_NAMES, C API macro'> >ICI_NO_OLD_NAMES
<CodeIn1cm>\ <bold>#define\ ICI_NO_OLD_NAMES<HardSpace><HardSpace>...<nobold>
<Comment From fwd.h>
<Body>This define may be made before an include of <italic>ici.h<noitalic> to suppress a group
of old (backward compatible) names. These names have been upgraded to
have <italic>ici_<noitalic> prefixes since version 4.0.4. These names don't effect the
binary interface of the API; they are all type or macro names. But you
might want to suppress them if you get a clash with some other include
file (for example, <italic>file_t<noitalic> has been known to clash with defines in
<italic>\<file.h\><noitalic> on some systems).
<Body>If you just was to get rid of one or two defines, you can <italic>#undef<noitalic> them
after the include of <italic>ici.h<noitalic>.
<Body>The names this define supresses are:
<CodeIn1cm>\ array_t\ \ \ \ \ float_t\ \ \ \ \ object_t\ \ \ \ catch_t<HardReturn>
slot_t\ \ \ \ \ \ set_t\ \ \ \ \ \ \ struct_t\ \ \ \ exec_t<HardReturn>
file_t\ \ \ \ \ \ func_t\ \ \ \ \ \ cfunc_t\ \ \ \ \ method_t<HardReturn>
int_t\ \ \ \ \ \ \ mark_t\ \ \ \ \ \ null_t\ \ \ \ \ \ objwsup_t<HardReturn>
op_t\ \ \ \ \ \ \ \ pc_t\ \ \ \ \ \ \ \ ptr_t\ \ \ \ \ \ \ regexp_t<HardReturn>
src_t\ \ \ \ \ \ \ string_t\ \ \ \ type_t\ \ \ \ \ \ wrap_t<HardReturn>
ftype_t\ \ \ \ \ forall_t\ \ \ \ parse_t\ \ \ \ \ mem_t<HardReturn>
debug_t
<Heading2><Marker <MType 2> <MText `ici_alloc, C API function'> >ici_alloc
<CodeIn1cm>\ <bold>void\ *\ ici_alloc(size_t\ z)
<nobold>
<Comment From alloc.c>
<Body>Allocate a block of size <italic>z<noitalic>. This just maps to a raw malloc() but
does garbage collection as necessary and attempts to track memory
usage to control when the garbage collector runs. Blocks allocated
with this must be freed with ici_free().
<Body>It is preferable to use ici_talloc(), or failing that, ici_nalloc(),
instead of this function. But both require that you can match the
allocation by calling ici_tfree() or ici_nalloc() with the original
type/size you passed in the allocation call. Those functions use
dense fast free lists for small objects, and track memory usage
better.
<Body>See also: <italic>ICIs allocation functions<noitalic>, ici_free(), ici_talloc(),
ici_nalloc().
<Heading2><Marker <MType 2> <MText `ici_argcount, C API function'> >ici_argcount
<CodeIn1cm>\ <bold>int\ ici_argcount(int\ n)
<nobold>
<Comment From cfunc.c>
<Body>Generate a generic error message to indicate that the wrong number of
arguments have been supplied to an intrinsic function, and that it really
(or most commonly) takes <italic>n<noitalic>.  This function sets the error descriptor
(ici_error) to a message like:
<CodeIn1cm>\ %d\ arguments\ given\ to\ %s,\ but\ it\ takes\ %d
<Body>and then returns 1.
<Body>This function may only be called from the implementation of an intrinsic
function.  It takes the number of actual argument and the function name
from the current operand stack, which therefore should not have been
distured (which is normal for intrincic functions).  It takes the number of
arguments the function should have been supplied with (or typically is)
from <italic>n<noitalic>.  This function is typically used from C coded functions that are
not using ici_typecheck() to process arguments.  For example, a function
that just takes a single object as an argument might start:
<CodeIn1cm>\ static\ int<HardReturn>
myfunc()<HardReturn>
{<HardReturn>
\ \ \ \ ici_obj_t\ \ *o;
<HardReturn><HardReturn>
\ \ \ \ if\ (NARGS()\ !=\ 1)<HardReturn>
\ \ \ \ \ \ \ \ return\ ici_argcount(1);<HardReturn>
\ \ \ \ o\ =\ ARG(0);<HardReturn>
\ \ \ \ .\ .\ .
<Heading2><Marker <MType 2> <MText `ici_argerror, C API function'> >ici_argerror
<CodeIn1cm>\ <bold>int\ ici_argerror(int\ i)
<nobold>
<Comment From cfunc.c>
<Body>Generate a generic error message to indicate that argument i of the current
intrinsic function is bad.  Despite being generic, this message is
generally pretty informative and useful.  It has the form:
<CodeIn1cm>\ argument\ %d\ of\ %s\ incorrectly\ supplied\ as\ %s
<Body>The argument number is base 0.  I.e.  ici_argerror(0) indicates the 1st
argument is bad.
<Body>The function returns 1, for use in a direct return from an intrinsic
function.
<Body>This function may only be called from the implementation of an intrinsic
function.  It takes the function name from the current operand stack, which
therefore should not have been distured (which is normal for intrincic
functions).  This function is typically used from C coded functions that
are not using ici_typecheck() to process arguments.  For example, a
function that just takes a single mem object as an argument might start:
<CodeIn1cm>\ static\ int<HardReturn>
myfunc()<HardReturn>
{<HardReturn>
\ \ \ \ ici_obj_t\ \ *o;
<HardReturn><HardReturn>
\ \ \ \ if\ (NARGS()\ !=\ 1)<HardReturn>
\ \ \ \ \ \ \ \ return\ ici_argcount(1);<HardReturn>
\ \ \ \ if\ (!ismem(ARG(0)))<HardReturn>
\ \ \ \ \ \ \ \ return\ ici_argerror(0);<HardReturn>
\ \ \ \ .\ .\ .
<Heading2><Marker <MType 2> <MText `ici_array_gather, C API function'> >ici_array_gather
<CodeIn1cm>\ <bold>void\ ici_array_gather(ici_obj_t\ **b,\ ici_array_t\ *a,\ ptrdiff_t\ start,\ ptrdiff_t\ n)
<nobold>
<Comment From array.c>
<Body>Copy <italic>n<noitalic> object pointers from the given array, starting at index <italic>start<noitalic>,
to <italic>b<noitalic>.  The span must cover existing elements of the array (that is, don't
try to read from negative or excessive indexes).
<Body>This function is used to copy objects out of an array into a contiguous
destination area.  You can't easily just memcpy, because the span of
elements you want may wrap around the end.  For example, the implementaion
of interval() uses this to copy the span of elements it wants into a new
array.
<Heading2><Marker <MType 2> <MText `ici_array_get, C API function'> >ici_array_get
<CodeIn1cm>\ <bold>ici_obj_t\ *\ ici_array_get(ici_array_t\ *a,\ ptrdiff_t\ i)
<nobold>
<Comment From array.c>
<Body>Return the element or the array <italic>a<noitalic> from index <italic>i<noitalic>, or <italic>ici_null<noitalic> if out of
range.  No incref is done on the object.
<Heading2><Marker <MType 2> <MText `ici_array_nels, C API function'> >ici_array_nels
<CodeIn1cm>\ <bold>ptrdiff_t\ ici_array_nels(ici_array_t\ *a)
<nobold>
<Comment From array.c>
<Body>Return the number of elements in the array <italic>a<noitalic>.
<Heading2><Marker <MType 2> <MText `ici_array_new, C API function'> >ici_array_new
<CodeIn1cm>\ <bold>ici_array_t\ *\ ici_array_new(ptrdiff_t\ n)
<nobold>
<Comment From array.c>
<Body>Return a new array.  It will have room for at least <italic>n<noitalic> elements to be
pushed contigously (that is, there is no need to use ici_stk_push_chk() for
objects pushed immediately, up to that limit).  If <italic>n<noitalic> is 0 an internal
default will be used.  The returned array has ref count 1.  Returns NULL on
failure, usual conventions.
<Heading2><Marker <MType 2> <MText `ici_array_new, C API function'> >ici_array_new
<CodeIn1cm>\ <bold>ici_array_t\ *\ ici_array_new(ptrdiff_t\ n)
<nobold>
<Comment From array.c>
<Body>Return a new array.  It will have room for at least <italic>n<noitalic> elements to be
pushed contigously (that is, there is no need to use ici_stk_push_chk() for
objects pushed immediately, up to that limit).  If <italic>n<noitalic> is 0 an internal
default will be used.  The returned array has ref count 1.  Returns NULL on
failure, usual conventions.
<Heading2><Marker <MType 2> <MText `ici_array_pop, C API function'> >ici_array_pop
<CodeIn1cm>\ <bold>ici_obj_t\ *\ ici_array_pop(ici_array_t\ *a)
<nobold>
<Comment From array.c>
<Body>Pop and return the top of the given array, or <italic>ici_null<noitalic> if it is empty.
Returns NULL on error (for example, attempting to pop and atomic array).
Usual error conventions.
<Heading2><Marker <MType 2> <MText `ici_array_push, C API function'> >ici_array_push
<CodeIn1cm>\ <bold>int\ ici_array_push(ici_array_t\ *a,\ ici_obj_t\ *o)
<nobold>
<Comment From array.c>
<Body>Push the object <italic>o<noitalic> onto the end of the array <italic>a<noitalic>. This is the general
case that works for any array whether it is a stack or a queue.
On return, o_top[-1] is the object pushed. Returns 1 on error, else 0,
usual error conventions.
<Heading2><Marker <MType 2> <MText `ici_array_rpop, C API function'> >ici_array_rpop
<CodeIn1cm>\ <bold>ici_obj_t\ *\ ici_array_rpop(ici_array_t\ *a)
<nobold>
<Comment From array.c>
<Body>Pop and return the front of the given array, or <italic>ici_null<noitalic> if it is empty.
Returns NULL on error (for example, attempting to pop and atomic array).
Usual error conventions.
<Heading2><Marker <MType 2> <MText `ici_array_rpush, C API function'> >ici_array_rpush
<CodeIn1cm>\ <bold>int\ ici_array_rpush(ici_array_t\ *a,\ ici_obj_t\ *o)
<nobold>
<Comment From array.c>
<Body>Push the object <italic>o<noitalic> onto the front of the array <italic>a<noitalic>. Return 1 on failure,
else 0, usual error conventions.
<Heading2><Marker <MType 2> <MText `ici_call, C API function'> >ici_call
<CodeIn1cm>\ <bold>int\ ici_call(ici_str_t\ *func_name,\ char\ *types,\ ...)
<nobold>
<Comment From call.c>
<Body>ici_call(name, types, args...)
<Body>Call an ici function by name from C with simple argument types and
return value.  The named is looked up in the current scope or in
a supplied struct.
<Body>Types can be of the forms ".=...", ".@.=...", ".@..." or "...".
In the first case the 1st extra arg is used as a pointer to store the
return value through. In the second and third cases the first extra
arg is a struct from which the function is fetched; this object
will be passed as the first parameter to the function. In the second case
the second extra arg will be used for the return value.
<Body>Type key letters are:
<Body>i                    a long
<Body>f                    a double
<Body>s                    a nul terminated string
<Body>o                    an ici object
<Body>When a string is returned it is a pointer to the character data of an
internal ICI string object. It will only remain valid until the next
call to any ICI function.  When an object is returned it has been ici_incref'ed
(i.e. it is held against garbage collection).
<Heading2><Marker <MType 2> <MText `ici_callv, C API function'> >ici_callv
<CodeIn1cm>\ <bold>int\ ici_callv(ici_str_t\ *func_name,\ char\ *types,\ va_list\ va)
<nobold>
<Comment From call.c>
<Body>Varient of ici_call() (see) taking a variable argument list.
<Heading2><Marker <MType 2> <MText `ici_chkbuf, C API macro'> >ici_chkbuf
<CodeIn1cm>\ <bold>#define\ ici_chkbuf(n)<HardSpace><HardSpace>...<nobold>
<Comment From buf.h>
<Body>Ensure that <italic>ici_buf<noitalic> points to enough memory to hold index <italic>n<noitalic> (plus
room for a nul char at the end). Returns 0 on success, else 1 and
sets <italic>ici_error<noitalic>.
<Body>See also: <italic>The error return convention<noitalic>.
<Heading2><Marker <MType 2> <MText `ici_chkbuf, C API macro'> >ici_chkbuf
<CodeIn1cm>\ <bold>#define\ ici_chkbuf(n)<HardSpace><HardSpace>...<nobold>
<Comment From buf.h>
<Body>Ensure that <italic>ici_buf<noitalic> points to enough memory to hold index <italic>n<noitalic> (plus
room for a nul char at the end). Returns 0 on success, else 1 and
sets <italic>ici_error<noitalic>.
<Body>See also: <italic>The error return convention<noitalic>.
<Heading2><Marker <MType 2> <MText `ici_float_ret, C API function'> >ici_float_ret
<CodeIn1cm>\ <bold>int\ ici_float_ret(double\ ret)
<nobold>
<Comment From cfunc.c>
<Body>Use <italic>return ici_float_ret(n);<noitalic> to return a float from an intrinsic fuction.
<Heading2><Marker <MType 2> <MText `ici_free, C API function'> >ici_free
<CodeIn1cm>\ <bold>void\ ici_free(void\ *p)
<nobold>
<Comment From alloc.c>
<Body>Free a block allocated with ici_alloc().
<Body>See also: <italic>ICIs allocation functions<noitalic>, ici_alloc(), ici_tfree(),
ici_nfree().
<Heading2><Marker <MType 2> <MText `ici_free, C API function'> >ici_free
<CodeIn1cm>\ <bold>void\ ici_free(void\ *p)
<nobold>
<Comment From alloc.c>
<Body>Free a block allocated with ici_alloc().
<Body>See also: <italic>ICIs allocation functions<noitalic>, ici_alloc(), ici_tfree(),
ici_nfree().
<Heading2><Marker <MType 2> <MText `ici_func, C API function'> >ici_func
<CodeIn1cm>\ <bold>int\ ici_func(ici_obj_t\ *callable,\ char\ *types,\ ...)
<nobold>
<Comment From call.c>
<Body>Call an callable ICI object <italic>callable<noitalic> from C with simple argument types
and an optional return value.  The callable object is typically a function
(but not a function name, see <italic>ici_call<noitalic> for that case).
<Body><italic>types<noitalic> is a string that indicates what C values are being supplied as
arguments.  It can be of the form ".=..." or "..." where each "." is a type
key letter as described below.  In the first case the 1st extra argument is
used as a pointer to store the return value through.  In the second case,
the return value of the ICI function is not provided.
<Body>Type key letters are:
<TagIn4cm><italic>i<noitalic><Tab>The corresponding argument should be a C long
                     (a pointer to a long in the case of a return value).
                     It will be converted to an ICI <italic>int<noitalic> and passed
                     to the function.
<TagIn4cm><italic>f<noitalic><Tab>The corresponding argument should be a C double.
                     (a pointer to a double in the case of a return value).
                     It will be converted to an ICI <italic>float<noitalic> and passed
                     to the function.
<TagIn4cm><italic>s<noitalic><Tab>The corresponding argument should be a nul
                     terminated string (a pointer to a char * in the case
                     of a return value).  It will be converted to an ICI
                     <italic>string<noitalic> and passed to the function.
<TagIn4cm><Tab>                     When a string is returned it is a pointer to the
                     character data of an internal ICI string object.  It
                     will only remain valid until the next call to any ICI
                     function.
<TagIn4cm><italic>o<noitalic><Tab>The corresponding argument should be a pointer
                     to an ICI object (a pointer to an object in the case
                     of a return value).  It will be passed directly to the
                     ICI function.
<TagIn4cm><Tab>                     When an object is returned it has been ici_incref()ed
                     (that is, it is held against garbage collection).
<Heading2><Marker <MType 2> <MText `ici_funcv, C API function'> >ici_funcv
<CodeIn1cm>\ <bold>int\ ici_funcv(ici_obj_t\ *subject,\ ici_obj_t\ *callable,\ char\ *types,\ va_list\ va)
<nobold>
<Comment From call.c>
<Body>The core common function of the things that call ICI functions from C with
a simple marshalled argument list (ici_func, ici_call, ici_method).
<Body>If <italic>subject<noitalic> is NULL, then <italic>callable<noitalic> is taken to be a callable object
(could be a function, a method, or something else) and is called directly.
If <italic>subject<noitalic> is non-NULL, it is taken to be an instance object and callable
is taken to be the name of the method to be invoked on it.
<Body>In common with all these functions, arguments are marshalled from
C into ICI arguments according to a simple specification given by
the string <italic>types<noitalic>.
<Body>Types can be of the forms ".=..." or "...".  In the first case the first
extra arg is used as a pointer to store the return value through.
<Body>Type key letters are:
<Body>i                    a long
<Body>f                    a double
<Body>s                    a nul terminated string
<Body>o                    an ICI object
<Body>When a string is returned it is a pointer to the character data of an
internal ICI string object. It will only remain valid until the next
call to any ICI function because it is not necessarily held against
garbage collection.  When an object is returned it has been
ici_incref()ed (i.e. it is held against garbage collection).
<Body>There is some historical support for <italic>@<noitalic> operators, but it is deprecated
and may be removed in future versions.
<Heading2><Marker <MType 2> <MText `ici_incref, C API macro'> >ici_incref
<CodeIn1cm>\ <bold>#define\ ici_incref(o)<HardSpace><HardSpace>...<nobold>
<Comment From object.h>
<Body>References from ordinary machine data objects (ie. variables and stuff,
not other objects) are invisible to the garbage collector.  These refs
must be accounted for if there is a possibility of garbage collection.
Note that most routines that make objects (new_*(), copy() etc...)
return objects with 1 ref.  The caller is expected to ici_decref() it when
they attach it into wherever it is going.
<Heading2><Marker <MType 2> <MText `ici_int_ret, C API function'> >ici_int_ret
<CodeIn1cm>\ <bold>int\ ici_int_ret(long\ ret)
<nobold>
<Comment From cfunc.c>
<Body>Use <italic>return ici_int_ret(n);<noitalic> to return an integer from an intrinsic fuction.
<Heading2><Marker <MType 2> <MText `ici_method, C API function'> >ici_method
<CodeIn1cm>\ <bold>int\ ici_method(ici_obj_t\ *inst,\ ici_str_t\ *mname,\ char\ *types,\ ...)
<nobold>
<Comment From call.c>
<Body>Call an ICI function from C with simple argument types and return value.
<Body>Types can be of the forms ".=..." or "...".  In the first case the 1st
extra arg is used as a pointer to store the return value through.
<Body>Type key letters are:
<Body>i                    a long
<Body>f                    a double
<Body>s                    a nul terminated string
<Body>o                    an ici object
<Body>When a string is returned it is a pointer to the character data of an
internal ICI string object. It will only remain valid until the next
call to any ICI function.  When an object is returned it has been
ici_incref()ed (i.e. it is held against garbage collection).
<Heading2><Marker <MType 2> <MText `ici_nalloc, C API function'> >ici_nalloc
<CodeIn1cm>\ <bold>void\ *\ ici_nalloc(size_t\ z)
<nobold>
<Comment From alloc.c>
<Body>Allocate an object of the given <italic>size<noitalic>.  Return NULL on failure, usual
conventions.  The resulting object must be freed with ici_nfree() and only
ici_nfree().  Note that ici_nfree() also requires to know the size of the
object being freed.
<Body>This function is preferable to ici_alloc(). It should be used if
you can know the size of the allocation when the free happens so
you can call ici_nfree(). If this isn't the case you will have to
use ici_alloc().
<Body>See also: <italic>ICIs allocation functions<noitalic>, ici_talloc(), ici_alloc(),
ici_nfree().
<Heading2><Marker <MType 2> <MText `ici_nfree, C API function'> >ici_nfree
<CodeIn1cm>\ <bold>void\ ici_nfree(void\ *p,\ size_t\ z)
<nobold>
<Comment From alloc.c>
<Body>Free an object allocated with ici_nalloc(). The <italic>size<noitalic> passed here
must be exactly the same size passed to ici_nalloc() when the
allocation was made. If you don't know the size, you should have
called ici_alloc() in the first place.
<Body>See also: <italic>ICIs allocation functions<noitalic>, ici_nalloc().
<Heading2><Marker <MType 2> <MText `ici_obj, C API struct'> >ici_obj
<CodeIn1cm>\ <bold>struct\ ici_obj<HardReturn>
{<HardReturn>
\ \ \ \ char\ \ \ \ \ \ \ \ o_tcode;<HardReturn>
\ \ \ \ char\ \ \ \ \ \ \ \ o_flags;<HardReturn>
\ \ \ \ char\ \ \ \ \ \ \ \ o_nrefs;<HardReturn>
\ \ \ \ char\ \ \ \ \ \ \ \ o_leafz;<HardReturn>
}<nobold>
<Comment From object.h>
<Body>This is the universal header of all objects.  Each object includes this as
a header.  In the real structures associated with each object type the type
specific stuff follows
<Comment From object.h>
<TagIn4cm><italic>o_tcode<noitalic><Tab>The small integer type code that characterises
                     this object. Standard core types have well known
                     codes identified by the TC_* defines below. Other
                     types are registered at run-time and are given
                     the next available code.
<TagIn4cm><Tab>                     This code can be used to index ici_types[] to discover
                     a pointer to the type structure (see above).
<TagIn4cm><italic>o_flags<noitalic><Tab>Some boolean flags. Well known flags that apply to
                     all object occupy the lower 4 bits of this byte.
                     The upper four bits are available for object specific
                     use. See O_* below.
<TagIn4cm><italic>o_nrefs<noitalic><Tab>A small integer count of the number of references
                     to this object that are *not* otherwise visible
                     to the garbage collector.
<TagIn4cm><italic>o_leafz<noitalic><Tab>If (and only if) this object does not reference any
                     other objects (i.e. its t_mark() function just sets
                     the O_MARK flag), and its memory cost fits in this
                     signed byte (\< 127), then its size can be set here
                     to accelerate the marking phase of the garbage
                     collector. Else it must be zero.
<Heading2><Marker <MType 2> <MText `ici_obj, C API struct'> >ici_obj
<CodeIn1cm>\ <bold>struct\ ici_obj<HardReturn>
{<HardReturn>
\ \ \ \ char\ \ \ \ \ \ \ \ o_tcode;<HardReturn>
\ \ \ \ char\ \ \ \ \ \ \ \ o_flags;<HardReturn>
\ \ \ \ char\ \ \ \ \ \ \ \ o_nrefs;<HardReturn>
\ \ \ \ char\ \ \ \ \ \ \ \ o_leafz;<HardReturn>
}<nobold>
<Comment From object.h>
<Body>This is the universal header of all objects.  Each object includes this as
a header.  In the real structures associated with each object type the type
specific stuff follows
<Comment From object.h>
<TagIn4cm><italic>o_tcode<noitalic><Tab>The small integer type code that characterises
                     this object. Standard core types have well known
                     codes identified by the TC_* defines below. Other
                     types are registered at run-time and are given
                     the next available code.
<TagIn4cm><Tab>                     This code can be used to index ici_types[] to discover
                     a pointer to the type structure (see above).
<TagIn4cm><italic>o_flags<noitalic><Tab>Some boolean flags. Well known flags that apply to
                     all object occupy the lower 4 bits of this byte.
                     The upper four bits are available for object specific
                     use. See O_* below.
<TagIn4cm><italic>o_nrefs<noitalic><Tab>A small integer count of the number of references
                     to this object that are *not* otherwise visible
                     to the garbage collector.
<TagIn4cm><italic>o_leafz<noitalic><Tab>If (and only if) this object does not reference any
                     other objects (i.e. its t_mark() function just sets
                     the O_MARK flag), and its memory cost fits in this
                     signed byte (\< 127), then its size can be set here
                     to accelerate the marking phase of the garbage
                     collector. Else it must be zero.
<Heading2><Marker <MType 2> <MText `ici_ret_no_decref, C API function'> >ici_ret_no_decref
<CodeIn1cm>\ <bold>int\ ici_ret_no_decref(ici_obj_t\ *o)
<nobold>
<Comment From cfunc.c>
<Body>General way out of an intrinsic function returning the object o where
the given object has no extra refernce count. Returns 0 indicating no
error.
<Body>This is suitable for using as a return from an intrinsic function
as say:
<CodeIn1cm>\ return\ ici_ret_no_decref(o);
<Body>If the object you are returning has an extra reference which must be
decremented as part of the return, use ici_ret_with_decref() (above).
<Heading2><Marker <MType 2> <MText `ici_ret_with_decref, C API function'> >ici_ret_with_decref
<CodeIn1cm>\ <bold>int\ ici_ret_with_decref(ici_obj_t\ *o)
<nobold>
<Comment From cfunc.c>
<Body>General way out of an intrinsic function returning the object <italic>o<noitalic>, but
the given object has a reference count which must be decref'ed on the
way out. Return 0 unless the given <italic>o<noitalic> is NULL, in which case it returns
1 with no other action.
<Body>This is suitable for using as a return from an intrinsic function
as say:
<CodeIn1cm>\ return\ ici_ret_with_decref(objof(ici_int_new(2)));
<Body>(Although see ici_int_ret().) If the object you wish to return does
not have an extra reference, use ici_ret_no_decref().
<Heading2><Marker <MType 2> <MText `ici_str_ret, C API function'> >ici_str_ret
<CodeIn1cm>\ <bold>int\ ici_str_ret(char\ *str)
<nobold>
<Comment From cfunc.c>
<Body>Use <italic>return ici_str_ret(n);<noitalic> to return a string from an intrinsic fuction.
<Heading2><Marker <MType 2> <MText `ici_str_ret, C API function'> >ici_str_ret
<CodeIn1cm>\ <bold>int\ ici_str_ret(char\ *str)
<nobold>
<Comment From cfunc.c>
<Body>Use <italic>return ici_str_ret(n);<noitalic> to return a string from an intrinsic fuction.
<Heading2><Marker <MType 2> <MText `ici_type, C API struct'> >ici_type
<CodeIn1cm>\ <bold>struct\ ici_type<HardReturn>
{<HardReturn>
\ \ \ \ unsigned\ long\ (*t_mark)(ici_obj_t\ *);<HardReturn>
\ \ \ \ void\ \ \ \ \ \ \ \ (*t_free)(ici_obj_t\ *);<HardReturn>
\ \ \ \ unsigned\ long\ (*t_hash)(ici_obj_t\ *);<HardReturn>
\ \ \ \ int\ \ \ \ \ \ \ \ \ (*t_cmp)(ici_obj_t\ *,\ ici_obj_t\ *);<HardReturn>
\ \ \ \ ici_obj_t\ \ \ *(*t_copy)(ici_obj_t\ *);<HardReturn>
\ \ \ \ int\ \ \ \ \ \ \ \ \ (*t_assign)(ici_obj_t\ *,\ ici_obj_t\ *,\ ici_obj_t\ *);<HardReturn>
\ \ \ \ ici_obj_t\ \ \ *(*t_fetch)(ici_obj_t\ *,\ ici_obj_t\ *);<HardReturn>
\ \ \ \ char\ \ \ \ \ \ \ \ *t_name;<HardReturn>
\ \ \ \ void\ \ \ \ \ \ \ \ (*t_objname)(ici_obj_t\ *,\ char\ [ICI_OBJNAMEZ]);<HardReturn>
\ \ \ \ int\ \ \ \ \ \ \ \ \ (*t_call)(ici_obj_t\ *,\ ici_obj_t\ *);<HardReturn>
\ \ \ \ ici_str_t\ \ \ *t_ici_name;<HardReturn>
\ \ \ \ int\ \ \ \ \ \ \ \ \ (*t_assign_super)(ici_obj_t\ *,\ ici_obj_t\ *,\ ici_obj_t\ *,\ ici_struct_t\ *);<HardReturn>
\ \ \ \ int\ \ \ \ \ \ \ \ \ (*t_fetch_super)(ici_obj_t\ *,\ ici_obj_t\ *,\ ici_obj_t\ **,\ ici_struct_t\ *);<HardReturn>
\ \ \ \ int\ \ \ \ \ \ \ \ \ (*t_assign_base)(ici_obj_t\ *,\ ici_obj_t\ *,\ ici_obj_t\ *);<HardReturn>
\ \ \ \ ici_obj_t\ \ \ *(*t_fetch_base)(ici_obj_t\ *,\ ici_obj_t\ *);<HardReturn>
\ \ \ \ ici_obj_t\ \ \ *(*t_fetch_method)(ici_obj_t\ *,\ ici_obj_t\ *);<HardReturn>
\ \ \ \ void\ \ \ \ \ \ \ \ *t_reserved2;\ \ \ /*\ Must\ be\ zero.\ */<HardReturn>
\ \ \ \ void\ \ \ \ \ \ \ \ *t_reserved3;\ \ \ /*\ Must\ be\ zero.\ */<HardReturn>
\ \ \ \ void\ \ \ \ \ \ \ \ *t_reserved4;\ \ \ /*\ Must\ be\ zero.\ */<HardReturn>
}<nobold>
<Comment From object.h>
<Body>Every object has a header. In the header the o_tcode (type code) field
can be used to index the ici_types[] array to discover the obejct's
type structure. This is the type structure. See detailed comments below.
<Comment From object.h>
<TagIn4cm><italic>t_mark(o)<noitalic><Tab>Sets the O_MARK flag in o-\>o_flags of this object and
                     all objects referenced by this one which don't already
                     have O_MARK set.  Returns the approximate memory cost
                     of this and all other objects it sets the O_MARK of.
                     Typically recurses on all referenced objects which
                     don't already have O_MARK set (this recursion is a
                     potential problem due to the uncontrolled stack depth
                     it can create).  This is used in the marking phase of
                     garbage collection.
<TagIn4cm><Tab>                     The macro ici_mark() calls the t_mark function of the
                     object (based on object type) if the O_MARK flag of
                     the object is clear, else it returns 0.  This is the
                     usual interface to an object's mark function.
<TagIn4cm><Tab>                     The mark function implemantation of objects can assume
                     the O_MARK flag of the object they are being invoked
                     on is clear.
<TagIn4cm><italic>t_free(o)<noitalic><Tab>Frees the object o and all associated data, but not
                     other objects which are referenced from it.  This is
                     only called from garbage collection.  Care should be
                     taken to remember that errors can occur during object
                     creation and that the free function might be asked to
                     free a partially allocated object.
<TagIn4cm><italic>t_cmp(o1, o2)<noitalic><Tab>Compare o1 and o2 and return 0 if they are the same,
                     else non zero.  This similarity is the basis for
                     merging objects into single atomic objects and the
                     implementation of the == operator.
<TagIn4cm><Tab>                     Some objects are by nature both unique and
                     intrinsically atomic (for example, objects which are
                     one-to-one with some other allocated data which they
                     alloc when the are created and free when they die).
                     For these objects the existing function
                     ici_cmp_unique() can be used as their implementation
                     of this function.
<TagIn4cm><Tab>                     It is very important in implementing this function not
                     to miss any fields which may otherwise distinguish two
                     obejcts.  The cmp, hash and copy operations of an
                     object are all related.  It is useful to check that
                     they all regard the same data fields as significant in
                     performing their operation.
<TagIn4cm><italic>t_copy(o)<noitalic><Tab>Returns a copy of the given object. This is the basis
                     for the implementation of the copy() function.  On
                     failure, NULL is returned and error is set.  The
                     returned object has been ici_incref'ed.  The returned
                     object should cmp() as being equal, but be a distinct
                     object for objects that are not intrinsically atomic.
<TagIn4cm><Tab>                     Intrinsically atomic objects may use the existing
                     function ici_copy_simple() as their implemenation of
                     this function.
<TagIn4cm><italic>t_hash(o)<noitalic><Tab>Return an unsigned long hash which is sensitive to the
                     value of the object.  Two objects which cmp() equal
                     should return the same hash.
<TagIn4cm><Tab>                     The returned hash is used in a hash table shared by
                     objects of all types.  So, somewhat problematically,
                     it is desireable to generate hashes which have good
                     spread and seperation across all objects.
<TagIn4cm><Tab>                     Some objects are by nature both unique and
                     intrinsically atomic (for example, objects which are
                     one-to-one with some other allocated data which they
                     alloc when the are created and free when they die).
                     For these objects the existing function hash_unique()
                     can be used as their implementation of this function.
<TagIn4cm><italic>t_assign(o, k, v)<noitalic><Tab>Assign to key k of the object o the value v. Return
                     1 on error, else 0.
<TagIn4cm><Tab>                     The existing function ici_assign_fail() may be used
                     both as the implementation of this function for object
                     types which do not support any assignment, and as a
                     simple method of generating an error for particular
                     assignments which break some rule of the object.
<TagIn4cm><Tab>                     Not that it is not necessarilly wrong for an
                     intrinsically atomic object to support some form of
                     assignment.  Only for the modified field to be
                     significant in a cmp() operation.  Objects which are
                     intrinsically unique and atomic often support
                     assignments.
<TagIn4cm><italic>t_fetch(o, k)<noitalic><Tab>Fetch the value of key k of the object o.  Return
                     NULL on error.
<TagIn4cm><Tab>                     Note that the returned object does not have any extra
                     reference count; however, in some circumstances it may
                     not have any garbage collector visible references to
                     it.  That is, it may be vunerable to a garbage
                     collection if it is not either incref()ed or hooked
                     into a referenced object immediately.  Callers are
                     responsible for taking care.
<TagIn4cm><Tab>                     The existing function ici_fetch_fail() may be used
                     both as the implementation of this function for object
                     types which do not support any assignment, and as a
                     simple method of generating an error for particular
                     fetches which break some rule of the object.
<TagIn4cm><italic>t_name<noitalic><Tab>The name of this type. Use for the implementation of
                     typeof() and in error messages.  But apart from that,
                     type names have no fundamental importance in the
                     langauge and need not even be unique.
<TagIn4cm><italic>t_objname(o, p)<noitalic><Tab>Place a short (30 chars or less) human readable
                     representation of the object in the given buffer.
                     This is not intended as a basis for re-parsing or
                     serialisation.  It is just for diagnostics and debug.
                     An implementation of t_objname() must not allocate
                     memory or otherwise allow the garbage collector to
                     run.  It is often used to generate formatted failure
                     messages after an error has occured, but before
                     cleanup has completed.
<TagIn4cm><italic>t_call(o, s)<noitalic><Tab>Call the object o. If s is non-NULL this is a method
                     call and s is the subject object of the call.  Return
                     1 on error, else 0.
<TagIn4cm><italic>t_ici_name<noitalic><Tab>A ici_str_t copy of the name. This is just a cached
                     version so that typeof() doesn't keep re-computing the
                     string.
<TagIn4cm><italic>t_fetch_method<noitalic><Tab>An optional alternative to the basic t_fetch() that
                     will be called (if supplied) when doing a fetch for
                     the purpose of forming a method.  This is really only
                     a hack to support COM under Windows.  COM allows
                     remote objects to have properties, like
                     object.property, and methods, like object:method().
                     But without this special hack, we can't tell if a
                     fetch operation is supposed to perform the COM get/set
                     property operation, or return a callable object for a
                     future method call.  Most objects will leave this
                     NULL.
