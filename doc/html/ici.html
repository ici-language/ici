<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML EXPERIMENTAL 970324//EN">
<HTML>
<HEAD>
<META NAME="GENERATOR" CONTENT="Adobe FrameMaker 5.5/HTML Export Filter">
<LINK REL="STYLESHEET" HREF="ici.css">
<TITLE> ICI Technical Description</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<P CLASS="Body">
<A NAME="pgfId=184947">
 </A>&nbsp;</P>
<DIV>
<H1 CLASS="Title">
<A NAME="pgfId=197492">
 </A>ICI Technical Description</H1>
<DIV>
<H2 CLASS="Sub-title">
<A NAME="pgfId=184912">
 </A>Version 1.2</H2>
</DIV>
<DIV>
<H2 CLASS="Sub-title">
<A NAME="pgfId=184948">
 </A>Tim Long</H2>
<P CLASS="Legals">
<A NAME="pgfId=188317">
 </A>&#169; 1992-2000 Tim Long</P>
<P CLASS="Legals">
<A NAME="pgfId=184725">
 </A>Regular expression portions &#169; 1997-1999 University of Cambridge</P>
<P CLASS="Legals">
<A NAME="pgfId=184727">
 </A>Permission granted to reproduce provided copyright notices are preserved.</P>
<P CLASS="Legals">
<A NAME="pgfId=225509">
 </A>&nbsp;</P>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=225510">
 </A>Introduction</H3>
<P CLASS="Body">
<A NAME="pgfId=245249">
 </A>ICI is a general purpose interpretive programming language that has dynamic typing and flexible data types with the basic syntax, flow control constructs and operators of C.  It is designed for use in many environments, including embedded systems, as an adjunct to other programs, as a text-based interface to compiled libraries, and as a cross-platform scripting language with good string-handling capabilities.</P>
<P CLASS="Body">
<A NAME="pgfId=245282">
 </A>The ICI language and source is not copyright in any way.</P>
<P CLASS="Body">
<A NAME="pgfId=245291">
 </A>This document is the basic reference for the core language and functions. There is also an extensive man page that includes details command line invocation not described here. Additional documentation is provided in ICI source releases. The ICI web site is <A HREF="http.html#//www.zeta.org.au/~atrn/ici/" CLASS="Hypertext">
http://www.zeta.org.au/~atrn/ici/</A></P>
</DIV>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=245292">
 </A>Basics</H3>
<P CLASS="Body">
<A NAME="pgfId=225511">
 </A>The ICI interpreter's execution engine calls on the parser to read and compile a statement from an input stream.  The parser in turns calls on the lexical analyser to read tokens.  Upon return from the parser the execution engine executes the compiled statement.  When the statement has finished execution, the execution engine repeats the sequence.</P>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175533">
 </A>The lexical analyser</H4>
<P CLASS="Body">
<A NAME="pgfId=199245">
 </A>The ICI lexical analyser breaks the input stream into tokens, optionally separated by white-space (which includes comments as described below).  The next token is always the longest string of following characters which could possibly be a token.  The following are tokens:</P>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205062"></A>/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205064"></A>/=&nbsp;&nbsp;&nbsp;&nbsp;</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205066"></A>$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205068"></A>@&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205070"></A>(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205072"></A>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205074"></A>{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205076"></A>}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205078"></A>,</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205080"></A>~</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205082"></A>~~</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205084"></A>~~=</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205086"></A>~~~</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205088"></A>[</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205090"></A>]</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205092"></A>.</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205094"></A>*</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205096"></A>*=</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205098"></A>%</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205100"></A>%=</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205102"></A>^</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205104"></A>^=</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205106"></A>+</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205108"></A>+=</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205110"></A>++</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205112"></A>-</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205114"></A>-=</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205116"></A>--</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205118"></A>-&gt;</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205120"></A>&gt;</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205122"></A>&gt;=</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205124"></A>&gt;&gt;</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205126"></A>&gt;&gt;=</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205128"></A>&lt;</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205130"></A>&lt;=</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205132"></A>&lt;=&gt;</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205134"></A>&lt;&lt;</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205136"></A>&lt;&lt;=</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205138"></A>=</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205140"></A>==</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205142"></A>!</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205144"></A>!=</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205146"></A>!~</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205148"></A>&amp;</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205150"></A>&amp;&amp;</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205152"></A>&amp;=</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205154"></A>|</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205156"></A>||</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205158"></A>|=</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205160"></A>;</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205162"></A>?</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205164"></A>:</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205166"></A>:=</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205168"></A>:^</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205170"></A>&nbsp;</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205172"></A>&nbsp;</PRE>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId=199359">
 </A>The following are also tokens:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId=196439">
 </A>The character '#' followed by any sequence of characters except a newline, then another '#'.  This token is a regular-expression.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId=175549">
 </A>The character ' (single quote) followed by a single character (other than a newline) or a single backslash character sequence (described below), followed by another single quote.  This token is a character-code.  A single quote followed by other than the above sequence will result in an error.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId=203976">
 </A>The character &quot; (double quote) followed by any sequence of characters (other than a newline) and backslash character sequences, up to another double quote character.  This token is a string.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId=204014">
 </A>A backslash character sequence is any of the following:</P>
<TABLE>
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205174"></A><CODE CLASS="+Code">\n</CODE>
</PRE>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=205176">
 </A>newline (ASCII 0x0A)</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205178"></A><CODE CLASS="+Code">\t</CODE>
</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=205180">
 </A>tab (ASCII 0x09)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205182"></A><CODE CLASS="+Code">\v</CODE>
</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=205184">
 </A>vertical tab (ASCII 0x0B)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205186"></A><CODE CLASS="+Code">\b</CODE>
</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=205188">
 </A>back space (ASCII 0x08)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205190"></A><CODE CLASS="+Code">\r</CODE>
</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=205192">
 </A>carriage return (ASCII 0x0D)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205194"></A><CODE CLASS="+Code">\f</CODE>
</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=205196">
 </A>form feed (ASCII 0x0C)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205198"></A><CODE CLASS="+Code">\a</CODE>
</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=205200">
 </A>audible bell (ASCII 0x07)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205202"></A><CODE CLASS="+Code">\e</CODE>
</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=205204">
 </A>escape (ASCII 0x1B)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205206"></A><CODE CLASS="+Code">\\</CODE>
</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=205208">
 </A>backslash (ASCII 0x5C)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205210"></A><CODE CLASS="+Code">\'</CODE>
</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=205212">
 </A>single quote (ASCII 0x27)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205214"></A><CODE CLASS="+Code">\&quot;</CODE>
</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=205216">
 </A>double quote (ASCII 0x22)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205218"></A><CODE CLASS="+Code">\?</CODE>
</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=205220">
 </A>question mark (ASCII 0x3F)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205222"></A><CODE CLASS="+Code">\cx</CODE>
</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=205224">
 </A>control-x</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205226"></A><CODE CLASS="+Code">\xx..&nbsp;</CODE>
</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=205228">
 </A>the character with hex code x...</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=205230"></A><CODE CLASS="+Code">\n</CODE>
</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=205232">
 </A>the character with octal code n. (1, 2 or 3 octal digits)</P>
</TD>
</TR>
</TABLE>
<P CLASS="CBullet">
<A NAME="pgfId=175571">
 </A>		Consecutive string-literals, seperated only by white-space, are concatenated to form a single string-literal.</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId=175573">
 </A>Any upper or lower case letter, any digit, or '_' (underscore)  followed by any number of the same (or other characters which may be involved in a floating point number while that is a valid interpretation).  A token of this form may be one of three things:</LI>
</UL>
<P CLASS="CBullet">
<A NAME="pgfId=175575">
 </A>	If it can be interpreted as an integer, it is an integer-number.</P>
<P CLASS="CBullet">
<A NAME="pgfId=175577">
 </A>	Otherwise, if it can be interpreted as a floating point number, it is a floating-point-number.</P>
<P CLASS="CBullet">
<A NAME="pgfId=175579">
 </A>	Otherwise, it is an identifier.</P>
<P CLASS="Body">
<A NAME="pgfId=175581">
 </A>Notice that keywords are not recognised directly by the lexical analyser. Instead, certain identifiers are recognised in context by the parser as described below. </P>
<P CLASS="Body">
<A NAME="pgfId=175582">
 </A>There are two forms of comments (which are white-space). One starts with the characters <CODE CLASS="+Code">
/*</CODE>
 and continue until the next <CODE CLASS="+Code">
*/</CODE>
.  The other starts with the characters <CODE CLASS="+Code">
//</CODE>
 and continues until the next end of line. Also, lines which start with a # character are ignored. (Lines may be terminated with <I CLASS="+Italic">
linefeed</I>
, <I CLASS="+Italic">
carriage return</I>
 or <I CLASS="+Italic">
carrige return</I>
 plus <I CLASS="+Italic">
linefeed</I>
.)</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175583">
 </A>An introduction to variables, modules and scope</H4>
<P CLASS="Body">
<A NAME="pgfId=175584">
 </A>Variables are simple identifiers which have a value associated with them.  They are in themselves typeless, depending on the type of the value currently assigned to them.</P>
<P CLASS="Body">
<A NAME="pgfId=175585">
 </A>The term module in ICI refers to a collection of functions, declarations and code which share the same variables.  Typically each source file is a module, but not necessarily.</P>
<P CLASS="Body">
<A NAME="pgfId=175586">
 </A>In ICI, modules may be nested in a hierarchical fashion. Within a module, variables can be declared as either static or extern.  When a variable is declared as static it is visible to code defined in the module of its definition, and to code defined in sub-modules of that one. This is termed the scope of the variable.</P>
<P CLASS="Body">
<A NAME="pgfId=175587">
 </A>When a variable is defined as extern it is declared static in the parent module.  Thus the parent module and all sub-modules of the parent module have that variable in their scope. Variables of this type, whether originally declared extern or static, will be henceforward referred to as static variables.</P>
<P CLASS="Body">
<A NAME="pgfId=175588">
 </A>Static variables are persistent variables.  That is they remain in existence even when execution completely leaves their scope, despite not being visible to any executing code. They are visible again when code flow again enters their scope.</P>
<P CLASS="Body">
<A NAME="pgfId=175589">
 </A>The scoping of static variables is strictly governed by the nesting of the modules, not by the flow of execution.  For example.  Suppose two neighbouring modules (call them module A and module B) each define a variable called theVariable. When some code in module A calls a function defined in module B and that function refers to theVariable; it is referring to the version of theVariable defined in module B, not the one defined in module A.</P>
<P CLASS="Body">
<A NAME="pgfId=175590">
 </A>Variables in sub scopes hide variables of the same name defined in outer scopes.</P>
<P CLASS="Body">
<A NAME="pgfId=175591">
 </A>The second type of variable in ICI is the automatic, or auto, variable.  Automatic variables are not persistent.  They last only as long as a module is being parsed or a function is being executed. For instance, each time a function is entered a copy is made of the auto variables which were declared in the function.  This group of variables generally only persists during the execution of the function; once the function returns they are discarded.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175592">
 </A>The parser</H4>
<P CLASS="Body">
<A NAME="pgfId=175593">
 </A>The parser uses the lexical analyser to read a source input stream. The parser also has reference to the variable-scope within which this source is being parsed, so that it may define variables.</P>
<P CLASS="Body">
<A NAME="pgfId=175594">
 </A>When encountering a variable definition, the parser will define variables within the current scope. When encountering normal executable code at the outermost level, the parser returns its compiled form to the execution engine for execution.</P>
<P CLASS="Body">
<A NAME="pgfId=175595">
 </A>For some constructs the parser will in turn recursively call upon the execution engine to evaluate a sub-construct within a statement.</P>
<P CLASS="Body">
<A NAME="pgfId=175596">
 </A>The following sections will work through the syntax of ICI with explanations and examples.  Occasionally constructs will be used ahead of their full explanation.  Their intent should be obvious. </P>
<P CLASS="Body">
<A NAME="pgfId=175597">
 </A>The following notation is used in the syntax in these sections.  Note that the syntax given in the text is not always exact, but rather designed to aid comprehension.  The exact syntax is given in a later section.</P>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=216614">
 </A><B CLASS="+Bold">
bold</B>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=216616">
 </A>The <B CLASS="+Bold">
bold</B>
 text is literal ASCII text.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=216618">
 </A><I CLASS="+Italic">
italic</I>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=216620">
 </A>The <I CLASS="+Italic">
italic</I>
 text is a construct further described elsewhere.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=216622">
 </A><I CLASS="+Italic">
[</I>
 xxx <I CLASS="+Italic">
]</I>
&nbsp;&nbsp;&nbsp;&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=216624">
 </A>The xxx is optionally present.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=216626">
 </A>xxx...</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=216628">
 </A>The xxx may be present zero or more times.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247285">
 </A><I CLASS="+Italic">
(</I>
 xxx <I CLASS="+Italic">
|</I>
 yyy <I CLASS="+Italic">
)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</I>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247287">
 </A>Either xxx or yyy may be present.</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId=175602">
 </A>As noted previously there are no reserved words recoginsed by the lexical anaylyser, but certain identifiers will be recognised by the parser in certain syntactic positions (as seen below).  While these identifiers are not otherwise restricted, special action may need to be taken if they are used as simple variable names. They probably should be avoided.  The complete list is:</P>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=216651">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=216653">
 </A>NULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=216655">
 </A>auto&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=216657">
 </A>break&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=216659">
 </A>case&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=216661">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=216663">
 </A>continue</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=216665">
 </A>default</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=216667">
 </A>do</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=216669">
 </A>else</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=216671">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=216673">
 </A>extern</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=216675">
 </A>for</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=216677">
 </A>forall</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=216679">
 </A>if</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=216681">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=216683">
 </A>in</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=216685">
 </A>onerror</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=216687">
 </A>return</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=216689">
 </A>static</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=216691">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=216693">
 </A>switch</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=216695">
 </A>try</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=216697">
 </A>while</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=216699">
 </A>&nbsp;</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId=175604">
 </A>We now turn our attention to the syntax itself.</P>
<P CLASS="Body">
<A NAME="pgfId=175605">
 </A>Firstly consider the basic statement which is the unit of operation of the parser.  As stated earlier the execution engine will call on the parser to parse one top-level statement at a time.  We split the syntax of a statement into two categories (purely for semantic clarity):</P>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=219766">
 </A><I CLASS="+Italic">
statement</I>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=219768">
 </A><I CLASS="+Italic">
executable-statement</I>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=219770">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=219772">
 </A><I CLASS="+Italic">
declaration</I>
</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId=175607">
 </A>That is, a statement is either an executable-statement or a declaration.  We will first consider the executable-statement.</P>
<P CLASS="Body">
<A NAME="pgfId=175608">
 </A>These are statements that, at the top-level of parsing, can be translated into code which can be returned to the execution engine. This is by far the largest category of statements:</P>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=245348">
 </A><I CLASS="+Italic">
executable-statement&nbsp;&nbsp;&nbsp;&nbsp;</I>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=245350">
 </A><I CLASS="+Italic">
expression</I>
 <B CLASS="+Bold">
;</B>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=245352">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=245354">
 </A><I CLASS="+Italic">
compound-statement</I>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=245356">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=245358">
 </A><B CLASS="+Bold">
if (</B>
 <I CLASS="+Italic">
expression</I>
 <B CLASS="+Bold">
)</B>
 <I CLASS="+Italic">
statement</I>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=245360">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=245362">
 </A><B CLASS="+Bold">
if (</B>
 <I CLASS="+Italic">
expression</I>
 <B CLASS="+Bold">
)</B>
 <I CLASS="+Italic">
statement</I>
 <B CLASS="+Bold">
else</B>
 <I CLASS="+Italic">
statement</I>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=245364">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=245366">
 </A><B CLASS="+Bold">
while</B>
 <B CLASS="+Bold">
(</B>
 <I CLASS="+Italic">
expression</I>
 <B CLASS="+Bold">
)</B>
 <I CLASS="+Italic">
statement</I>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=245368">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=245370">
 </A><B CLASS="+Bold">
do</B>
 <I CLASS="+Italic">
statement</I>
 <B CLASS="+Bold">
while</B>
 <B CLASS="+Bold">
(</B>
 <I CLASS="+Italic">
expression</I>
<B CLASS="+Bold">
 ) ;</B>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=245372">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=245374">
 </A><B CLASS="+Bold">
for (</B>
<I CLASS="+Italic">
 [ expression ] </I>
<B CLASS="+Bold">
;</B>
<I CLASS="+Italic">
 [ expression ] </I>
<B CLASS="+Bold">
;</B>
 <I CLASS="+Italic">
[ expression ]</I>
 <B CLASS="+Bold">
)</B>
 <I CLASS="+Italic">
statement</I>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=245376">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=245378">
 </A><B CLASS="+Bold">
forall (</B>
 <I CLASS="+Italic">
expression [</I>
 <B CLASS="+Bold">
,</B>
 <I CLASS="+Italic">
expression ]</I>
 <B CLASS="+Bold">
in</B>
 <I CLASS="+Italic">
expression</I>
 <B CLASS="+Bold">
)</B>
 <I CLASS="+Italic">
statement</I>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=245380">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=245382">
 </A><B CLASS="+Bold">
switch ( </B>
<I CLASS="+Italic">
expression</I>
<B CLASS="+Bold">
 )</B>
 <I CLASS="+Italic">
compound-statement</I>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=245384">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=245386">
 </A><B CLASS="+Bold">
case</B>
 <I CLASS="+Italic">
parser-evaluated-expression</I>
 <B CLASS="+Bold">
:</B>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=245388">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=245390">
 </A><B CLASS="+Bold">
default</B>
 <B CLASS="+Bold">
:</B>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=245392">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=245394">
 </A><B CLASS="+Bold">
break ;</B>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=245396">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=245398">
 </A><B CLASS="+Bold">
continue ;</B>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=245400">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=245402">
 </A><B CLASS="+Bold">
return</B>
 <I CLASS="+Italic">
[ expression ]</I>
 <B CLASS="+Bold">
;</B>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=245404">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=245406">
 </A><B CLASS="+Bold">
try</B>
 <I CLASS="+Italic">
statement</I>
 <B CLASS="+Bold">
onerror</B>
 <I CLASS="+Italic">
statement</I>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=245408">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=245410">
 </A><B CLASS="+Bold">
;</B>
</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId=175615">
 </A>These are the basic executable statement types.  Many of these involve expressions, so before examining each statement in turn we will examine the expression. </P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=248213">
 </A>Expressions</H3>
<P CLASS="Body">
<A NAME="pgfId=248214">
 </A>We will examine expressions by starting with the most primitive elements of expressions and working back up to the top level.</P>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=245333">
 </A>Factors</H4>
<P CLASS="Body">
<A NAME="pgfId=175617">
 </A>The lowest level building block of an expressions is the factor:</P>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=246743">
 </A><I CLASS="+Italic">
factor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</I>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=246745">
 </A><I CLASS="+Italic">
integer-number</I>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=246747">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=246749">
 </A><I CLASS="+Italic">
character-code</I>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=246751">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=246753">
 </A><I CLASS="+Italic">
floating-point-number</I>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=246755">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=246757">
 </A><I CLASS="+Italic">
string</I>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=246759">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=246761">
 </A><I CLASS="+Italic">
regular-expression</I>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=246763">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=246765">
 </A><I CLASS="+Italic">
identifier</I>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=246767">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=246769">
 </A><B CLASS="+Bold">
NULL</B>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=246771">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=246773">
 </A><B CLASS="+Bold">
(</B>
 <I CLASS="+Italic">
expression</I>
 <B CLASS="+Bold">
)</B>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=246775">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=246777">
 </A><B CLASS="+Bold">
[ array</B>
 <I CLASS="+Italic">
expression-list</I>
  <B CLASS="+Bold">
]</B>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=246779">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=246781">
 </A><B CLASS="+Bold">
[ set</B>
 <I CLASS="+Italic">
expression-list</I>
 <B CLASS="+Bold">
]</B>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=246918">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=246922">
 </A><B CLASS="+Bold">
[ struct</B>
 <I CLASS="+Italic">
[</I>
 <I CLASS="+Italic">
( </I>
<B CLASS="+Bold">
:</B>
<I CLASS="+Italic">
 | </I>
<B CLASS="+Bold">
=</B>
<I CLASS="+Italic">
 )</I>
<B CLASS="+Bold">
 </B>
<I CLASS="+Italic">
expression</I>
 <B CLASS="+Bold">
,</B>
 <I CLASS="+Italic">
]</I>
 <I CLASS="+Italic">
assignment-list</I>
 <B CLASS="+Bold">
]</B>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=246783">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=246785">
 </A><B CLASS="+Bold">
[ class</B>
 <I CLASS="+Italic">
[</I>
 <I CLASS="+Italic">
( </I>
<B CLASS="+Bold">
:</B>
<I CLASS="+Italic">
 | </I>
<B CLASS="+Bold">
=</B>
<I CLASS="+Italic">
 )</I>
<B CLASS="+Bold">
 </B>
<I CLASS="+Italic">
expression</I>
 <B CLASS="+Bold">
,</B>
 <I CLASS="+Italic">
]</I>
 <I CLASS="+Italic">
assignment-list</I>
 <B CLASS="+Bold">
]</B>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=246787">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=246789">
 </A><B CLASS="+Bold">
[ func</B>
 <I CLASS="+Italic">
function-body</I>
 <B CLASS="+Bold">
]</B>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=246951">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=246955">
 </A><B CLASS="+Bold">
[ module</B>
 <I CLASS="+Italic">
[</I>
 <I CLASS="+Italic">
( </I>
<B CLASS="+Bold">
:</B>
<I CLASS="+Italic">
 | </I>
<B CLASS="+Bold">
=</B>
<I CLASS="+Italic">
 )</I>
<B CLASS="+Bold">
 </B>
<I CLASS="+Italic">
expression</I>
 <B CLASS="+Bold">
,</B>
 <I CLASS="+Italic">
]</I>
 <I CLASS="+Italic">
statement...</I>
 <B CLASS="+Bold">
]</B>
</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId=175622">
 </A>The constructs integer-number, character-code, floating-point-number, string, and regular-expression are primitive lexical elements (described above).  Each is converted to its internal form and is an object of type int, int,  float, string, or regexp respectively.</P>
<P CLASS="Body">
<A NAME="pgfId=175623">
 </A>A factor which is an identifier is a variable reference.  But its exact meaning depends upon its context within the whole expression.  Variables in expressions can either be placed so that their value is being looked up, such as in:</P>
<PRE CLASS="CodeIn4cm"><A NAME="pgfId=175625"></A>a + 1</PRE>
<P CLASS="Body">
<A NAME="pgfId=175626">
 </A>Or they can be placed so that their value is being set, such as in:</P>
<PRE CLASS="CodeIn4cm"><A NAME="pgfId=175628"></A>a = 1</PRE>
<P CLASS="Body">
<A NAME="pgfId=175629">
 </A>Or they can be placed so that their value is being both looked up and set, as in:</P>
<PRE CLASS="CodeIn4cm"><A NAME="pgfId=175631"></A>a += 1</PRE>
<P CLASS="Body">
<A NAME="pgfId=175513">
 </A>Only certain types of expression elements can have their value set.  A variable is the simplest example of these.  Any expression element which can have its value set is termed an lvalue because it can appear on the left hand side of an assignment (which is the simplest expression construct which requires an lvalue).  Consider the following two expressions:</P>
<PRE CLASS="CodeIn4cm"><A NAME="pgfId=175524"></A>1 = 2					/* WRONG */
a = 2					/* OK */</PRE>
<P CLASS="Body">
<A NAME="pgfId=175635">
 </A>The first is illegal because an integer is not an lvalue, the second is legal because a variable reference is an lvalue. Certain expression elements, such as assignment, require an operand to be an lvalue.  The parser checks this.</P>
<P CLASS="Body">
<A NAME="pgfId=175636">
 </A>The next factor in the list above is NULL.  The keyword NULL stands for the value  NULL which is the general undefined value.  It has its own type, NULL.  Variables which have no explicit initialisation have an initial value of NULL.  Its other uses will become obvious later in this document.</P>
<P CLASS="Body">
<A NAME="pgfId=175638">
 </A>Next is the construct ( expression ). The brackets serve merely to make the expression within the bracket act as a simple factor and are used for grouping, as in ordinary mathematics.</P>
<P CLASS="Body">
<A NAME="pgfId=175639">
 </A>Finally we have the four constructs surrounded by square brackets.  These are textual descriptions of more complex data items; typically known as literals.  For example the factor:</P>
<PRE CLASS="CodeIn4cm"><A NAME="pgfId=175544"></A>[array 5, 6, 7]</PRE>
<P CLASS="Body">
<A NAME="pgfId=175641">
 </A>is an array of three items, that is, the integers 5, 6 and 7.  Each of these square bracketed constructs is a textual description of a data type named by the first identifier after the starting square bracket. A full explanation of these first requires an explanation of the fundamental aggregate types.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175642">
 </A>An introduction to arrays, sets and structs</H4>
<P CLASS="Body">
<A NAME="pgfId=175643">
 </A>There are three fundamental aggregate types in ICI: arrays, sets, and structs.  Certain properties are shared by all of these (and other types as will be seen later).  The most basic property is that they are each collections of other values.  The next is that they may be &quot;indexed&quot; to reference values within them.  For example, consider the code fragment:</P>
<PRE CLASS="CodeIn4cm"><A NAME="pgfId=175536"></A>a = [array 5, 6, 7];
i = a[0];</PRE>
<P CLASS="Body">
<A NAME="pgfId=175644">
 </A>The first line assigns the variable a an array of three elements.  The second line assigns the variable i the value currently stored at the first element of the array.  The suffixing of an expression element by an expression in square brackets is the operation of &quot;indexing&quot;, or referring to a sub-element of an aggregate, and will be explained in more detail below.  </P>
<P CLASS="Body">
<A NAME="pgfId=175645">
 </A>Notice that the first element of the array has index zero.  This is a fundamental property of ICI arrays.</P>
<P CLASS="Body">
<A NAME="pgfId=175646">
 </A>The next ICI aggregate we will examine is the set.  Sets are unordered collections of values. Elements &quot;in&quot; the set are used as indexes when working with the set, and the values looked up and assigned are interpreted as a booleans.  Consider the following code fragment:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175647"></A>s = [set 200, 300, &quot;a string&quot;];
if (s[200])
	printf(&quot;200 is in the set\n&quot;);
if (s[400])
	printf(&quot;400 is in the set\n&quot;);
if (s[&quot;a string&quot;])
	printf(&quot;\&quot;a string\&quot; is in the set\n&quot;);
s[200] = 0;
if (s[200])
	printf(&quot;200 is in the set\n&quot;);</PRE>
<P CLASS="Body">
<A NAME="pgfId=175649">
 </A>When run, this will print:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175651"></A>200 is in the set
&quot;a string&quot; is in the set</PRE>
<P CLASS="Body">
<A NAME="pgfId=175653">
 </A>Notice that there was no second printing of &quot;200 is in the set&quot; because it was removed from the set on the third last line by assigning zero to it.</P>
<P CLASS="Body">
<A NAME="pgfId=175654">
 </A>Now consider structs.  Structs are unordered collections of values indexed by any values. Other properties of structs will be discussed later.  The typical indexes of structs are strings.  For this reason notational shortcuts exist for indexing structures by simple strings.  Also,  because each element of a struct is actually an index and value pair, the syntax of a struct literal is slightly different from the arrays and sets seen above.  Consider the following code fragment:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175656"></A>s = [struct a = 123, b = 456, xxx = &quot;a string&quot;];
printf(&quot;s[\&quot;a\&quot;] = %d\n&quot;, s[&quot;a&quot;]);
printf(&quot;s.a = %d\n&quot;, s.a);
printf(&quot;s.xxx = \&quot;%s\&quot;\n&quot;, s.xxx);</PRE>
<P CLASS="Body">
<A NAME="pgfId=175658">
 </A>Will print:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175659"></A>s[&quot;a&quot;] = 123
s.a = 123
s.xxx = &quot;a string&quot;</PRE>
<P CLASS="Body">
<A NAME="pgfId=175660">
 </A>Notice that on the second line the structure was indexed by the string &quot;a&quot;, but that the assignment in the struct literal did not have quotes around the a.  This is part of the notational shortcut which will be discussed further, below.  Also notice the use of s.a in place of s[&quot;a&quot;].  This is a similar shortcut, also discussed below.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175661">
 </A>Back to expression syntax</H4>
<P CLASS="Body">
<A NAME="pgfId=175662">
 </A>The aggregate literals, which in summary are:</P>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=246976">
 </A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=246978">
 </A><B CLASS="+Bold">
[ array</B>
 <I CLASS="+Italic">
expression-list</I>
  <B CLASS="+Bold">
]</B>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=246980">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=246982">
 </A><B CLASS="+Bold">
[ set</B>
 <I CLASS="+Italic">
expression-list</I>
 <B CLASS="+Bold">
]</B>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=246984">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=246986">
 </A><B CLASS="+Bold">
[ struct</B>
 <I CLASS="+Italic">
[</I>
 <I CLASS="+Italic">
( </I>
<B CLASS="+Bold">
:</B>
<I CLASS="+Italic">
 | </I>
<B CLASS="+Bold">
=</B>
<I CLASS="+Italic">
 )</I>
<B CLASS="+Bold">
 </B>
<I CLASS="+Italic">
expression</I>
 <B CLASS="+Bold">
,</B>
 <I CLASS="+Italic">
]</I>
 <I CLASS="+Italic">
assignment-list</I>
 <B CLASS="+Bold">
]</B>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=246988">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=246990">
 </A><B CLASS="+Bold">
[ class</B>
 <I CLASS="+Italic">
[</I>
 <I CLASS="+Italic">
( </I>
<B CLASS="+Bold">
:</B>
<I CLASS="+Italic">
 | </I>
<B CLASS="+Bold">
=</B>
<I CLASS="+Italic">
 )</I>
<B CLASS="+Bold">
 </B>
<I CLASS="+Italic">
expression</I>
 <B CLASS="+Bold">
,</B>
 <I CLASS="+Italic">
]</I>
 <I CLASS="+Italic">
assignment-list</I>
 <B CLASS="+Bold">
]</B>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=246992">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=246994">
 </A><B CLASS="+Bold">
[ func</B>
 <I CLASS="+Italic">
function-body</I>
 <B CLASS="+Bold">
]</B>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=246996">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=246998">
 </A><B CLASS="+Bold">
[ module</B>
 <I CLASS="+Italic">
[</I>
 <I CLASS="+Italic">
( </I>
<B CLASS="+Bold">
:</B>
<I CLASS="+Italic">
 | </I>
<B CLASS="+Bold">
=</B>
<I CLASS="+Italic">
 )</I>
<B CLASS="+Bold">
 </B>
<I CLASS="+Italic">
expression</I>
 <B CLASS="+Bold">
,</B>
 <I CLASS="+Italic">
]</I>
 <I CLASS="+Italic">
statement...</I>
 <B CLASS="+Bold">
]</B>
</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId=175666">
 </A>involve three further constructs, the expression-list, which is a comma separated list of expressions; the assignment-list, which is a comma separated list of assignments; and the function-body, which is the argument list and code body of a function.  The syntax of the first of these is:</P>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247008">
 </A><I CLASS="+Italic">
expression-list&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</I>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247010">
 </A><I CLASS="+Italic">
empty</I>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247012">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247014">
 </A><I CLASS="+Italic">
expression [</I>
<B CLASS="+Bold">
 ,</B>
<I CLASS="+Italic">
 ]</I>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247016">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247018">
 </A><I CLASS="+Italic">
expression </I>
<B CLASS="+Bold">
,</B>
<I CLASS="+Italic">
 expression-list</I>
</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId=175668">
 </A>The expression-list is fairly simple.  The construct empty is used to indicate that the whole list may be absent.  Notice the optional comma after the last expression.  This is designed to allow a more consistent formatting when the elements are line based, and simpler output from programmatically produced code.  For example:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175670"></A>[array
	&quot;This is the first element&quot;,
	&quot;This is the second element&quot;,
	&quot;This is the third element&quot;,
]</PRE>
<P CLASS="Body">
<A NAME="pgfId=175673">
 </A>The assignment list has similar features:</P>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247078">
 </A><I CLASS="+Italic">
assignment-list&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</I>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247080">
 </A><I CLASS="+Italic">
empty</I>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247082">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247084">
 </A><I CLASS="+Italic">
assignment</I>
 <I CLASS="+Italic">
[</I>
<B CLASS="+Bold">
 ,</B>
 <I CLASS="+Italic">
]</I>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247086">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247088">
 </A><I CLASS="+Italic">
assignment</I>
<B CLASS="+Bold">
 ,</B>
<I CLASS="+Italic">
 assignment-list</I>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247090">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247092">
 </A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247094">
 </A><I CLASS="+Italic">
assignment</I>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247096">
 </A><I CLASS="+Italic">
struct-key</I>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247180">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247187">
 </A><I CLASS="+Italic">
struct-key </I>
<B CLASS="+Bold">
=</B>
<I CLASS="+Italic">
  expression</I>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247176">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247193">
 </A><I CLASS="+Italic">
struct-key function-body</I>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247098">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247100">
 </A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247102">
 </A><I CLASS="+Italic">
struct-key</I>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247104">
 </A><I CLASS="+Italic">
identifier</I>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247106">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247108">
 </A><B CLASS="+Bold">
(</B>
 <I CLASS="+Italic">
expression</I>
 <B CLASS="+Bold">
)</B>
</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId=175680">
 </A>Each assignment is either an assignment to a simple identifier or an assignment to a full expression in brackets.  The assignment to an identifier is merely a notational abbreviation for an assignment to a string.  The following two struct literals are equivalent:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=247279"></A>[struct abc = 4]
[struct (&quot;abc&quot;) = 4]</PRE>
<P CLASS="Body">
<A NAME="pgfId=247280">
 </A>The syntax of a function-body is:</P>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247301">
 </A><I CLASS="+Italic">
function-body&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</I>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247303">
 </A><B CLASS="+Bold">
(</B>
 <I CLASS="+Italic">
identifier-list</I>
 <B CLASS="+Bold">
)</B>
 <I CLASS="+Italic">
compound-statement</I>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247305">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247307">
 </A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247309">
 </A><I CLASS="+Italic">
identifier-list</I>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247311">
 </A><I CLASS="+Italic">
empty</I>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247313">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247315">
 </A><I CLASS="+Italic">
identifier</I>
 <I CLASS="+Italic">
[</I>
  <B CLASS="+Bold">
,</B>
 <I CLASS="+Italic">
]</I>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247317">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247319">
 </A><I CLASS="+Italic">
identifier</I>
 <B CLASS="+Bold">
,</B>
  <I CLASS="+Italic">
identifier-list</I>
</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId=175688">
 </A>That is, an identifier-list is an optional comma separated list of identifiers with an optional trailing comma.  Literal functions are rare in most programs; functions are normally named and defined with a special declaration form which will be seen in more detail below.  The following two code fragments are equivalent; the first is the abbreviated notation:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175689"></A>static fred(a, b){return a + b;}</PRE>
<P CLASS="Body">
<A NAME="pgfId=175691">
 </A>and:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175692"></A>static fred = [func (a, b){return a + b;}];</PRE>
<P CLASS="Body">
<A NAME="pgfId=175694">
 </A>The meaning of functions will discussed in more detail below.</P>
<P CLASS="Body">
<A NAME="pgfId=175695">
 </A>Aggregates in general, and literal aggregates in particular, are fully nestable:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175697"></A>[array
	[struct a = 1, c = 2],
	[set &quot;a&quot;, 1.2, 3],
	&quot;a string&quot;,
]</PRE>
<P CLASS="Body">
<A NAME="pgfId=175700">
 </A>Note that aggregate literals are entirely evaluated by the parser.  That is, each expression is evaluated and reduced to a particular value, these values are then used to build an object of the required type.  For example:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175702"></A>[struct a = sin(0.5), b = cos(0.5)]</PRE>
<P CLASS="Body">
<A NAME="pgfId=175703">
 </A>Causes the functions sin and cos to be called during the parsing process and the result assigned to the keys a and b in the struct being constructed.  It is possible to refer to variables which may be in existence while such a literal is being parsed<A HREF="#pgfId=175518" CLASS="footnote">
1</A>.</P>
<P CLASS="Body">
<A NAME="pgfId=175705">
 </A>This ends our consideration of the lowest level element of an expression, the factor.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175706">
 </A>Primary operators</H4>
<P CLASS="Body">
<A NAME="pgfId=247374">
 </A>A simple factor may be adorned with a sequence of primary-operations to form a primary-expression.  That is:</P>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247380">
 </A><I CLASS="+Italic">
primary-expression&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</I>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247382">
 </A><I CLASS="+Italic">
factor</I>
  <I CLASS="+Italic">
primary-operation...</I>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247384">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247386">
 </A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247388">
 </A><I CLASS="+Italic">
primary-operation</I>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247390">
 </A><B CLASS="+Bold">
[</B>
 <I CLASS="+Italic">
expression</I>
 <B CLASS="+Bold">
]</B>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247392">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247394">
 </A><I CLASS="+Italic">
index-operator</I>
 <I CLASS="+Italic">
identifier</I>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247396">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247398">
 </A><I CLASS="+Italic">
index-operator</I>
<B CLASS="+Bold">
 (</B>
 <I CLASS="+Italic">
expression</I>
 <B CLASS="+Bold">
)</B>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247400">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247402">
 </A><I CLASS="+Italic">
</I>
&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247404">
 </A><I CLASS="+Italic">
index-operator</I>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247406">
 </A><I CLASS="+Italic">
Any of:</I>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247408">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247410">
 </A><B CLASS="+Bold">
.&nbsp;&nbsp;-&gt;&nbsp;&nbsp;:&nbsp;&nbsp;:^</B>
</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId=175713">
 </A>The first primary-operation (above) we have already seen.  It is the operation of &quot;indexing&quot; which can be applied to aggregate types.  For example, if xxx is an array:</P>
<PRE CLASS="CodeIn4cm"><A NAME="pgfId=175715"></A>xxx[10]</PRE>
<P CLASS="Body">
<A NAME="pgfId=175716">
 </A>refers to the element of xxx at index 10.  The parser does not impose any type restrictions (because typing is dynamic), although numerous type restrictions apply at execution time (for instance, arrays may only be indexed by integers, and floating point numbers are not able to be indexed at all).</P>
<P CLASS="Body">
<A NAME="pgfId=175718">
 </A>Of the other index operators,  . identifier, is a notational abbreviation of [ &quot;identifier&quot; ] , as seen previously.  The bracketed form is again just a notational variation.  Thus the following are all equivalent:</P>
<PRE CLASS="CodeIn4cm"><A NAME="pgfId=175719"></A>xxx[&quot;aaa&quot;]
xxx.aaa
xxx.(&quot;aaa&quot;)
</PRE>
<P CLASS="Body">
<A NAME="pgfId=175722">
 </A>And the following are also equivalent to each other:</P>
<PRE CLASS="CodeIn4cm"><A NAME="pgfId=175723"></A>xxx[1 + 2]
xxx.(1 + 2)</PRE>
<P CLASS="Body">
<A NAME="pgfId=175725">
 </A>Note that factors may be suffixed by any number of primary-operations.  The only restriction is that the types must be right during execution.  Thus:</P>
<PRE CLASS="CodeIn4cm"><A NAME="pgfId=175727"></A>xxx[123].aaa[10]</PRE>
<P CLASS="Body">
<A NAME="pgfId=175728">
 </A>is legal.</P>
<P CLASS="Body">
<A NAME="pgfId=175730">
 </A>The two constructs</P>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247527">
 </A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247529">
 </A><B CLASS="+Bold">
-&gt;</B>
 <I CLASS="+Italic">
identifier</I>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247531">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247533">
 </A><B CLASS="+Bold">
-&gt; (</B>
 <I CLASS="+Italic">
expression</I>
<B CLASS="+Bold">
 )</B>
</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId=175734">
 </A>are again notational variations.  In general, constructs of the form:</P>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247576">
 </A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247544">
 </A><I CLASS="+Italic">
primary-expression </I>
<B CLASS="+Bold">
-&gt;</B>
 <I CLASS="+Italic">
identifier</I>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247546">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247548">
 </A><I CLASS="+Italic">
primary-expression </I>
<B CLASS="+Bold">
-&gt; (</B>
 <I CLASS="+Italic">
expression</I>
<B CLASS="+Bold">
 )</B>
</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId=175736">
 </A>are re-written as:	</P>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247578">
 </A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247559">
 </A><B CLASS="+Bold">
( * </B>
<I CLASS="+Italic">
primary-expresion </I>
<B CLASS="+Bold">
) .</B>
 <I CLASS="+Italic">
identifier</I>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247580">
 </A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247563">
 </A><B CLASS="+Bold">
( * </B>
<I CLASS="+Italic">
primary-expression</I>
 <B CLASS="+Bold">
) . (</B>
 <I CLASS="+Italic">
expression</I>
<B CLASS="+Bold">
 )</B>
</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId=175741">
 </A>The unary operator * used here is the indirection operator, its meaning is discussed later.</P>
<P CLASS="Body">
<A NAME="pgfId=247823">
 </A>The index operators <B CLASS="+Bold">
:</B>
 and <B CLASS="+Bold">
:^</B>
 index the primary expression to discover a function, the result of the operation is a callable method. These operators and methods are discussed in more detail below.</P>
<P CLASS="Body">
<A NAME="pgfId=175742">
 </A>The last of the primary-operations:</P>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247584">
 </A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247586">
 </A><B CLASS="+Bold">
( </B>
<I CLASS="+Italic">
expression-list</I>
 <B CLASS="+Bold">
)</B>
</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId=175745">
 </A>is the call operation.  Although, as usual, no type checking is performed by the parser; at execution time the thing it is applied to must be callable.  For example:</P>
<PRE CLASS="CodeIn4cm"><A NAME="pgfId=175747"></A>my_function(1, 2, &quot;a string&quot;)</PRE>
<P CLASS="Body">
<A NAME="pgfId=175748">
 </A>and</P>
<PRE CLASS="CodeIn4cm"><A NAME="pgfId=175750"></A>xxx.array_of_funcs[10]()</PRE>
<P CLASS="Body">
<A NAME="pgfId=175751">
 </A>are both function calls.  Function calls will be discussed in more detail below.</P>
<P CLASS="Body">
<A NAME="pgfId=175752">
 </A>This concludes the examination of a primary-expression.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=247690">
 </A>Terms</H4>
<P CLASS="Body">
<A NAME="pgfId=175753">
 </A>Primary-expressions are combined with prefix and postfix unary operators to make terms:</P>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247600">
 </A><I CLASS="+Italic">
term</I>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247602">
 </A><I CLASS="+Italic">
[</I>
 <I CLASS="+Italic">
prefix-operator... ]</I>
 <I CLASS="+Italic">
primary-expression</I>
 <I CLASS="+Italic">
[</I>
 <I CLASS="+Italic">
postfix-operator...</I>
 <I CLASS="+Italic">
]</I>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247604">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247606">
 </A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247608">
 </A><I CLASS="+Italic">
prefix-operator&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</I>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247610">
 </A><I CLASS="+Italic">
Any of:</I>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247612">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247614">
 </A><B CLASS="+Bold">
*&nbsp;&nbsp;&amp;&nbsp;&nbsp;-&nbsp;&nbsp;+&nbsp;&nbsp;!&nbsp;&nbsp;~&nbsp;&nbsp;++&nbsp;&nbsp;--&nbsp;&nbsp;@&nbsp;&nbsp;$</B>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247616">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247618">
 </A>&nbsp;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247620">
 </A><I CLASS="+Italic">
postfix-operator</I>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247622">
 </A><I CLASS="+Italic">
Any of:</I>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247624">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247626">
 </A><B CLASS="+Bold">
++&nbsp;&nbsp;--</B>
</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId=175759">
 </A>That is, a term is a primary-expression surrounded on both sides by any number of prefix and postfix operators.  Postfix operators bind more tightly than prefix operators. Both types bind right-to-left when concatenated together.  That is: -!x is the same as -(!x).  As in all expression compilation, no type checking is performed by the parser, because types are an execution-time consideration.</P>
<P CLASS="Body">
<A NAME="pgfId=175761">
 </A>Some of these operators touch on subjects not yet explained and so will be dealt with in detail in later sections.  But in summary:</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175762">
 </A>Prefix operators</H4>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247696">
 </A>&nbsp;&nbsp;&nbsp;&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247698">
 </A><B CLASS="+Bold">
*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</B>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247700">
 </A>Indirection; applied to a pointer, gives target of the pointer.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247702">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247704">
 </A><B CLASS="+Bold">
&amp;</B>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247706">
 </A>Address of; applied to any lvalue, gives a pointer to it.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247708">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247710">
 </A><B CLASS="+Bold">
-</B>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247712">
 </A>Negation; gives negative of any arithmetic value.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247714">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247716">
 </A><B CLASS="+Bold">
+</B>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247718">
 </A>Positive; no real effect.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247720">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247722">
 </A><B CLASS="+Bold">
!</B>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247724">
 </A>Logical not; applied to 0 or NULL, gives 1, else gives 0.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247726">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247728">
 </A><B CLASS="+Bold">
~</B>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247730">
 </A>Bit-wise complement.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247732">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247734">
 </A><B CLASS="+Bold">
++</B>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247736">
 </A>Pre-increment; increments an lvalue and gives new value.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247738">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247740">
 </A><B CLASS="+Bold">
--</B>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247742">
 </A>Pre-decrement; decrements an lvalue and gives new value.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247744">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247746">
 </A><B CLASS="+Bold">
@</B>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247748">
 </A>Atomic form of; gives the (unique) read-only version of any value.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247750">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247752">
 </A><B CLASS="+Bold">
$</B>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247754">
 </A>Immediate evaluation; see below.</P>
</TD>
</TR>
</TABLE>
<P CLASS="Untitled">
<A NAME="pgfId=175773">
 </A>&nbsp;</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175774">
 </A>Postfix operators</H4>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247759">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247761">
 </A><B CLASS="+Bold">
++</B>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247763">
 </A>Post-increment; increments an lvalue and gives old value.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247765">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247767">
 </A><B CLASS="+Bold">
--</B>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247769">
 </A>Post-increment; decrements an lvalue and gives old value.</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId=175779">
 </A>One of these operators, $, is only a pseudo-operator.  It actually has its effect entirely at parse time.  The $ operator causes its subject expression to be evaluated immediately by the parser and the result of that evaluation substituted in its place.  This is used to speed later execution, to protect against later scope or variable changes, and to construct constant values which are better made with running code than literal constants.  For example, an expression involving the square root of two could be written as:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175780"></A>x = y + 1.414213562373095;</PRE>
<P CLASS="Body">
<A NAME="pgfId=175782">
 </A>Or it could be written more clearly, and with less chance of error, as:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175783"></A>x = y + sqrt(2.0);</PRE>
<P CLASS="Body">
<A NAME="pgfId=175785">
 </A>But this construct will call the square root function each time the expression is evaluated. If the expression is written as:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175786"></A>x = y + $sqrt(2.0);</PRE>
<P CLASS="Body">
<A NAME="pgfId=175788">
 </A>The square root function will be called just once, by the parser, and will be equivalent to the first form.</P>
<P CLASS="Body">
<A NAME="pgfId=175789">
 </A>When the parser evaluates the subject of a $ operator it recursively invokes the execution engine to perform the evaluation.  As a result there is no restriction on the activity which can be performed by the subject expression.  It may reference variables, call functions or even read files.  But it is important to remember that it is called at parse time.  Any variables referenced will be immediately interrogated for their current value.  Automatic variables of any expression which is contained in a function will not be available, because the function itself has not yet been invoked; in fact it is clearly not yet even fully parsed.</P>
<P CLASS="Body">
<A NAME="pgfId=175791">
 </A>The $ operator as used above increased speed and readability. Another common use is to avoid later re-definitions of a variable.  For instance:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175792"></A>($printf)(&quot;Hello world\n&quot;);</PRE>
<P CLASS="Body">
<A NAME="pgfId=175794">
 </A>Will use the printf function which was defined at the time the statement was parsed, even if it is latter re-defined to be some other function.  It is also slightly faster, but the difference is small when only a simple variable look-up is involved.  Notice the bracketing which has been used to bind the $ to the word printf.  Function calls are primary operations so the $ would have otherwise referred to the whole function call as it did in the first example.</P>
<P CLASS="Body">
<A NAME="pgfId=175795">
 </A>This concludes our examination of a term (remember that the full meaning of other prefix and postfix operators will be discussed in later sections).</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=247831">
 </A>Binary operators</H4>
<P CLASS="Body">
<A NAME="pgfId=247830">
 </A>We will now turn to the top level of expressions where terms are combined with binary operators:</P>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247837">
 </A><I CLASS="+Italic">
expression</I>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247839">
 </A><I CLASS="+Italic">
term</I>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247841">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247843">
 </A><I CLASS="+Italic">
expression infix-operator expression</I>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247845">
 </A><I CLASS="+Italic">
infix-operator&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</I>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247847">
 </A><I CLASS="+Italic">
Any of:</I>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247849">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247851">
 </A><B CLASS="+Bold">
@</B>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247853">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247855">
 </A><B CLASS="+Bold">
*&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;%</B>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247857">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247859">
 </A><B CLASS="+Bold">
+&nbsp;&nbsp;&nbsp;-</B>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247861">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247863">
 </A><B CLASS="+Bold">
&gt;&gt;&nbsp;&nbsp;&nbsp;&lt;&lt;</B>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247865">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247867">
 </A><B CLASS="+Bold">
&lt;&nbsp;&nbsp;&nbsp;&gt;&nbsp;&nbsp;&nbsp;&lt;=&nbsp;&nbsp;&nbsp;&gt;=</B>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247869">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247871">
 </A><B CLASS="+Bold">
==&nbsp;&nbsp;&nbsp;!=&nbsp;&nbsp;&nbsp;~&nbsp;&nbsp;&nbsp;!~&nbsp;&nbsp;&nbsp;~~&nbsp;&nbsp;&nbsp;~~~</B>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247873">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247875">
 </A><B CLASS="+Bold">
&amp;</B>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247877">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247879">
 </A><B CLASS="+Bold">
^</B>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247881">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247883">
 </A><B CLASS="+Bold">
|</B>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247885">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247887">
 </A><B CLASS="+Bold">
&amp;&amp;</B>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247889">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247891">
 </A><B CLASS="+Bold">
||</B>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247893">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247895">
 </A><B CLASS="+Bold">
:</B>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247897">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247899">
 </A><B CLASS="+Bold">
?</B>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247901">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247903">
 </A><B CLASS="+Bold">
=&nbsp;&nbsp;&nbsp;+=&nbsp;&nbsp;&nbsp;-=&nbsp;&nbsp;&nbsp;*=&nbsp;&nbsp;&nbsp;/=&nbsp;&nbsp;&nbsp;%=&nbsp;&nbsp;&nbsp;&gt;&gt;=&nbsp;&nbsp;&nbsp;&lt;&lt;=&nbsp;&nbsp;&nbsp;&amp;=&nbsp;&nbsp;&nbsp;^=&nbsp;&nbsp;&nbsp;|=&nbsp;&nbsp;&nbsp;~~=&nbsp;&nbsp;&nbsp;&lt;=&gt;</B>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247905">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247907">
 </A><B CLASS="+Bold">
,</B>
</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId=175808">
 </A>That is, an expression can be a simple term, or two expressions separated by an infix-operator. The ambiguity amongst expressions built from several binary-operator separated expressions is resolved by assigning each operator a precedence and also applying rules for order of binding amongst equal precedence levels<A HREF="#pgfId=175519" CLASS="footnote">
2</A>.  The lines of binary operators in the syntax rules above summarise their precedence.  Operators on higher lines have higher precedence than those on lower lines.  Thus 1+2*3 is the same as 1+(2*3). Operators which share a line have the same precedence.  All operators except those on the second last line group left-to-right.  Those on the second last line (the assignment operators) group right-to-left.  Thus</P>
<PRE CLASS="CodeIn4cm"><A NAME="pgfId=175809"></A>a * b / c</PRE>
<P CLASS="Body">
<A NAME="pgfId=175811">
 </A>is the same as:</P>
<PRE CLASS="CodeIn4cm"><A NAME="pgfId=175812"></A>(a * b) / c</PRE>
<P CLASS="Body">
<A NAME="pgfId=175814">
 </A>But:</P>
<PRE CLASS="CodeIn4cm"><A NAME="pgfId=175815"></A>a = b += c</PRE>
<P CLASS="Body">
<A NAME="pgfId=175817">
 </A>is the same as:</P>
<PRE CLASS="CodeIn4cm"><A NAME="pgfId=175818"></A>a = (b += c)</PRE>
<P CLASS="Body">
<A NAME="pgfId=175820">
 </A>As with unary operators, the full meaning of each will be discussed in a later section.  But in summary:</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175821">
 </A>Binary operator summary</H4>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247970">
 </A>&nbsp;&nbsp;&nbsp;&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247972">
 </A><B CLASS="+Bold">
@&nbsp;&nbsp;&nbsp;&nbsp;</B>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247974">
 </A>Form pointer</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247976">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247978">
 </A><B CLASS="+Bold">
*</B>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247980">
 </A>Multiplication, Set intersection</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247982">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247984">
 </A><B CLASS="+Bold">
/</B>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247986">
 </A>Division</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247988">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247990">
 </A><B CLASS="+Bold">
%</B>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247992">
 </A>Modulus</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247994">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247996">
 </A><B CLASS="+Bold">
+</B>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=247998">
 </A>Addition, Set union</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248000">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248002">
 </A><B CLASS="+Bold">
-</B>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248004">
 </A>Subtraction, Set difference</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248006">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248008">
 </A><B CLASS="+Bold">
&gt;&gt;</B>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248010">
 </A>Right shift (shift to lower significance)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248012">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248014">
 </A><B CLASS="+Bold">
&lt;&lt;</B>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248016">
 </A>Left shift (shift to higher significance)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248018">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248020">
 </A><B CLASS="+Bold">
&lt;</B>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248022">
 </A>Logical test for less than, Proper subset</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248024">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248026">
 </A><B CLASS="+Bold">
&gt;</B>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248028">
 </A>Logical test for greater than, Proper superset</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248030">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248032">
 </A><B CLASS="+Bold">
&lt;=</B>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248034">
 </A>Logical test for less than or equal to, Subset</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248036">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248038">
 </A><B CLASS="+Bold">
&gt;=</B>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248040">
 </A>Logical test for greater than or equal to, Superset</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248042">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248044">
 </A><B CLASS="+Bold">
==</B>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248046">
 </A>Logical test for equality</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248048">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248050">
 </A><B CLASS="+Bold">
!=</B>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248052">
 </A>Logical test for inequality</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248054">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248056">
 </A><B CLASS="+Bold">
~</B>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248058">
 </A>Logical test for regular expression match</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248060">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248062">
 </A><B CLASS="+Bold">
!~</B>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248064">
 </A>Logical test for regular expression non-match</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248066">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248068">
 </A><B CLASS="+Bold">
~~</B>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248070">
 </A>Regular expression sub-string extraction</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248072">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248074">
 </A><B CLASS="+Bold">
~~~</B>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248076">
 </A>Regular expression multiple sub-string extraction</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248078">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248080">
 </A><B CLASS="+Bold">
&amp;</B>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248082">
 </A>Bit-wise and</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248084">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248086">
 </A><B CLASS="+Bold">
^</B>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248088">
 </A>Bit-wise exclusive or</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248090">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248092">
 </A><B CLASS="+Bold">
|</B>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248094">
 </A>Bit-wise or</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248096">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248098">
 </A><B CLASS="+Bold">
&amp;&amp;</B>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248100">
 </A>Logical and</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248102">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248104">
 </A><B CLASS="+Bold">
||</B>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248106">
 </A>Logical or</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248108">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248110">
 </A><B CLASS="+Bold">
:</B>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248112">
 </A>Choice separator (must be right hand subject of ? operator)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248114">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248116">
 </A><B CLASS="+Bold">
?</B>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248118">
 </A>Choice (right hand expression must use : operator)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248120">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248122">
 </A><B CLASS="+Bold">
=</B>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248124">
 </A>Assignment</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248126">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248128">
 </A><B CLASS="+Bold">
+=</B>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248130">
 </A>Add to</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248132">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248134">
 </A><B CLASS="+Bold">
-=</B>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248136">
 </A>Subtract from</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248138">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248140">
 </A><B CLASS="+Bold">
*=</B>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248142">
 </A>Multiply by</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248144">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248146">
 </A><B CLASS="+Bold">
/=</B>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248148">
 </A>Divide by</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248150">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248152">
 </A><B CLASS="+Bold">
%=</B>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248154">
 </A>Modulus by</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248156">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248158">
 </A><B CLASS="+Bold">
&gt;&gt;=</B>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248160">
 </A>Right shift by</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248162">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248164">
 </A><B CLASS="+Bold">
&lt;&lt;=</B>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248166">
 </A>Left shift by</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248168">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248170">
 </A><B CLASS="+Bold">
&amp;=</B>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248172">
 </A>And by</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248174">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248176">
 </A><B CLASS="+Bold">
^=</B>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248178">
 </A>Exclusive or by</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248180">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248182">
 </A><B CLASS="+Bold">
|=</B>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248184">
 </A>Or by</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248186">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248188">
 </A><B CLASS="+Bold">
~~=</B>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248190">
 </A>Replace by regular expression extraction</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248192">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248194">
 </A><B CLASS="+Bold">
&lt;=&gt;</B>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248196">
 </A>Swap values</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248198">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248200">
 </A><B CLASS="+Bold">
,</B>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248202">
 </A>Multiple expression separator</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId=175861">
 </A>This concludes our consideration of expressions.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=248232">
 </A>Statements</H3>
<P CLASS="Body">
<A NAME="pgfId=248233">
 </A>We will now move on to each of the executable statement types in turn.</P>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175863">
 </A>Simple expression statements</H4>
<P CLASS="Body">
<A NAME="pgfId=248248">
 </A>The simple expression statement:</P>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248258">
 </A><I CLASS="+Italic">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</I>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248260">
 </A><I CLASS="+Italic">
expression</I>
 <B CLASS="+Bold">
;</B>
</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId=248250">
 </A>Is just an expression followed by a semicolon.  The parser translates this expression to its executable form.  Upon execution the expression is evaluated and the result discarded. Typically the expression will have some side-effect such as assignment, or make a function call which has a side-effect, but there is no explicit requirement that it do so.  Typical expression statements are:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175869"></A>printf(&quot;Hello world.\n&quot;);
x = y + z;
++i;</PRE>
<P CLASS="Body">
<A NAME="pgfId=175525">
 </A>Note that an expression statement which could have no side-effects other than producing an error may be completely discarded and have no code generated for it.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175527">
 </A>Compound statements</H4>
<P CLASS="Body">
<A NAME="pgfId=175873">
 </A>The compound statement has the form:</P>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248273">
 </A><I CLASS="+Italic">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</I>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248275">
 </A><B CLASS="+Bold">
{ </B>
<I CLASS="+Italic">
statement... </I>
<B CLASS="+Bold">
}</B>
</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId=175876">
 </A>That is, a compound statement is a series of any number of statements surrounded by curly braces. Apart from causing all the sub-statements within the compound statement to be treated as a syntactic unit, it has no effect.  Thus:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175878"></A>printf(&quot;Line 1\n&quot;);
{
	printf(&quot;Line 2\n&quot;);
	printf(&quot;Line 3\n&quot;);
}
printf(&quot;Line 4\n&quot;);</PRE>
<P CLASS="Body">
<A NAME="pgfId=175882">
 </A>When run, will produce:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175883"></A>Line 1
Line 2
Line 3
Line 4</PRE>
<P CLASS="Body">
<A NAME="pgfId=175886">
 </A>Note that the parser will not return control to the execution engine until all of a top-level compound statement has been parsed.  This is true in general for all other statement types. </P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175888">
 </A>The if statement</H4>
<P CLASS="Body">
<A NAME="pgfId=248294">
 </A>The if statement has two forms:</P>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248312">
 </A><I CLASS="+Italic">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</I>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248303">
 </A><B CLASS="+Bold">
if (</B>
 <I CLASS="+Italic">
expression</I>
 <B CLASS="+Bold">
)</B>
 <I CLASS="+Italic">
statement</I>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248305">
 </A>&nbsp;</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248307">
 </A><B CLASS="+Bold">
if (</B>
 <I CLASS="+Italic">
expression</I>
 <B CLASS="+Bold">
)</B>
 <I CLASS="+Italic">
statement</I>
 <B CLASS="+Bold">
else</B>
 <I CLASS="+Italic">
statement</I>
</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId=175892">
 </A>The parser converts both to an internal form.  Upon execution, the expression is evaluated.  If the expression evaluates to anything other than 0 (integer zero) or NULL, the following statement is executed; otherwise it is not.  In the first form this is all that happens, in the second form, if the expression evaluated to 0 or NULL the statement following the else is executed; otherwise it is not.</P>
<P CLASS="Body">
<A NAME="pgfId=175893">
 </A>The interpretation of both 0 and NULL as false, and anything else as true, is common to all logical operations in ICI.  There is no special boolean type.</P>
<P CLASS="Body">
<A NAME="pgfId=175895">
 </A>The ambiguity introduced by multiple if statements with an lesser number of else clauses is resolved by binding else clauses with their closest possible if.  Thus:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175896"></A>if (a) if (b) dox(); else doy();</PRE>
<P CLASS="Body">
<A NAME="pgfId=175898">
 </A>If equivalent to:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175899"></A>if (a)
{
	if (b)
		dox();
	else
		doy();
}</PRE>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175903">
 </A>The while statement</H4>
<P CLASS="Body">
<A NAME="pgfId=175905">
 </A>The while statement has the form:</P>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248329">
 </A><I CLASS="+Italic">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</I>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId=248324">
 </A><B CLASS="+Bold">
while</B>
 <B CLASS="+Bold">
(</B>
 <I CLASS="+Italic">
expression</I>
 <B CLASS="+Bold">
)</B>
 <I CLASS="+Italic">
statement</I>
</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId=175908">
 </A>The parser converts it to an internal form.  Upon execution a loop is established.  Within the loop the expression is evaluated, and if it is false (0 or NULL) the loop is terminated and flow of control continues after the while statement.  But if the expression evaluates to true (not 0 and not NULL) the statement is executed and then flow of control moves back to the start of the loop where the test is performed again (although other statements, as seen below, can be used to modify this natural flow of control).</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175909">
 </A>The do-while statement</H4>
<P CLASS="Body">
<A NAME="pgfId=175911">
 </A>The do-while statement has the following form: ###UP TO HERE</P>
<P CLASS="Syntax">
<A NAME="pgfId=175912">
 </A>	do statement while ( expression ) ;</P>
<P CLASS="Body">
<A NAME="pgfId=175914">
 </A>The parser converts it to an internal form.  Upon execution a loop is established.  Within the loop the statement is executed.  Then the expression is evaluated and if it evaluates to true, flow of control resumes at the start of the loop.  Otherwise the loop is terminated and flow of control resumes after the do-while statement.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175915">
 </A>The for statement</H4>
<P CLASS="Body">
<A NAME="pgfId=175917">
 </A>The for statement has the form:</P>
<P CLASS="Syntax">
<A NAME="pgfId=175918">
 </A>	for ( [ expression ]; [ expression ]; [ expression ] ) statement</P>
<P CLASS="Body">
<A NAME="pgfId=175920">
 </A>The parser converts it to an internal form.  Upon execution the first expression is evaluated (if present).  Then, a loop is established.  Within the loop: If the second expression is present, it is evaluated and if it is false the loop is terminated.  Next the statement is executed.  Finally, the third expression is evaluated (if present) and flow of control resumes at the start of the loop.  For example:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175921"></A>for (i = 0; i &lt; 4; ++i)
	printf(&quot;Line %d\n&quot;, i);</PRE>
<P CLASS="Body">
<A NAME="pgfId=175923">
 </A>When run will produce:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175925"></A>Line 0
Line 1
Line 2
Line 3</PRE>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175928">
 </A>The forall statement</H4>
<P CLASS="Body">
<A NAME="pgfId=175929">
 </A>The forall statement has the form:</P>
<P CLASS="Syntax">
<A NAME="pgfId=175931">
 </A>	forall ( expression [ ,expression ] in expression ) statement</P>
<P CLASS="Body">
<A NAME="pgfId=175932">
 </A>The parser converts it to an internal form.  In doing so the first and second expressions are required to be lvalues (that is, capable of being assigned to).  Upon execution the first expression is evaluated and that storage location is noted.  If the second expression is present the same is done for it.  The third expression is then evaluated and the result noted; it must evaluate to an array, a set, a struct, a string, or NULL; we will call this the aggregate.  If this is NULL, the forall statement is finished and flow of control continues after the statement; otherwise, a loop is established.</P>
<P CLASS="Body">
<A NAME="pgfId=175934">
 </A>Within the loop, an element is selected from the noted aggregate.  The value of that element is assigned to the location given by the first expression.  If the second expression was present, it is assigned the key used to access that element.  Then  the statement is executed.  Finally, flow of control resumes at the start of the loop.</P>
<P CLASS="Body">
<A NAME="pgfId=175935">
 </A>Each arrival at the start of the loop will select a different element from the aggregate.  If no as yet unselected elements are left, the loop terminates.  The order of selection is predictable for arrays and strings, namely first to last.  But for structs and sets it is unpredictable.  Also, while changing the values of the structure members is acceptable, adding or deleting keys, or adding or deleting set elements during the loop will have an unpredictable effect on the progress of the loop.</P>
<P CLASS="Body">
<A NAME="pgfId=175534">
 </A>As an example:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175937"></A>forall (colour in [array &quot;red&quot;, &quot;green&quot;, &quot;blue&quot;])
	printf(&quot;%s\n&quot;, colour);</PRE>
<P CLASS="Body">
<A NAME="pgfId=175939">
 </A>when run will produce:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175940"></A>red
green
blue</PRE>
<P CLASS="Body">
<A NAME="pgfId=175943">
 </A>And:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175944"></A>forall (value, key in [struct a = 1, b = 2, c = 3])
	printf(&quot;%s = %d\n&quot;, key, value);</PRE>
<P CLASS="Body">
<A NAME="pgfId=175946">
 </A>when run will produce (possibly in some other order):</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175948"></A>c = 3
a = 1
b = 2</PRE>
<P CLASS="Body">
<A NAME="pgfId=175950">
 </A>Note in particular the interpretation of the value and key for a set.  For consistency with the access method and the behavior of structs and arrays, the values are all 1 and the elements are regarded as the keys, thus:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175952"></A>forall (value, key in [set &quot;a&quot;, &quot;b&quot;, &quot;c&quot;])
	printf(&quot;%s = %d\n&quot;, key, value);</PRE>
<P CLASS="Body">
<A NAME="pgfId=175954">
 </A>when run will produce:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175955"></A>c = 1
a = 1
b = 1</PRE>
<P CLASS="Body">
<A NAME="pgfId=175958">
 </A>But as a special case, when the second expression is omitted, the first is set to each &quot;key&quot; in turn, that is, the elements of the set.  Thus:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175959"></A>forall (element in [set &quot;a&quot;, &quot;b&quot;, &quot;c&quot;])
	printf(&quot;%s\n&quot;, element);</PRE>
<P CLASS="Body">
<A NAME="pgfId=175961">
 </A>when run will produce:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175963"></A>c
a
b</PRE>
<P CLASS="Body">
<A NAME="pgfId=175965">
 </A>When a forall loop is applied to a string (which is not a true aggregate), the &quot;sub-elements&quot; will be successive one character sub-strings.</P>
<P CLASS="Body">
<A NAME="pgfId=175967">
 </A>Note that although the sequence of choice of elements from a set or struct is at first examination unpredictable, it will be the same in a second forall loop applied without the structure or set being modified in the interim.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175968">
 </A>The switch, case, and default statements</H4>
<P CLASS="Body">
<A NAME="pgfId=175970">
 </A>These statements have the forms:</P>
<P CLASS="Syntax">
<A NAME="pgfId=175971">
 </A>	switch ( expression ) compound-statement<BR>
	case expression :<BR>
	default <CODE CLASS="CourierBold">
:</CODE>
</P>
<P CLASS="Body">
<A NAME="pgfId=175974">
 </A>The parser converts the switch statement to an internal form.  As it is parsing the compound statement, it notes any case and default statements it finds at the top level of the compound statement.  When a case statement is parsed the expression is evaluated immediately by the parser.  As noted previously for parser evaluated expressions, it may perform arbitrary actions, but it is important to be aware that it is resolved to a particular value just once by the parser.  As the case and default statements are seen their position and the associated expressions are noted in a table.</P>
<P CLASS="Body">
<A NAME="pgfId=175975">
 </A>Upon execution, the switch statement's expression is evaluated.  This value is looked up in the table created by the parser.  If a matching case statement is found, flow of control immediately moves to immediately after that case statement.  If there is a default statement, flow of control immediately moves to just after that.  If there is no matching case and no default statement, flow of control continues just after the entire switch statement.</P>
<P CLASS="Body">
<A NAME="pgfId=175977">
 </A>For example:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175978"></A>switch (&quot;a string&quot;)
{
case &quot;another string&quot;:
	printf(&quot;Not this one.\n&quot;);
case 2:
	printf(&quot;Not this one either.\n&quot;);
case &quot;a string&quot;:
	printf(&quot;This one.\n&quot;);
default:
	printf(&quot;And this one too.\n&quot;);
}</PRE>
<P CLASS="Body">
<A NAME="pgfId=175985">
 </A>When run will produce:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175987"></A>This one.
And this one too.</PRE>
<P CLASS="Body">
<A NAME="pgfId=175989">
 </A>Note that the case and default statements, apart from the part they play in the construction of the look-up table, do not influence the executable code of the compound statement.  Notice that once flow of control had transferred to the third case statement above, it continued through the default statement as if it had not been present.  This behavior can be modified by the break statement described below.</P>
<P CLASS="Body">
<A NAME="pgfId=175990">
 </A>It should be noted that the &quot;match&quot; used to look-up the switch expression against the case expressions is the same as that used for structure element look-up. That is, to match, the switch expression must evaluate to the same object as the case expression.  The meaning of this will be made clear in a later section.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175992">
 </A>The break and continue statements</H4>
<P CLASS="Body">
<A NAME="pgfId=175993">
 </A>The break and continue statements have the form:</P>
<P CLASS="Syntax">
<A NAME="pgfId=175995">
 </A>	<CODE CLASS="CourierBold">
break ;<BR>
	continue ;</CODE>
</P>
<P CLASS="Body">
<A NAME="pgfId=175997">
 </A>The parser converts these to an internal form.  Upon execution of a break statement the execution engine will cause the nearest enclosing loop (a while, do, for or forall) or switch statement within the same scope to terminate.  Flow of control will resume immediately after the affected statement.  Note that a break statement without a surrounding loop or switch in the same function or module is illegal.</P>
<P CLASS="Body">
<A NAME="pgfId=175998">
 </A>Upon execution of a continue statement the execution engine will cause the nearest enclosing loop to move to the next iteration.  For while and do loops this means the test.  For for loops it means the step, then the test.  For forall loops it means the next element of the aggregate.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=176000">
 </A>The return statement</H4>
<P CLASS="Body">
<A NAME="pgfId=176001">
 </A>The return statement has the form:</P>
<P CLASS="Syntax">
<A NAME="pgfId=176003">
 </A>	<CODE CLASS="CourierBold">
return</CODE>
 [ expression ] <CODE CLASS="CourierBold">
;</CODE>
</P>
<P CLASS="Body">
<A NAME="pgfId=175538">
 </A>The parser converts this to an internal form.  Upon execution, the execution engine evaluates the expression if it is present.  If it is not, the value NULL is substituted.  Then the current function terminates with that value as its apparent value in any expression it is embedded in.  It is an error for there to be no enclosing function.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=176005">
 </A>The try statement</H4>
<P CLASS="Body">
<A NAME="pgfId=176007">
 </A>The try statement has the form:</P>
<P CLASS="Syntax">
<A NAME="pgfId=176008">
 </A>	<CODE CLASS="CourierBold">
try</CODE>
  statement <CODE CLASS="CourierBold">
onerror</CODE>
 statement</P>
<P CLASS="Body">
<A NAME="pgfId=176010">
 </A>The parser converts this to an internal form.  Upon execution, the first statement is executed. If this statement executes normally flow continues after the try statement; the second statement is ignored.  But if an error occurs during the execution of the first statement control is passed immediately to the second statement.</P>
<P CLASS="Body">
<A NAME="pgfId=176011">
 </A>Note that &quot;during the execution&quot; applies to any depth of function calls, even to other modules or the parsing of sub-modules.  When an error occurs both the parser and execution engine unwind as necessary until an error catcher (that is, a try statement) is found.</P>
<P CLASS="Body">
<A NAME="pgfId=176013">
 </A>Errors can occur almost anywhere and for a variety of reasons.  They can be explicitly generated with the fail function (described below), they can be generated as a side-effect of execution (such as division by zero), and they can be generated by the parser due to syntax or semantic errors in the parsed source.  For whatever reason an error is generated, a message (a string) is always associated with it.</P>
<P CLASS="Body">
<A NAME="pgfId=176014">
 </A>When any otherwise uncaught error occurs during the execution of the first statement, two things are done:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId=175539">
 </A>Firstly, the string associated with the failure is assigned to the variable error.  The assignment is made as if by a simple assignment statement within the scope of the try statement.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId=176017">
 </A>Secondly, flow of control is passed to the statement following the onerror keyword.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId=176018">
 </A>Once the second statement finishes execution, flow of control continues as if the whole try statement had executed normally.</P>
<P CLASS="Body">
<A NAME="pgfId=176020">
 </A>For example:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=176021"></A>static
div(a, b)
{
	try
		return a / b;
	onerror
		return 0;
}

printf(&quot;4 / 2 = %d\n&quot;, div(4, 2));
printf(&quot;4 / 0 = %d\n&quot;, div(4, 0));</PRE>
<P CLASS="Body">
<A NAME="pgfId=176027">
 </A>When run will print:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=176029"></A>4 / 2 = 2
4 / 0 = 0</PRE>
<P CLASS="Body">
<A NAME="pgfId=176031">
 </A>The handling of errors which are not caught by any try statement is implementation dependent.  A typical action is to prepend the file and line number on which the error occurred to the error string, print this, and exit.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=176033">
 </A>The null statement</H4>
<P CLASS="Body">
<A NAME="pgfId=176034">
 </A>The null statement has the form:</P>
<P CLASS="Syntax">
<A NAME="pgfId=176036">
 </A>	<CODE CLASS="CourierBold">
;</CODE>
</P>
<P CLASS="Body">
<A NAME="pgfId=176037">
 </A>The parser may convert this to an internal form. Upon execution it will do nothing.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=176039">
 </A>Declaration statements</H4>
<P CLASS="Body">
<A NAME="pgfId=176040">
 </A>There are two types of declaration statements:</P>
<P CLASS="Syntax">
<A NAME="pgfId=176042">
 </A>declaration	storage-class declaration-list <CODE CLASS="CourierBold">
;<BR>
</CODE>
	storage-class identifier function-body</P>
<P CLASS="Syntax">
<A NAME="pgfId=176044">
 </A>storage-class	extern<BR>
	<CODE CLASS="CourierBold">
static<BR>
</CODE>
	<CODE CLASS="CourierBold">
auto</CODE>
</P>
<P CLASS="Body">
<A NAME="pgfId=176046">
 </A>The first is the general case while the second is an abbreviated form for function definitions.  Declaration statements are syntactically equal to any other statement, but their effect is made entirely at parse time.  They act as null statements to the execution engine.  There are no restriction on where they may occur, but their effect is a by-product of their parsing, not of any execution.</P>
<P CLASS="Body">
<A NAME="pgfId=176048">
 </A>Declaration statements must start with one of the storage-class keywords listed above<A HREF="#pgfId=175520" CLASS="footnote">
3</A>.  Considering the general case first, we next have a declaration-list.</P>
<P CLASS="Syntax">
<A NAME="pgfId=176049">
 </A>declaration-list	identifier [ <CODE CLASS="CourierBold">
=</CODE>
 expression ]<BR>
	declaration-list <CODE CLASS="CourierBold">
,</CODE>
 identifier [ <CODE CLASS="CourierBold">
=</CODE>
 expression ]</P>
<P CLASS="Body">
<A NAME="pgfId=176051">
 </A>That is, a comma separated list of identifiers, each with an optional initialisation, terminated by a semicolon.  For example:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=176053"></A>static a, b = 2, c = [array 1, 2, 3];</PRE>
<P CLASS="Body">
<A NAME="pgfId=176054">
 </A>The storage class keyword establishes which scope the variables in the list are established in, as discussed earlier.  Note that declaring the same identifier at different scope levels is permissible and that they are different variables.</P>
<P CLASS="Body">
<A NAME="pgfId=176056">
 </A>A declaration with no initialisation first checks if the variable already exists at the given scope.  If it does, it is left unmodified.  In particular, any value it currently has is undisturbed.  If it does not exist it is established and is given the value NULL.</P>
<P CLASS="Body">
<A NAME="pgfId=176057">
 </A>A declaration with an initialisation establishes the variable in the given scope and gives it the given value even if it already exists and even if it has some other value.</P>
<P CLASS="Body">
<A NAME="pgfId=176059">
 </A>Note that initial values are parser evaluated expressions.  That is they are evaluated immediately by the parser, but may take arbitrary actions apart from that.  For example:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=176060"></A>static
fibonacci(n)
{
	if (n &lt;= 1)
		return 1;
	return fibonacci(n - 1) + fibonacci(n - 2);
}

static fib10 = fibonacci(10);</PRE>
<P CLASS="Body">
<A NAME="pgfId=176066">
 </A>The declaration of fib10 calls a function.  But that function has already been defined so this will work.</P>
<P CLASS="Body">
<A NAME="pgfId=176067">
 </A>Note that the scope of a static variable is (normally) the entire module it is parsed in.  For example:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=176069"></A>static
func()
{
	static aStatic = &quot;The value of a static.&quot;;
}

printf(&quot;%s\n&quot;, aStatic);</PRE>
<P CLASS="Body">
<A NAME="pgfId=176073">
 </A>when run will print:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=176075"></A>The value of a static.</PRE>
<P CLASS="Body">
<A NAME="pgfId=176076">
 </A>That is, despite being declared within a function, the declaration of aStatic has the same effect as if it had been declared outside the function.  Also notice that the function has not been called.  The act of parsing the function caused the declaration to take effect.</P>
<P CLASS="Body">
<A NAME="pgfId=176078">
 </A>The behavior of extern variables has already been discussed, that is, they are declared as static in the parent module.  The behavior of auto variables, and in particular their initialisation, will be discussed in a later section.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=176079">
 </A>Abbreviated function declarations</H4>
<P CLASS="Body">
<A NAME="pgfId=176081">
 </A>As seen above there are two forms of declaration.  The second:</P>
<P CLASS="Syntax">
<A NAME="pgfId=176082">
 </A>	storage-class identifier function-body</P>
<P CLASS="Body">
<A NAME="pgfId=176084">
 </A>is a shorthand for:</P>
<P CLASS="Syntax">
<A NAME="pgfId=176085">
 </A>	storage-class identifier <CODE CLASS="CourierBold">
= [ func</CODE>
 function-body <CODE CLASS="CourierBold">
] ;</CODE>
</P>
<P CLASS="Body">
<A NAME="pgfId=176087">
 </A>and is the normal way to declare simple functions.  Examples of this have been seen above.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=176088">
 </A>Functions</H4>
<P CLASS="Body">
<A NAME="pgfId=176090">
 </A>As with most ICI constructs there are two parts to understanding functions; how they are parsed and how they execute.</P>
<P CLASS="Body">
<A NAME="pgfId=176091">
 </A>When a function is parsed four things are noted:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId=176093">
 </A>the names and positions of the formal parameters;</LI>
<LI CLASS="Bullet">
<A NAME="pgfId=176094">
 </A>the names and initialisation of auto variables;</LI>
<LI CLASS="Bullet">
<A NAME="pgfId=176095">
 </A>the static scope in which the function is declared;</LI>
<LI CLASS="Bullet">
<A NAME="pgfId=176096">
 </A>the code generated by the statements in the function.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId=176097">
 </A>The formal parameters (that is, the identifiers in the bracket enclosed list just before the compound statement) are actually implicit auto variable declarations.  Each of the identifiers is declared as an auto variable without an initialisation, but in addition, its name and position in the list is noted.</P>
<P CLASS="Body">
<A NAME="pgfId=175540">
 </A>Upon execution (that is, upon a function call), the following takes place:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId=175542">
 </A>The auto variables, as noted by the parser, along with any initialisations, are copied as a group.  This copy forms the auto variables of this invocation.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId=176100">
 </A>Any actual parameters (that is, expressions provided by the caller) are matched positionally with the formal parameter names, and the value of those expressions are assigned to the auto variables of those names.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId=176101">
 </A>If there were more actual parameters than formal parameters, and there is an auto variable called vargs, the remaining argument values are formed into an array which is assigned to vargs.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId=175541">
 </A>The variable scope is set such that the auto variables are the inner-most scope, the static variables noted with the function are the next outer scope etc.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId=176103">
 </A>The flow of control is diverted to the code generated by parsing the function.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId=176104">
 </A>A return statement executed within the function will cause the function to return to the caller and act as though its value were the expression given in the return statement.  If no expression was given in the return statement, or if execution fell through the bottom of the function, the apparent return value is NULL.  In any event, upon return the scope is restored to that of the caller.  All internal references to the group of automatic variables are lost (although as will be seen later explicit program references may cause them to remain active).</P>
<P CLASS="Body">
<A NAME="pgfId=176106">
 </A>Simple functions have been seen in earlier examples.  We will now consider further issues.</P>
<P CLASS="Body">
<A NAME="pgfId=176108">
 </A>It is very important to note that the parser generates a prototype set of auto variables which are copied, along with their initial values, when the function is called.  The value which an auto variable is initialised with is a parser evaluated expression just like any other initialisation.  It is not evaluated on function entry.  But on function entry the value the parser determined is used to initialise the variable.  For example:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=176110"></A>static myVar = 100;

static
myFunc()
{
	auto anAuto = myVar;

	printf(&quot;%d\n&quot;, anAuto);
	anAuto = 500;
}

myFunc();
myVar = 200;
myFunc();</PRE>
<P CLASS="Body">
<A NAME="pgfId=176120">
 </A>When run will print:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=176121"></A>100
100</PRE>
<P CLASS="Body">
<A NAME="pgfId=176123">
 </A>Notice that the initial value of anAuto was computed just once, changing myVar before the second call did not affect it.  Also note that changing anAuto during the function did not affect its subsequent re-initialisation on the next invocation.</P>
<P CLASS="Body">
<A NAME="pgfId=175543">
 </A>As stated above, formal parameters are actually uninitialised auto variables.  Because of the behavior of variable declarations it is possible to explicitly declare an auto variable as well as include it in the formal parameter list.  In addition, such an explicit declaration may have an initialisation.  In this case, the explicit initialisation will be effective when there is no actual parameter to override it.  For example:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175550"></A>static
print(msg, file)
{
	auto file = stdout; /* Default value. */

	fprintf(file, &quot;%s\n&quot;, msg);
}

print(&quot;Hello world&quot;);
print(&quot;Hello world&quot;, stderr);</PRE>
<P CLASS="Body">
<A NAME="pgfId=176129">
 </A>In the first call to the function print there is no second actual parameter.  In this case the explicit initialisation of the auto variable file (which is the second formal parameter) will have its effect unmolested.  But in the second call to print a second argument is given.  In this case this value will over-write the explicit initialisation given to the argument and cause the output to go to stderr.</P>
<P CLASS="Body">
<A NAME="pgfId=176130">
 </A>As indicated above there is a mechanism to capture additional actual parameters which were not mentioned in the formal parameter list.  Consider the following example:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=176131"></A>static
sum()
{
	auto vargs;
	auto total = 0;
	auto arg;

	forall (arg in vargs)
		total += arg;
	return total;
}

printf(&quot;1+2+3 = %d\n&quot;, sum(1, 2, 3));
printf(&quot;1+2+3+4 = %d\n&quot;, sum(1, 2, 3, 4));</PRE>
<P CLASS="Body">
<A NAME="pgfId=176132">
 </A>Which when run will produce:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=176133"></A>1+2+3 = 6
1+2+3+4 = 10</PRE>
<P CLASS="Body">
<A NAME="pgfId=176134">
 </A>In this example the unmatched actual parameters were formed into an array and assigned to the auto variable vargs, a name which is recognised specially by the function call mechanism.</P>
<P CLASS="Body">
<A NAME="pgfId=176135">
 </A>And also consider the following example where a default initialisation to vargs is made.  In the following example the function call is used to invoke a function with an array of actual parameters, the function array is used to form an array at run-time, and addition is used to concatenate arrays; all these features will be further explained in later sections:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=176136"></A>static
debug(fmt)
{
	auto fmt = &quot;Reached here.\n&quot;;
	auto vargs = [array];

	call(fprintf, array(stderr, fmt) + vargs);
}

debug();
debug(&quot;Done that.\n&quot;);
debug(&quot;Result = %d, total = %d.\n&quot;, 123, 456);</PRE>
<P CLASS="Body">
<A NAME="pgfId=176137">
 </A>When run will print:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=176138"></A>Reached here.
Done that.
Result = 123, total = 456.</PRE>
<P CLASS="Body">
<A NAME="pgfId=176139">
 </A>In the first call to debug no arguments are given and both explicit initialisations take effect.  In the second call the first argument is given, but the initialisation of vargs still takes effect.  But in the third call there are unmatched actual parameters, so these are formed into an array and assigned to vargs, overriding its explicit initialisation.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=176140">
 </A>Method Calls</H4>
<P CLASS="Body">
<A NAME="pgfId=180311">
 </A>In addition to the above ICI has a simple mechanism for calling <I CLASS="+Italic">
methods</I>
 -- functions contained within an object (typically a <I CLASS="+Italic">
struct</I>
) that accept that object as their first parameter. The method call mechanism is enabled via a modification to the <I CLASS="+Italic">
call</I>
 operator, &quot;()&quot;, to add semantics for calling a pointer object and through the addition of a new operator, binary-@, to form a pointer object from an object and a key. ICI pointers, described below, consist of an object and a key. To indirect though the pointer the object is indexed by the key and the resulting object used as the result. This is the same operation used in dynamic dispatch in languages such as Smalltalk and Objective-C.</P>
<P CLASS="Body">
<A NAME="pgfId=180312">
 </A>The call operator now accepts a pointer as its first operand (we may think of the call operator as a n-ary operator that takes a function or pointer object as its first operand the function parameters as the remaining operands). When a pointer is &quot;called&quot; the key is used to index the pointer's container object and the result, which must be a function object, is called. In addition the container object within the pointer is passed as an implicit first parameter to the function (thus passing the actual object used to invoke the method to the method). Apart from the calling semantics the functions used to implemented methods are in all respects normal ICI functions.</P>
<P CLASS="Body">
<A NAME="pgfId=180313">
 </A>Struct objects are typically used as the &quot;container&quot; for objects used with methods. The super mechanism provides the hierarichal search needed to allow class objects to be shared by multiple instances and provide a natural means of encapsulating information.</P>
<P CLASS="Body">
<A NAME="pgfId=180314">
 </A>A typical way of using methods is,</P>
<PRE CLASS="CodeIn1cm1"><A NAME="pgfId=180315"></A>/*</PRE>
<PRE CLASS="CodeIn1cm1"><A NAME="pgfId=180316"></A> * Define a &quot;class&quot; object representing our class and</PRE>
<PRE CLASS="CodeIn1cm1"><A NAME="pgfId=180317"></A> * containing the class methods.</PRE>
<PRE CLASS="CodeIn1cm1"><A NAME="pgfId=180318"></A> */</PRE>
<PRE CLASS="CodeIn1cm1"><A NAME="pgfId=180319"></A>static MyClass = [struct</PRE>
<PRE CLASS="CodeIn1cm1"><A NAME="pgfId=180320"></A>&nbsp;</PRE>
<PRE CLASS="CodeIn1cm1"><A NAME="pgfId=180321"></A>    doubleX = [func (self)</PRE>
<PRE CLASS="CodeIn1cm1"><A NAME="pgfId=180322"></A>    {</PRE>
<PRE CLASS="CodeIn1cm1"><A NAME="pgfId=180323"></A>        return self.x * 2;</PRE>
<PRE CLASS="CodeIn1cm1"><A NAME="pgfId=180324"></A>    }]</PRE>
<PRE CLASS="CodeIn1cm1"><A NAME="pgfId=180325"></A>&nbsp;</PRE>
<PRE CLASS="CodeIn1cm1"><A NAME="pgfId=180326"></A>];</PRE>
<PRE CLASS="CodeIn1cm1"><A NAME="pgfId=180327"></A>&nbsp;</PRE>
<PRE CLASS="CodeIn1cm1"><A NAME="pgfId=180328"></A>...</PRE>
<PRE CLASS="CodeIn1cm1"><A NAME="pgfId=180329"></A>&nbsp;</PRE>
<PRE CLASS="CodeIn1cm1"><A NAME="pgfId=180330"></A>static a;</PRE>
<PRE CLASS="CodeIn1cm1"><A NAME="pgfId=180331"></A>a = struct(@MyClass);</PRE>
<PRE CLASS="CodeIn1cm1"><A NAME="pgfId=180332"></A>a.x = 21;</PRE>
<PRE CLASS="CodeIn1cm1"><A NAME="pgfId=180333"></A>printf(&quot;%d\n&quot;, a@doubleX());</PRE>
<P CLASS="Body">
<A NAME="pgfId=180334">
 </A>&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId=180335">
 </A>We first define a class by using a literal struct to contain our named methods. You could also define class variables in this struct as it is shared by all instances of that class. In our class we've got a single method, doubleX, that doubles the value of an instance variable called x.</P>
<P CLASS="Body">
<A NAME="pgfId=180336">
 </A>Later in the program we create an instance of a MyClass object by making a new struct object and setting its super struct to the class struct. The super is made atomic which ensures all instances share the same object and makes it read-only for them. Then we create an &quot;instance variable&quot; within the object by assigning 21 to a.x and finally invoke the method. We do not pass any parameters to doubleX. The call through the pointer object formed by the binary-@ operator passes &quot;a&quot; implicitly</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=180068">
 </A>Objects</H4>
<P CLASS="Body">
<A NAME="pgfId=176141">
 </A>Up till now few exact statements about the nature of values and data have been made.  We will now examine values in more detail.  Consider the following code fragment:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175548"></A>static x;
static y;

x = [array 1, 2, 3, 4];
y = x;</PRE>
<P CLASS="Body">
<A NAME="pgfId=176142">
 </A>After execution of this code the variable x refers to an array.  The assignment of x to y causes y to refer to the same array. Diagrammatically:</P>
<DIV>
<IMG SRC="ici-1.gif">
</DIV>
<P CLASS="Body">
<A NAME="pgfId=176143">
 </A>If the assignment:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=176144"></A>y[1] = 200;</PRE>
<P CLASS="Body">
<A NAME="pgfId=176145">
 </A>is performed, the result is:</P>
<DIV>
<IMG SRC="ici-2.gif">
</DIV>
<P CLASS="Body">
<A NAME="pgfId=176146">
 </A>We say that x and y refer to the same object.  Now consider the following code fragment:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=176147"></A>static x;
static y;

x = [array 1, 2, 3, 4];
y = [array 1, 2, 3, 4];</PRE>
<P CLASS="Body">
<A NAME="pgfId=176148">
 </A>Diagrammatically:</P>
<DIV>
<IMG SRC="ici-3.gif">
</DIV>
<P CLASS="Body">
<A NAME="pgfId=176149">
 </A>In this case, x and y refer to different objects, despite that fact they are equal.</P>
<P CLASS="Body">
<A NAME="pgfId=175552">
 </A>Now consider one of the unary operators which was only briefly mentioned in the sections above.  The @ operator returns a read-only version of the sub-expression it is applied to.  Consider the following statement:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175554"></A>y = @y;</PRE>
<P CLASS="Body">
<A NAME="pgfId=176150">
 </A>After this has been executed the result could be represented diagrammatically as:</P>
<DIV>
<IMG SRC="ici-4.gif">
</DIV>
<P CLASS="Body">
<A NAME="pgfId=176151">
 </A>The middle array now has no reference to it and the memory associated with it will be collected by the interpreter's standard garbage collection mechanism. Now consider the following statement:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=176152"></A>x = @x;</PRE>
<P CLASS="Body">
<A NAME="pgfId=176153">
 </A>This is similar to the previous statement, except that this time x is replaced by a read-only version of its old value.  But the result of this operation is:</P>
<DIV>
<IMG SRC="ici-5.gif">
</DIV>
<P CLASS="Body">
<A NAME="pgfId=176154">
 </A>Notice that x now refers to the same read-only array that y refers to.  This is a fundamental property of the @ operator. It returns the unique read-only version of its argument value. Such read-only objects are referred to as atomic objects.  The array which x used to refer to was non-atomic, but the array it refers to now is an atomic array.  Aggregate types such as arrays, sets and structs are generally non-atomic, but atomic versions can be obtained (as seen above).  But most other types, such as integers floats, strings and functions are intrinsically atomic.  That is, no matter how a number, say 10, is generated, it will be the same object as every other number 10 in the interpreter.  For-instance, consider the following example:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=176155"></A>x = &quot;ab&quot; + &quot;cdefg&quot;;
y = &quot;abcde&quot; + &quot;fg&quot;;</PRE>
<P CLASS="Body">
<A NAME="pgfId=176156">
 </A>After this is executed the situation can be represented diagrammatically as:</P>
<DIV>
<IMG SRC="ici-6.gif">
</DIV>
<P CLASS="Body">
<A NAME="pgfId=176157">
 </A>It is important to understand when objects are the same object, when they are different and the effects this has.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=176158">
 </A>Equality</H4>
<P CLASS="Body">
<A NAME="pgfId=176159">
 </A>We saw above how two apparently identical arrays were each distinct object.  But these two arrays were equal in the sense of the equality testing operator ==.  If two values are the same object they are said to be eq<A HREF="#pgfId=175521" CLASS="footnote">
4</A>, and there is a function of that name to test for this condition.  Two objects are equal (that is ==) if:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId=176160">
 </A>they are the same object; or</LI>
<LI CLASS="Bullet">
<A NAME="pgfId=176161">
 </A>they are both arithmetic (int and float) and have equivalent numeric values; or</LI>
<LI CLASS="Bullet">
<A NAME="pgfId=176162">
 </A>they are aggregates of the same type and all the sub-elements are the same objects.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId=176163">
 </A>This definition of equality is the basis for resolving the merging of aggregates into unique read-only (atomic) versions.  Two aggregates will resolve to the same atomic object if they are equal.  That is, they must contain exactly the same objects as sub-elements, not just equal objects.  For example:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=176164"></A>static x = [array 1, [array 2, 3], 4, 5];
static y = [array 1, [array 2, 3], 4, 5];</PRE>
<P CLASS="Body">
<A NAME="pgfId=176165">
 </A>Could be represented diagrammatically as:</P>
<DIV>
<IMG SRC="ici-7.gif">
</DIV>
<P CLASS="Body">
<A NAME="pgfId=176166">
 </A>Now, if the following statements were executed:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=176167"></A>x = @x;
y = @y;</PRE>
<P CLASS="Body">
<A NAME="pgfId=176168">
 </A>The result could be represented diagrammatically as:</P>
<DIV>
<IMG SRC="ici-8.gif">
</DIV>
<P CLASS="Body">
<A NAME="pgfId=176169">
 </A>That is, both x and y refer to new read-only objects, but they refer to different read-only objects because they have an element which is not the same object.  The simple integers are the same objects because integers are intrinsically atomic objects.  But the two sub-arrays are distinct objects.  Being equal was not sufficient.  The top-level arrays needed to have exactly the same objects as contents to make x and y end up referring to the same read-only array.  In contrast to this consider the following similar situation:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=176170"></A>static z = [array 2, 3];
static x = [array 1, z, 4, 5];
static y = [array 1, z, 4, 5];</PRE>
<P CLASS="Body">
<A NAME="pgfId=176171">
 </A>This could be represented diagrammatically as:</P>
<DIV>
<IMG SRC="ici-9.gif">
</DIV>
<P CLASS="Body">
<A NAME="pgfId=176172">
 </A>Now, if the following statements were executed:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=176173"></A>x = @x;
y = @y;</PRE>
<P CLASS="Body">
<A NAME="pgfId=176174">
 </A>The result could be represented diagrammatically as:</P>
<DIV>
<IMG SRC="ici-10.gif">
</DIV>
<P CLASS="Body">
<A NAME="pgfId=176175">
 </A>In this case both x and y refer to the same read-only array because the original arrays where equal, that is, all their elements were the same objects.  Notice that one of the elements is still a writeable array.  The read-only property is only referring to the top level array.  The sub-array can be changed, but the reference to it from the top level array can not.  Thus:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=176176"></A>x[1][0] = 200;</PRE>
<P CLASS="Body">
<A NAME="pgfId=176177">
 </A>will result in:</P>
<DIV>
<IMG SRC="ici-11.gif">
</DIV>
<P CLASS="Body">
<A NAME="pgfId=175572">
 </A>whereas the statement:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=176178"></A>x[1] = 200;</PRE>
<P CLASS="Body">
<A NAME="pgfId=176179">
 </A>will just result in an error.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=176180">
 </A>Structure and set keys</H4>
<P CLASS="Body">
<A NAME="pgfId=176181">
 </A>Any object, not just a string, can be used as a key in a structure.  For instance:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=176182"></A>static x = [struct];
static z = [array 10, 11];

x[&quot;abc&quot;] = 1;
x[56] = 2;
x[z] = 3;</PRE>
<P CLASS="Body">
<A NAME="pgfId=176183">
 </A>Could be represented diagrammatically as:</P>
<DIV>
<IMG SRC="ici-12.gif">
</DIV>
<P CLASS="Body">
<A NAME="pgfId=176184">
 </A>And the assignment:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=176185"></A>x[z] = 300;</PRE>
<P CLASS="Body">
<A NAME="pgfId=176186">
 </A>would replace the 3 in the above diagram with 300.  But the assignment:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=176187"></A>x[[array 10, 11]] = 300;</PRE>
<P CLASS="Body">
<A NAME="pgfId=176188">
 </A>would result in a new element being added to the structure because the array given in the above statement is a different object from the one which z refers to.</P>
<P CLASS="Body">
<A NAME="pgfId=176189">
 </A>Similarly, elements of sets may be any objects.</P>
<P CLASS="Body">
<A NAME="pgfId=176190">
 </A>Indexing structures by complex aggregates is as efficient as indexing by intrinsically atomic types such as strings and integers.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=176191">
 </A>Structure super types</H4>
<P CLASS="Body">
<A NAME="pgfId=176192">
 </A>Up till now structures have been described as simple lookup tables which map a key, or index, to a value.  But a structure may have associated with it a super structure.</P>
<P CLASS="Body">
<A NAME="pgfId=176193">
 </A>The function super can be used to discover the current super of a struct and to set a new super.  With just one argument it returns the current super of that struct, with a second argument it also replaces the super by that value.</P>
<P CLASS="Body">
<A NAME="pgfId=176194">
 </A>When a key is being looked-up in a structure for reading, and it is not found and there is a super struct, the key is further looked for in the super struct, if it is found there its value from that struct is returned.  If it is not found it will be looked for in the next super struct etc.  If no structures in the super chain contain the key, the special value NULL is returned.</P>
<P CLASS="Body">
<A NAME="pgfId=176195">
 </A>When a key is being looked up in a structure for writing, it will similarly be searched for in the super chain.  If it is found in a writeable structure the value in the structure in which it was found will be set to the new value.  If it was never found, it will be added along with the given value to the very first struct, that is, the structure at the base, or root, of the super chain.</P>
<P CLASS="Body">
<A NAME="pgfId=176196">
 </A>Consider the following example:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=176197"></A>static theSuper = [struct a = 1, b = 2, c = 3];
static theStruct = [struct x = 100, y = 200];

super(theStruct, theSuper);</PRE>
<P CLASS="Body">
<A NAME="pgfId=176198">
 </A>After this statement the situation could be represented diagrammatically as:</P>
<DIV>
<IMG SRC="ici-13.gif">
</DIV>
<P CLASS="Body">
<A NAME="pgfId=176199">
 </A>then if the following statements were executed:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=176200"></A>theStruct.a = 123;
theStruct.x = 456;
theStruct.z = 789;</PRE>
<P CLASS="Body">
<A NAME="pgfId=176201">
 </A>the situation could be diagrammatically represented as:</P>
<DIV>
<IMG SRC="ici-14.gif">
</DIV>
<P CLASS="Body">
<A NAME="pgfId=176202">
 </A>If a super struct is not writeable (that is, it is atomic) values will not be written in it and will lodge in the base structure instead.  Thus consider what happens if we replace the super structure in the previous example by its read-only version:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=176203"></A>super(theStruct, @theSuper);</PRE>
<P CLASS="Body">
<A NAME="pgfId=176204">
 </A>The situation could now be represented diagrammatically as:</P>
<DIV>
<IMG SRC="ici-15.gif">
</DIV>
<P CLASS="Body">
<A NAME="pgfId=176205">
 </A>If the assignment statement:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=176206"></A>theStruct.a += 10;</PRE>
<P CLASS="Body">
<A NAME="pgfId=176207">
 </A>were executed, the value of the element a will first be read from the super structure, this value will then have ten added to it, and the result will be written back into the base structure; because the super structure is read-only and cannot be modified.  The finally situation can be represented diagrammatically as:</P>
<DIV>
<IMG SRC="ici-16.gif">
</DIV>
<P CLASS="Body">
<A NAME="pgfId=176208">
 </A>Note that many structs may share the same super struct.  Thus a single read-only super struct can be used hold initial values; saving explicit initialisations and storage space.</P>
<P CLASS="Body">
<A NAME="pgfId=176209">
 </A>The function assign may be used to set a value in a struct explicitly, without reference to any super structs; and the function fetch may be used to read a value from a struct explicitly, without reference to any super structs.</P>
<P CLASS="Body">
<A NAME="pgfId=176210">
 </A>Within a struct-literal a colon prefixed expression after the struct identifier is used as the super struct.  For example, the declarations used in the previous example could be written as:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=176211"></A>static theSuper = [struct a = 1, b = 2, c = 3];
static theStruct = [struct:theSuper, x = 100, y = 200];</PRE>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=176212">
 </A>An aside on variables and scope</H4>
<P CLASS="Body">
<A NAME="pgfId=176213">
 </A>Now that structs and their super have been described a more precise statement about variables and scope can be made.</P>
<P CLASS="Body">
<A NAME="pgfId=176214">
 </A>ICI variables are entries in ordinary structs.  At all times, the current scope is identified by a structure.  The auto variables are the entries in this base structure.  Its super is the struct containing the static variables.  The next super struct contains the externs, and successive super structs are successive outer scopes.</P>
<P CLASS="Body">
<A NAME="pgfId=176215">
 </A>Auto, static and extern declarations make explicit assignments to the appropriate structure.</P>
<P CLASS="Body">
<A NAME="pgfId=176216">
 </A>In these terms it can be said that an un-adorned identifier in an expression is an implicit reference to an element of the current scope structure.  The inheritance and name hiding of the variable scope mechanism is a product of the super chain. But there is a difference in the handling of undefined entries. Whereas normal lookup of undefined entries in a structure produces a default value of NULL or implicit creation, the implicit lookup of undefined variables triggers an attempt to dynamically load a library to define the variable (see Undefined variables and dynamic loading below), and failing that, produce an error (&quot;%s undefined&quot;).</P>
<P CLASS="Body">
<A NAME="pgfId=176217">
 </A>The function scope can be used to obtain the current scope structure; and to set it (use with care).</P>
<P CLASS="Body">
<A NAME="pgfId=176218">
 </A>Note that when there is an atomic structure in the scope chain the mechanism described at the end of the previous section does not operate correctly.  Writing to a variable in the atomic struct will give a spurious undefined error rather than lodging it in the base structure.  This is a deficiency which will be corrected in a later release.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=176219">
 </A>Pointers</H4>
<P CLASS="Body">
<A NAME="pgfId=176220">
 </A>Pointers are references to storage locations.  Storage locations are the elements of anything which can be indexed.  That is, array elements, set elements, struct elements and others (which we will see below) can be pointed to.  Variables (which are just struct elements) can be pointed to.  In more general terms, any lvalue can be pointed to.</P>
<P CLASS="Body">
<A NAME="pgfId=176221">
 </A>The &amp; operator is used to obtain a pointer to a location.  Thus if the following were executed:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=176222"></A>static x;
static y = [array 1, 2, 3];
static p1 = &amp;x;
static p2 = &amp;y[1];</PRE>
<P CLASS="Body">
<A NAME="pgfId=175574">
 </A>The variable p1 would be a pointer to x and the variables p2 would be a pointer to the second element of y.  Reference to the object a pointer points to can be obtained with the * operator.  Thus if the following were executed:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=176223"></A>*p1 = 123;
*p2 = 456;
printf(&quot;x = %d, y[1] = %d\n&quot;, x, y[1]);</PRE>
<P CLASS="Body">
<A NAME="pgfId=176224">
 </A>the output would be:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=176225"></A>x = 123, y[1] = 456</PRE>
<P CLASS="Body">
<A NAME="pgfId=176226">
 </A>Pointers are really a bundle of two objects, one is the object pointed into, the other is the key used to access the location in question.  For instance, in the example above p2 remembers the array, and the number 1; that is, the aggregate and the index.  The generation of a pointer does not affect the location being pointed to.  In fact the location may not even exist yet.  When a pointer is referenced the same operation takes place as if the location was referenced explicitly.  Thus a search down the super chain of a struct may occur, or an array may be extended to include the index being written to, etc.</P>
<P CLASS="Body">
<A NAME="pgfId=176227">
 </A>In addition to simple indirection (that is the * operator), pointers may be indexed. But the index values must be an integer, and the key stored as part of the pointer must also be an integer.  When a pointer is indexed, the index is added to the key which is stored as part of the pointer, the sum forms the actual index to use to when referencing the aggregate recorded by the pointer.  For instance, continuing the example above:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=176228"></A>p2[1] = 789;</PRE>
<P CLASS="Body">
<A NAME="pgfId=176229">
 </A>would set the last element of the array to 789, because the pointer currently references element 1, and the given index is 1, and 1 + 1 is 2 which is the last element.  The index arithmetic provided by pointers will work with any types, as long as the indexes are integers, thus:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=176230"></A>static s = [struct (20) = 1, (30) = 2, (40) = 3];
static p = &amp;s[30];

p[-10] = -1;
p[0] = -2;
p[10] = -3;</PRE>
<P CLASS="Body">
<A NAME="pgfId=176231">
 </A>Would replace each of the elements in the struct s by their negative value.</P>
<P CLASS="Body">
<A NAME="pgfId=176232">
 </A>This concludes the general discussion of ICI as a whole.  We will now examine the exact nature of each of the data types, then each of the expression operators, and finally each of the standard functions.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=176233">
 </A>Data types</H4>
<P CLASS="Body">
<A NAME="pgfId=176234">
 </A>ICI supports a base set of standard data types.  Each is identified by a simple name.  In summary these are:</P>
<P CLASS="Untitled">
<A NAME="pgfId=176235">
 </A>	array	An ordered sequence of other objects.</P>
<P CLASS="Untitled">
<A NAME="pgfId=176236">
 </A>	file	An open file reference.</P>
<P CLASS="Untitled">
<A NAME="pgfId=176237">
 </A>	float	A double precision floating point number.</P>
<P CLASS="Untitled">
<A NAME="pgfId=176238">
 </A>	func	A function.</P>
<P CLASS="Untitled">
<A NAME="pgfId=176239">
 </A>	int	A signed 32 bit integer.</P>
<P CLASS="Untitled">
<A NAME="pgfId=176240">
 </A>	mem	References to raw machine memory.</P>
<P CLASS="Untitled">
<A NAME="pgfId=176241">
 </A>	ptr	A reference to a storage location.</P>
<P CLASS="Untitled">
<A NAME="pgfId=176242">
 </A>	regexp	A compiled regular expression.</P>
<P CLASS="Untitled">
<A NAME="pgfId=176243">
 </A>	set	An unordered collection of other objects.</P>
<P CLASS="Untitled">
<A NAME="pgfId=176244">
 </A>	string	An ordered sequence of 8 bit characters.</P>
<P CLASS="Untitled">
<A NAME="pgfId=176245">
 </A>	struct	An unordered set of pairs of objects.</P>
<P CLASS="Untitled">
<A NAME="pgfId=176246">
 </A>&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId=176247">
 </A>A full explanation of the semantics of each type (including the semantics of indexing an object of that type) will be included in a future version of this document.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=176248">
 </A>Operators</H4>
<P CLASS="Body">
<A NAME="pgfId=176249">
 </A>The following table details each of the unary and binary operators with all of the types they may be applied to. Within the first column the standard type names are used to stand for operands of that type, along with any to mean any type and num to mean an int or a float. In general, where an int and a float are combined in an arithmetic operation, the int is first converted to a float and then the operation is performed.</P>
<P CLASS="Body">
<A NAME="pgfId=176250">
 </A>The following table is in precedence order.</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176251">
 </A><CODE CLASS="CourierBold">
*</CODE>
ptr	Indirection: The result references the thing the pointer points to. The result is an lvalue.</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176252">
 </A><CODE CLASS="CourierBold">
&amp;</CODE>
any	Address of: The result is a pointer to any. If any is an lvalue the pointer references that storage location.  If any is not an lvalue but is a term other than a bracketed non-term, as described in the syntax above, a one element array containing any  will be fabricated and a pointer to that storage location returned. For example:</P>
<PRE CLASS="CodeIn4cm"><A NAME="pgfId=176253"></A>		p = &amp;1;</PRE>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176254">
 </A>	sets p to be a pointer to the first element of an un-named array, which currently contains the number 1.</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176255">
 </A><CODE CLASS="CourierBold">
-</CODE>
num	Negation: Returns the negation of num. The result is the same type as the argument. The result is not an lvalue.</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176256">
 </A><CODE CLASS="CourierBold">
+</CODE>
any	Has no effect except the result is not an lvalue.</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176257">
 </A><CODE CLASS="CourierBold">
!</CODE>
any	Logical negation: If any is 0 (integer) or NULL, 1 is returned, else 0 is returned.</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176258">
 </A><CODE CLASS="CourierBold">
~</CODE>
int	Bit-wise complement: The bit-wise complement of int is returned.</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176259">
 </A><CODE CLASS="CourierBold">
++</CODE>
any	Pre-increment: Equivalent to <CODE CLASS="CourierBold">
(</CODE>
any <CODE CLASS="CourierBold">
+= 1)</CODE>
. any must be an lvalue and obey the restrictions of the binary <CODE CLASS="CourierBold">
+</CODE>
 operator.  See <CODE CLASS="CourierBold">
+</CODE>
 below.</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176260">
 </A><CODE CLASS="CourierBold">
--</CODE>
any	Pre-decrement: Equivalent to <CODE CLASS="CourierBold">
(</CODE>
any <CODE CLASS="CourierBold">
-= 1)</CODE>
. any must be an lvalue and obey the restrictions of the binary <CODE CLASS="CourierBold">
-</CODE>
 operator.  See <CODE CLASS="CourierBold">
-</CODE>
 below.</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176261">
 </A><CODE CLASS="CourierBold">
@</CODE>
any	Atomic form of: Returns the unique, read-only form of any.  If any is already atomic, it is returned immediately.  Otherwise an atomic form of any is found or generated and returned; this is of execution time order equal to the number of elements in any.  See the section on objects above for more explanation.</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176262">
 </A><CODE CLASS="CourierBold">
$</CODE>
any	Immediate evaluation: Recognised by the parser.  The sub-expression any is immediately evaluated by invocation of the execution engine.  The result of the evaluation is substituted directly for this expression term by the parser.</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176263">
 </A><I CLASS="+Italic">
any</I>
++	Post-increment: Notes the value of any, then performs the equivalent of (<I CLASS="+Italic">
any</I>
 += 1), except any is only evaluated once, and finally returns the original noted value.  any must be an lvalue and obey the restrictions of the binary + operator.  See + below.</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176264">
 </A><I CLASS="+Italic">
any</I>
--	Post-increment: Notes the value of any, then performs the equivalent of (<I CLASS="+Italic">
any</I>
 -= 1), except any is only evaluated once, and finally returns the original noted value.  any must be an lvalue and obey the restrictions of the binary - operator.  See - below.</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176265">
 </A><I CLASS="+Italic">
any1 @ any2	Form pointer: Returns a pointer object formed from its operands with the pointer's aggregate being set from any1 and the pointer's key from any2.</I>
</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=180368">
 </A><I CLASS="+Italic">
num1</I>
 * <I CLASS="+Italic">
num2</I>
	Multiplication: Returns the product of the two numbers, if both nums are ints, the result is int, else the result is float.</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176266">
 </A><I CLASS="+Italic">
set1</I>
 * <I CLASS="+Italic">
set2</I>
	Set intersection: Returns a set that contains all elements that appear in both <I CLASS="+Italic">
set1</I>
 and <I CLASS="+Italic">
set2</I>
.</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176267">
 </A><I CLASS="+Italic">
num1</I>
 / <I CLASS="+Italic">
num2</I>
	Division: Returns the result of dividing <I CLASS="+Italic">
num1</I>
 by <I CLASS="+Italic">
num2</I>
.  If both numbers are ints the result is int, else the result is float.  If <I CLASS="+Italic">
num2</I>
 is zero the error <I CLASS="+Italic">
division by 0</I>
 is generated, or <I CLASS="+Italic">
division by 0.0</I>
 if the result would have been a float.</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176268">
 </A><I CLASS="+Italic">
int1</I>
 % <I CLASS="+Italic">
int2</I>
	Modulus: Returns the remainder of dividing <I CLASS="+Italic">
int1</I>
 by <I CLASS="+Italic">
int2</I>
.  If <I CLASS="+Italic">
int2</I>
 is zero the error <I CLASS="+Italic">
modulus by 0</I>
 is generated.</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176269">
 </A><I CLASS="+Italic">
num1</I>
 <CODE CLASS="CourierBold">
+</CODE>
 <I CLASS="+Italic">
num2</I>
	Addition: Returns the sum of <I CLASS="+Italic">
num1</I>
 and <I CLASS="+Italic">
num2</I>
.  If both numbers are <I CLASS="+Italic">
ints</I>
 the result is <I CLASS="+Italic">
int</I>
, else the result is <I CLASS="+Italic">
float</I>
.</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176270">
 </A><I CLASS="+Italic">
ptr</I>
 + <I CLASS="+Italic">
int</I>
	Pointer addition: <I CLASS="+Italic">
ptr</I>
 must point to an element of an indexable object whose index is an <I CLASS="+Italic">
int</I>
.  Returns a new pointer which points to an element of the same aggregate which has the index which is the sum of <I CLASS="+Italic">
ptr</I>
's index and <I CLASS="+Italic">
int</I>
.  The arguments may be in any order.</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176271">
 </A><I CLASS="+Italic">
string1</I>
 + <I CLASS="+Italic">
string2</I>
	String concatenation: Returns the string which is the concatenation of the characters of <I CLASS="+Italic">
string1</I>
 then <I CLASS="+Italic">
string2</I>
.  The execution time order is  proportional to the total length of the result.</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176272">
 </A><I CLASS="+Italic">
array1</I>
 + <I CLASS="+Italic">
array2</I>
	Array concatenation: Returns a new array which is the concatenation of the elements from <I CLASS="+Italic">
array1</I>
 then <I CLASS="+Italic">
array2</I>
.  The execution time order is  proportional to the total length of the result. Note the difference between the following:</P>
<PRE CLASS="CodeIn4cm"><A NAME="pgfId=176273"></A>		a += [array 1];
		push(a, 1);</PRE>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176274">
 </A>	In the first case a is replaced by a newly formed array which is the original array with one element added.  But in the second case the push function (see below) appends an element to the array a refers to, without making a new array. The second case is much faster, but modifies an existing array.</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176275">
 </A><I CLASS="+Italic">
struct1</I>
 + <I CLASS="+Italic">
struct2</I>
	Structure concatenation: Returns a new struct which is a copy of <I CLASS="+Italic">
struct1</I>
, with all the elements of <I CLASS="+Italic">
struct2</I>
 assigned into it.  Obeys the semantics of copying and assignment discussed in other sections with regard to super structs..  The execution time order is  proportional to the sum of the lengths of the two arguments.</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176276">
 </A><I CLASS="+Italic">
set1</I>
 + <I CLASS="+Italic">
set2</I>
	Set union: Returns a new set which contains all the elements from both sets.  The execution time order is  proportional to the sum of the lengths of the two arguments.</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176277">
 </A><I CLASS="+Italic">
num1</I>
 - <I CLASS="+Italic">
num2</I>
	Subtraction: Returns the result of subtracting <I CLASS="+Italic">
num2</I>
 from <I CLASS="+Italic">
num1</I>
.  If both numbers are ints the result is <I CLASS="+Italic">
int</I>
, else the result is <I CLASS="+Italic">
float</I>
.</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176278">
 </A><I CLASS="+Italic">
set1</I>
 - <I CLASS="+Italic">
set2</I>
	Set subtraction: Returns a new set which contains all the elements of <I CLASS="+Italic">
set1</I>
, less the elements of <I CLASS="+Italic">
set2</I>
. The execution time order is  proportional to the sum of the lengths of the two arguments.</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176279">
 </A><I CLASS="+Italic">
ptr1</I>
 - <I CLASS="+Italic">
ptr2</I>
	Pointer subtraction: <I CLASS="+Italic">
ptr1</I>
 and <I CLASS="+Italic">
ptr2</I>
 must point to elements of indexable objects whose indexs are <I CLASS="+Italic">
ints</I>
.  Returns an <I CLASS="+Italic">
int</I>
 which is the the index of <I CLASS="+Italic">
ptr1</I>
 less the index of <I CLASS="+Italic">
ptr2</I>
.</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176280">
 </A><I CLASS="+Italic">
int1</I>
 &gt;&gt; <I CLASS="+Italic">
int2</I>
	Right shift: Returns the result of right shifting <I CLASS="+Italic">
int1</I>
 by <I CLASS="+Italic">
int2</I>
.  Equivalent to division by 2**<I CLASS="+Italic">
int2</I>
.  <I CLASS="+Italic">
int1</I>
 is interpreted as a signed quantity.</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176281">
 </A><I CLASS="+Italic">
int1</I>
 &lt;&lt; <I CLASS="+Italic">
int2</I>
	Left shift: Returns the result of left shifting <I CLASS="+Italic">
int1</I>
 by <I CLASS="+Italic">
int2</I>
.  Equivalent to multiplication by 2**<I CLASS="+Italic">
int2</I>
.</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176282">
 </A><I CLASS="+Italic">
array</I>
 &lt;&lt; <I CLASS="+Italic">
int</I>
	Left shift array: Returns a new array which contains the elements of <I CLASS="+Italic">
array</I>
 from index <I CLASS="+Italic">
int</I>
 onwards.  Equivalent to the function call <I CLASS="+Italic">
interval(array, int)</I>
 (which is considered preferable, this operator may disappear in future releases).</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176283">
 </A><I CLASS="+Italic">
num1</I>
 &lt; <I CLASS="+Italic">
num2</I>
	Numeric test for less than: Returns 1 if <I CLASS="+Italic">
num1</I>
 is less than <I CLASS="+Italic">
num2</I>
, else 0.</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176284">
 </A><I CLASS="+Italic">
set1</I>
 &lt; <I CLASS="+Italic">
set2</I>
	Test for subset: Returns 1 if <I CLASS="+Italic">
set1</I>
 contains only elements that are in <I CLASS="+Italic">
set2</I>
, else 0.</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176285">
 </A><I CLASS="+Italic">
string1</I>
 &lt; <I CLASS="+Italic">
string2</I>
	Lexical test for less than: Returns 1 if <I CLASS="+Italic">
string1</I>
 is lexically less than <I CLASS="+Italic">
string2</I>
, else 0.</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176286">
 </A><I CLASS="+Italic">
ptr1</I>
 &lt; <I CLASS="+Italic">
ptr2</I>
	Pointer test for less than:  <I CLASS="+Italic">
ptr1</I>
 and <I CLASS="+Italic">
ptr2</I>
 must point to elements of indexable objects whose indexes are <I CLASS="+Italic">
ints</I>
.  Returns 1 if <I CLASS="+Italic">
ptr1</I>
 points to an element with a lesser index than <I CLASS="+Italic">
ptr2</I>
, else 0.</P>
<P CLASS="Body">
<A NAME="pgfId=176287">
 </A>The &gt;, &lt;= and &gt;= operators work in the same fashion as &lt;, above. For sets &gt; tests for one set being a superset of the other. The &lt;= and &gt;= operators test for proper sub- or super-sets. That is one set can contain only those elements contained in the other set but cannot be equal to the other set.</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176288">
 </A><I CLASS="+Italic">
any1</I>
 == <I CLASS="+Italic">
any2</I>
	Equality test: Returns 1 if <I CLASS="+Italic">
any1</I>
 is equal to <I CLASS="+Italic">
any2</I>
, else 0.  Two objects are equal when: they are the same object; or they are both arithmetic (<I CLASS="+Italic">
int</I>
 and <I CLASS="+Italic">
float</I>
) and have equivalent numeric values; or they are aggregates of the same type and all the sub-elements are the same objects.</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176289">
 </A><I CLASS="+Italic">
any1</I>
 != <I CLASS="+Italic">
any2</I>
	Inequality test: Returns 1 if <I CLASS="+Italic">
any1</I>
 is not equal to <I CLASS="+Italic">
any2</I>
, else 0.  See above.</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176290">
 </A><I CLASS="+Italic">
string</I>
 ~ <I CLASS="+Italic">
regexp</I>
	Logical test for regular expression match: Returns 1 if <I CLASS="+Italic">
string</I>
 can be matched by <I CLASS="+Italic">
regexp</I>
, else 0.  The arguments may be in any order.</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176291">
 </A><I CLASS="+Italic">
string</I>
 !~ <I CLASS="+Italic">
regexp</I>
	Logical test for regular expression non-match: Returns 1 if <I CLASS="+Italic">
string</I>
 can not be matched by <I CLASS="+Italic">
regexp</I>
, else 0.  The arguments may be in any order.</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176292">
 </A><I CLASS="+Italic">
string</I>
 ~~ <I CLASS="+Italic">
regexp</I>
	Regular expression sub-string extraction: Returns the sub-string of <I CLASS="+Italic">
string</I>
 which is matched by the first bracket enclosed portion of <I CLASS="+Italic">
regexp</I>
, or NULL if there is no match or <I CLASS="+Italic">
regexp</I>
 does not contain a (...) portion. The arguments may be in any order.  For example, a &quot;basename&quot; operation can be performed with:</P>
<PRE CLASS="CodeIn4cm"><A NAME="pgfId=176293"></A>		argv[0] ~~= #([^/]*)$#;</PRE>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176294">
 </A><I CLASS="+Italic">
string</I>
 ~~~ <I CLASS="+Italic">
regexp</I>
	Regular expression multiple sub-string extraction: Returns an array of the the sub-strings of <I CLASS="+Italic">
string</I>
 which are matched by the (...) enclosed portions of <I CLASS="+Italic">
regexp</I>
, or NULL if there is no match. The arguments may be in any order.</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176295">
 </A><I CLASS="+Italic">
int1</I>
 &amp; <I CLASS="+Italic">
int2</I>
	Bit-wise and: Returns the bit-wise and of <I CLASS="+Italic">
int1</I>
 and <I CLASS="+Italic">
int2</I>
.</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176296">
 </A><I CLASS="+Italic">
int1</I>
 ^ <I CLASS="+Italic">
int2</I>
	Bit-exclusive or: Returns the bit-wise exclusive or of <I CLASS="+Italic">
int1</I>
 and <I CLASS="+Italic">
int2</I>
.</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176297">
 </A><I CLASS="+Italic">
int1</I>
 | <I CLASS="+Italic">
int2</I>
	Bit-wise or: Returns the bit-wise or of <I CLASS="+Italic">
int1</I>
 and <I CLASS="+Italic">
int2</I>
.</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176298">
 </A><I CLASS="+Italic">
any1</I>
 &amp;&amp; <I CLASS="+Italic">
any2</I>
	Logical and: Evaluates the expression which determines <I CLASS="+Italic">
any1</I>
, if this evaluates to 0 or NULL (i.e. <I CLASS="+Italic">
false</I>
), 0 is returned, else <I CLASS="+Italic">
any2</I>
 is evaluated and returned<A HREF="#pgfId=175522" CLASS="footnote">
5</A>. Note that if <I CLASS="+Italic">
any1</I>
 does not evaluate to a <I CLASS="+Italic">
true</I>
 value, the expression which determines <I CLASS="+Italic">
any2</I>
 is never evaluated.</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176299">
 </A><I CLASS="+Italic">
any1</I>
 || <I CLASS="+Italic">
any2</I>
	Logical or: Evaluates the expression which determines <I CLASS="+Italic">
any1</I>
, if this evaluates to other than 0 or NULL (i.e. <I CLASS="+Italic">
true</I>
), 1 is returned, else <I CLASS="+Italic">
any2</I>
 is evaluated and returned. Note that if <I CLASS="+Italic">
any1</I>
 does not evaluate to a <I CLASS="+Italic">
false</I>
 value, the expression which determines <I CLASS="+Italic">
any2</I>
 is never evaluated.</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176125">
 </A><I CLASS="+Italic">
any1</I>
 ? <I CLASS="+Italic">
any2</I>
 : <I CLASS="+Italic">
any3</I>
 	Choice: If <I CLASS="+Italic">
any1</I>
 is neither 0 or NULL (i.e. <I CLASS="+Italic">
true</I>
), the expression which determines  <I CLASS="+Italic">
any2</I>
 is evaluated and returned, else the expression which determines <I CLASS="+Italic">
any3</I>
 is evaluated and returned.  Only one of <I CLASS="+Italic">
any2</I>
 and <I CLASS="+Italic">
any3</I>
 are evaluated.  The result may be an lvalue if the returned expression is.  Thus:</P>
<PRE CLASS="CodeIn4cm"><A NAME="pgfId=176126"></A>		flag ? a : b = value</PRE>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176300">
 </A>	is a legal expression and will assign value to either a or b depending on the state of flag.</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176301">
 </A><I CLASS="+Italic">
any1</I>
 = <I CLASS="+Italic">
any2</I>
	Assignment: Assigns <I CLASS="+Italic">
any2</I>
 to <I CLASS="+Italic">
any1</I>
.  <I CLASS="+Italic">
any1</I>
 must be an lvalue. The behavior of assignment is a consequence of aggregate access as discussed in earlier sections.  In short, an lvalue (in this case <I CLASS="+Italic">
any1</I>
) can always be resolved into an aggregate and an index into the aggregate.  Assignment sets the element of the aggregate identified by the index to <I CLASS="+Italic">
any2</I>
.  The returned result of the whole assignment is <I CLASS="+Italic">
any1</I>
, after the assignment has been performed.</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176302">
 </A>	The result is an lvalue, thus:</P>
<PRE CLASS="CodeIn4cm"><A NAME="pgfId=176303"></A>		++(a = b)</PRE>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176304">
 </A>	will assign b to a and then increment a by 1.</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176305">
 </A>	Note that assignment operators (this and following ones) associate right to left, unlike all other binary operators, thus:</P>
<PRE CLASS="CodeIn4cm"><A NAME="pgfId=176306"></A>		a = b += c -= d</PRE>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176307">
 </A>	Will subtract d from c, then add the result to b, then assign the final value to a.</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176308">
 </A><CODE CLASS="CourierBold">
+= -= *= /= %= &gt;&gt;= &lt;&lt;= &amp;= ^= |= ~~=</CODE>
</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176309">
 </A>	Compound assignments: All these operators are defined by the re-writing rule:</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176310">
 </A>		any1 op= any2</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176311">
 </A>	is equivalent to:</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176312">
 </A>		any1 = any1 op any2</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176313">
 </A>	except that any1 is not evaluated twice. Type restrictions and the behavior or op will follow the rules given with that binary operator above. The result will be an lvalue (as a consequence of = above).  There are no further restrictions.  Thus:</P>
<PRE CLASS="CodeIn4cm"><A NAME="pgfId=176314"></A>		a = &quot;Hello&quot;;
		a += &quot; world.\n&quot;;</PRE>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176315">
 </A>	will result in the variable a referring to the string:</P>
<PRE CLASS="CodeIn4cm"><A NAME="pgfId=176316"></A>		&quot;Hello world.\n&quot;.</PRE>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176317">
 </A><I CLASS="+Italic">
any1</I>
 &lt;=&gt; <I CLASS="+Italic">
any2</I>
	Swap: Swaps the current values of <I CLASS="+Italic">
any1</I>
 and <I CLASS="+Italic">
any2</I>
. Both operands must be lvalues. The result is <I CLASS="+Italic">
any1</I>
 after the swap and is an lvalue, as in other assignment operators.  Also like other assignment operators, associativity is right to left, thus:</P>
<PRE CLASS="CodeIn4cm"><A NAME="pgfId=176318"></A>		a &lt;=&gt; b &lt;=&gt; c &lt;=&gt; d</PRE>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176319">
 </A>	rotates the values of a, b and c towards d and brings d's original value back to a.</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=176320">
 </A><I CLASS="+Italic">
any1</I>
 , <I CLASS="+Italic">
any2</I>
	Sequential evaluation: Evaluates <I CLASS="+Italic">
any1</I>
, then <I CLASS="+Italic">
any2</I>
. The result is <I CLASS="+Italic">
any2</I>
 and is an lvalue if <I CLASS="+Italic">
any2</I>
 is. Note that in situations where comma has meaning at the top level of parsing an  expression (such as in function call arguments), expression parsing precedence starts at one level below the comma, and a comma will not be recognised as an operator.  Surround the expression with brackets to avoid this if necessary.</P>
</DIV>
</DIV>
<DIV>
<H3 CLASS="Heading1">
<A NAME="pgfId=176321">
 </A>Core language functions</H3>
<P CLASS="Body">
<A NAME="pgfId=176322">
 </A>The following list summarises the standard functions.  Following this is a detailed descriptions of each of them.</P>
<P CLASS="Untitled">
<A NAME="pgfId=176323">
 </A>&nbsp;</P>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233750"></A>float|int = </PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233753"></A><A HREF="ici.html#abs" CLASS="Hypertext">abs</A>(float|int)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233755"></A>float =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233757"></A><A HREF="ici.html#acos" CLASS="Hypertext">acos</A>(number)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233759"></A>mem =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233761"></A><A HREF="ici.html#alloc" CLASS="Hypertext">alloc</A>(int [, int])</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233763"></A>array =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233766"></A><A HREF="ici.html#array" CLASS="Hypertext">array</A>(any...)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233768"></A>float =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233770"></A><A HREF="ici.html#asin" CLASS="Hypertext">asin</A>(number)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233772"></A>any =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233774"></A><A HREF="ici.html#assign" CLASS="Hypertext">assign</A>(struct, any, any)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233776"></A>float =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233778"></A><A HREF="ici.html#atan" CLASS="Hypertext">atan</A>(number)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233780"></A>float =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233782"></A><A HREF="ici.html#atan2" CLASS="Hypertext">atan2</A>(number, number)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233784"></A>any =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233786"></A><A HREF="ici.html#call" CLASS="Hypertext">call</A>(func, array)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233788"></A>float =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233790"></A>ceil(number)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233792"></A>&nbsp;</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233794"></A>close(file)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233796"></A>any =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233798"></A><A HREF="ici.html#copy" CLASS="Hypertext">copy</A>(any)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233800"></A>float =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233802"></A><A HREF="ici.html#cos" CLASS="Hypertext">cos</A>(number)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233804"></A>file =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233806"></A><A HREF="ici.html#currentfile" CLASS="Hypertext">currentfile</A>()</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233808"></A>&nbsp;</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233810"></A><A HREF="ici.html#del" CLASS="Hypertext">del</A>(struct, any)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233812"></A>int =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233814"></A><A HREF="ici.html#eq" CLASS="Hypertext">eq</A>(any, any)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233816"></A>int =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233818"></A><A HREF="ici.html#eof" CLASS="Hypertext">eof</A>(file)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233820"></A>&nbsp;</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233822"></A><A HREF="ici.html#eventloop" CLASS="Hypertext">eventloop</A>()</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233824"></A>&nbsp;</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233826"></A><A HREF="ici.html#exit" CLASS="Hypertext">exit</A>([int|string|NULL])</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233828"></A>float =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233830"></A>exp(number)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233832"></A>array =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233834"></A>explode(string)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233836"></A>&nbsp;</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233838"></A>fail(string)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233840"></A>any =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233842"></A>fetch(struct, any)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233844"></A>float =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233846"></A>float(any)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233848"></A>float =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233850"></A>floor(number)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233852"></A>int =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233854"></A>flush(file)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233856"></A>float =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233858"></A>fmod(number, number)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233860"></A>file =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233862"></A>fopen(string [, string])</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233864"></A>&nbsp;</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233866"></A>flush([file])</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233868"></A>string =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233870"></A>getchar([file])</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233872"></A>string =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233874"></A>getfile([file])</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233876"></A>string =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233878"></A>getline([file])</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233880"></A>string =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233882"></A>getenv(string)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233884"></A>string =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233886"></A>gettoken([file|string [,string]])</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233888"></A>array =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233890"></A>gettokens([file|string [,string [,string]]])</PRE>
<PRE CLASS="Preformatted"><A NAME="pgfId=233891"></A>&nbsp;</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233893"></A>string =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233895"></A>gsub(string, regexp, string)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233897"></A>string =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233899"></A>implode(array)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233901"></A>struct =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233903"></A>include(string [, struct])</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233905"></A>int =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233907"></A>int(any)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233909"></A>string|array =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233911"></A>interval(string|array, int [, int])</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233913"></A>int =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233915"></A>isatom(any)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233917"></A>array =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233919"></A>keys(struct)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233921"></A>float =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233923"></A>log(number)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233925"></A>float =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233927"></A>log10(number)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233929"></A>mem =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233931"></A>mem(int, int [,int])</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233933"></A>file =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233935"></A>mopen(string [, string])</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233937"></A>int =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233939"></A>nels(any)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233941"></A>int|float =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233943"></A>num(string|int|float)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233945"></A>struct =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233947"></A>parse(file|string [, struct])</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233949"></A>any =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233951"></A>pop(array)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233953"></A>file =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233955"></A>popen(string [, string])</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233957"></A>float =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233959"></A>pow(number, number)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233961"></A>&nbsp;</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233963"></A>printf([file,] string [, any...])</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233965"></A>any =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233967"></A>push(array, any)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233969"></A>&nbsp;</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233971"></A>put(string)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233973"></A>&nbsp;</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233975"></A>putenv(string [, string])</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233977"></A>int =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233979"></A>rand([int])</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233981"></A>&nbsp;</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233983"></A>reclaim()</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233985"></A>regexp =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233987"></A>regexp(string)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233989"></A>regexp =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233991"></A>regexpi(string)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233993"></A>&nbsp;</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233995"></A>remove(string)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=233997"></A>struct =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=233999"></A>scope([struct])</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=234001"></A>int =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=234003"></A>seek(file, int, int)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=234005"></A>set =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=234007"></A>set(any...)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=234009"></A>float =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=234011"></A>sin(number)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=234013"></A>int =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=234015"></A>sizeof(any)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=234017"></A>array =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=234019"></A>smash(string, string)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=234021"></A>file =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=234023"></A>sopen(string [, string])</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=234025"></A>&nbsp;</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=234027"></A>sort(array, func)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=234029"></A>string =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=234031"></A>sprintf(string [, any...])</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=234033"></A>float =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=234035"></A>sqrt(number)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=234037"></A>string =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=234039"></A>string(any)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=234041"></A>struct =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=234043"></A>struct(any, any...)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=234045"></A>string =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=234047"></A>sub(string, regexp, string)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=234049"></A>struct =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=234051"></A>super(struct [, struct])</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=234053"></A>int =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=234055"></A>system(string)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=234057"></A>float =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=234059"></A>tan(number)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=234061"></A>string =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=234063"></A>tochar(int)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=234065"></A>int =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=234067"></A>toint(string)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=234069"></A>any =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=234071"></A>top(array [, int])</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=234073"></A>int =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=234075"></A>trace(string)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=234077"></A>string =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=234079"></A>typeof(any)</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=234081"></A>array =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=234083"></A>vstack()</PRE>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="PreformattedRAlign"><A NAME="pgfId=234085"></A>file|int|float =</PRE>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<PRE CLASS="Preformatted"><A NAME="pgfId=234087"></A>waitfor(file|int|float...)</PRE>
</TD>
</TR>
</TABLE>
<P CLASS="Untitled">
<A NAME="pgfId=176128">
 </A>&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId=176398">
 </A>The following is an alphabetic listing of each of the standard functions.  <CODE CLASS="CourierBold">
</CODE>
</P>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=182157">
 </A><CODE CLASS="+Code">
float|int = abs(float|int)</CODE>
<A NAME="abs">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=182158">
 </A>Returns the absolute value of its argument. The result is an int if the argument is an int, a float if it is a float.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=176399">
 </A><CODE CLASS="+Code">
angle = acos(x)</CODE>
<A NAME="acos">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=176400">
 </A>Returns the arc cosine of x in the range 0 to pi.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=176401">
 </A><CODE CLASS="+Code">
mem = alloc(nwords [, wordz])</CODE>
<A NAME="alloc">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=176402">
 </A>Returns a new mem object referring to nwords (an int) of newly allocated and cleared memory.  Each word is either 1, 2, or 4 bytes as specified by wordz  (an int, default 1). Indexing of mem objects performs the obvious operations, and thus pointers work too.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=176403">
 </A><CODE CLASS="+Code">
array = array(any...)</CODE>
<A NAME="array">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=176404">
 </A>Returns an array formed from all the arguments. For example:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=176405"></A>array()</PRE>
<P CLASS="Body">
<A NAME="pgfId=176406">
 </A>will return a new empty array; and</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=176407"></A>array(1, 2, &quot;a string&quot;)</PRE>
<P CLASS="Body">
<A NAME="pgfId=176408">
 </A>will return a new array with three elements, 1, 2, and &quot;the string&quot;.</P>
<P CLASS="Body">
<A NAME="pgfId=176409">
 </A>This is the run-time equivalent of the array literal. Thus the following two expressions are equivalent:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=176410"></A>$array(1, 2, &quot;a string&quot;)</PRE>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=176411"></A>[array 1, 2, &quot;a string&quot;]</PRE>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=176412">
 </A><CODE CLASS="+Code">
float = asin(x)</CODE>
<A NAME="asin">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=176413">
 </A>Returns the arc sine of x  in the range -pi/2 to pi/2.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=176414">
 </A><CODE CLASS="+Code">
value = assign(struct, key, value)</CODE>
<A NAME="assign">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=175576">
 </A>Sets the element of struct identified by key to value, ignoring any super struct.  Returns value.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175610">
 </A><CODE CLASS="+Code">
angle = atan(x)</CODE>
<A NAME="atan">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=175611">
 </A>Returns the arc tangent of x  in the range -pi/2 to pi/2.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175612">
 </A><CODE CLASS="+Code">
angle = atan2(y, x)</CODE>
<A NAME="atan2">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=175613">
 </A>Returns the angle from the origin to the rectangular coordinates x, y (floats ) in the range -pi to pi.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175614">
 </A><CODE CLASS="+Code">
return = call(func, args)</CODE>
<A NAME="call">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=175616">
 </A>Calls the function func with arguments taken from the array args.  Returns the return value of the function.</P>
<P CLASS="Body">
<A NAME="pgfId=175619">
 </A>This is often used to pass on an unknown argument list.  For example:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175620"></A>static
db()
{
	auto vargs;

	if (debug)
		return call(printf, vargs);
}</PRE>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175621">
 </A><CODE CLASS="+Code">
new = copy(old)</CODE>
<A NAME="copy">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=175624">
 </A>Returns a copy of old.  If old is an intrinsically atomic type such as an int or string, the new will be the same object as the old.  But if old is an array, set, or struct, a copy will be returned.  The copy will be a new non-atomic object (even if old was atomic) which will contain exactly the same objects as old and will be equal to it (that is ==).  If old is a struct with a super struct, new will have the same super (exactly the same super, not a copy of it).</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175627">
 </A><CODE CLASS="+Code">
x = cos(angle)</CODE>
<A NAME="cos">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=175630">
 </A>Returns the cosine of angle (a float interpreted in radians).</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175632">
 </A><CODE CLASS="+Code">
file = currentfile()</CODE>
<A NAME="currentfile">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=175633">
 </A>Returns the file associated with the innermost parsing context, or NULL if there is no module being parsed.</P>
<P CLASS="Body">
<A NAME="pgfId=175634">
 </A>This function can be used to include data in a program source file which is out-of-band with respect to the normal parse stream.  But to do this it is necessary to know up to what character in the file in question the parser has consumed.</P>
<P CLASS="Body">
<A NAME="pgfId=175637">
 </A>In general: after having parsed any simple statement the parser will have consumed up to and including the terminating semicolon, and no more.  Also, after having parsed a compound statement the parser will have consumed up to and including the terminating close brace and no more.  For example:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175640"></A>static help = gettokens(currentfile(), &quot;&quot;, &quot;!&quot;)[0]

;This is the text of the help message.
It follows exactly after the ; because
that is exactly up to where the parser
will have consumed. We are using the
gettokens() function (as described below)
to read the text.
!

static otherVariable = &quot;etc...&quot;;</PRE>
<P CLASS="Untitled">
<A NAME="pgfId=175648">
 </A>This function can also be used to parse the rest of a module within an error catcher.  For example:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175578"></A>try
	parse(currentfile(), scope())
onerror
	printf(&quot;That didn't work, but never mind.\n&quot;);

static this = that;
etc();</PRE>
<P CLASS="Body">
<A NAME="pgfId=175650">
 </A>The functions  parse and scope are described below.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175652">
 </A><CODE CLASS="+Code">
del(struct, key)</CODE>
<A NAME="del">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=175655">
 </A>Deletes the element of struct identified by key. Any super structs are ignored.  Returns NULL.  For example:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175657"></A>static s = [struct a = 1, b = 2, c = 3];
static v, k;
forall (v, k in s)
	printf(&quot;%s=%d\n&quot;, k, v);
del(s, &quot;b&quot;);
printf(&quot;\n&quot;);
forall (v, k in s)
	printf(&quot;%s=%d\n&quot;, k, v);</PRE>
<P CLASS="Body">
<A NAME="pgfId=175663">
 </A>When run would produce (possibly in some other order):</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175665"></A>a=1
c=3
b=2

a=1
c=3</PRE>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175669">
 </A><CODE CLASS="+Code">
int = eof([file])</CODE>
<A NAME="eof">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=180163">
 </A>Returns non-zero if end of file has been read on <I CLASS="+Italic">
file</I>
. If <I CLASS="+Italic">
file</I>
 is not given the current value of <I CLASS="+Italic">
stdin</I>
 in the current scope is used.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=180162">
 </A><CODE CLASS="+Code">
int = eq(obj1, obj2)</CODE>
<A NAME="eq">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=175671">
 </A>Returns 1 (one) if obj1 and obj2 are the same object, else 0 (zero).</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=182180">
 </A><CODE CLASS="+Code">
eventloop()</CODE>
<A NAME="eventloop">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=182181">
 </A>Enters an internal event loop and never returns (but can be broken out of with an error). The exact nature of the event loop is system specific. Some dynamically loaded modules require an event loop for their operation.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175672">
 </A><CODE CLASS="+Code">
exit([string|int|NULL])</CODE>
<A NAME="exit">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=175674">
 </A>Causes the interpreter to finish execution and exit. If no parameter, the empty string or NULL is passed the exit status is zero. If an integer is passed that is the exit status. If a non-empty string is passed then that string is printed to the interpreter's standard error output and an exit status of one used.  This is implementation dependent and may be replaced by a more general exception mechanism.  Avoid.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175676">
 </A><CODE CLASS="+Code">
float = exp(x)</CODE>
<A NAME="exp">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=175677">
 </A>Returns the exponential function of x.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175678">
 </A><CODE CLASS="+Code">
array = explode(string)</CODE>
<A NAME="explode">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=175679">
 </A>Returns an array containing each of the integer character codes of the characters in string.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175682">
 </A><CODE CLASS="+Code">
fail(string)</CODE>
<A NAME="fail">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=175684">
 </A>Causes an error to be raised with the message string associated with it.  See the section of error handling in the try statement above.  For example:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175686"></A>if (qf &gt; 255)
	fail(sprintf(&quot;Q factor %d is too large&quot;, qf));</PRE>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175687">
 </A><CODE CLASS="+Code">
value = fetch(struct, key)</CODE>
<A NAME="fetch">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=175690">
 </A>Returns the value from struct associated with key, ignoring any super structs. Returns NULL is key is not an element of struct.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175693">
 </A><CODE CLASS="+Code">
value = float(x)</CODE>
<A NAME="float">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=175696">
 </A>Returns a floating point interpretation of x, or 0.0 if no reasonable interpretation exists. x should be an int, a float, or a string, else 0.0 will be returned.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175698">
 </A><CODE CLASS="+Code">
file = fopen(name [, mode])</CODE>
<A NAME="fopen">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=178436">
 </A>Opens the named file for reading or writing according to <I CLASS="+Italic">
mode</I>
 and returns a file object that may be used to perform I/O on the file. <I CLASS="+Italic">
Mode</I>
 is the same as in C and is passed directly to the C library <CODE CLASS="CourierBold">
fopen</CODE>
 function. If mode is not specified <CODE CLASS="CourierBold">
&quot;r&quot;</CODE>
 is assumed.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178437">
 </A><CODE CLASS="+Code">
fprintf(file, fmt, args...)</CODE>
<A NAME="fprintf">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=175699">
 </A>Formats a string based on fmt and args as per sprintf (below) and outputs the result to file.  See sprintf. <B CLASS="+Bold">
Changes to ICI's printf have made fprintf redundant and it may be removed in future versions of the interpreter. Avoid.</B>
</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=180243">
 </A><CODE CLASS="+Code">
string = getchar([file])</CODE>
<A NAME="getchar">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=180246">
 </A>Reads a single character from <I CLASS="+Italic">
file</I>
 and returns it as a string. Returns NULL upon end of file. If <I CLASS="+Italic">
file</I>
 is not given the current value of <I CLASS="+Italic">
stdin</I>
 in the current scope is used.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=180242">
 </A><CODE CLASS="+Code">
string = getfile([file])</CODE>
<A NAME="getfile">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=180248">
 </A>Reads all remaining data from <I CLASS="+Italic">
file</I>
 and returns it as a string. Returns an empty string upon end of file. If <I CLASS="+Italic">
file</I>
 is not given the current value of <I CLASS="+Italic">
stdin</I>
 in the current scope is used.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=180247">
 </A><CODE CLASS="+Code">
string = getline([file])</CODE>
<A NAME="getline">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=180227">
 </A>Reads a line of text from <I CLASS="+Italic">
file</I>
 and returns it as a string. Any end-of-line marker is removed. Returns <I CLASS="+Italic">
NULL</I>
 upon end of file. If <I CLASS="+Italic">
file</I>
 is not given the current value of <I CLASS="+Italic">
stdin</I>
 in the current scope is used.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=180237">
 </A><CODE CLASS="+Code">
string = gettoken([file [, seps]])</CODE>
<A NAME="gettoken">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=175704">
 </A>Read a token (that is, a string) from file.</P>
<P CLASS="Body">
<A NAME="pgfId=175707">
 </A>Seps must be a string.  It is interpreted as a set of characters which do not from part of the token.  Any leading sequence of these characters is first skipped.  Then a sequence of characters not in seps is gathered until end of file or a character from seps is found.  This terminating character is not consumed.  The gathered string is returned, or NULL if end of file was encountered before any token was gathered.</P>
<P CLASS="Body">
<A NAME="pgfId=175709">
 </A>If file is not given the current value of stdin in the current scope is used.</P>
<P CLASS="Body">
<A NAME="pgfId=175710">
 </A>If seps is not given the string &quot; \t\n&quot; is assumed.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175711">
 </A><CODE CLASS="+Code">
array = gettokens([file [, seps [, terms]]])</CODE>
<A NAME="gettokens">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=175712">
 </A>Read tokens (that is, strings) from file.  The tokens are character sequences separated by seps and terminated by terms.  Returns an array of strings, NULL on end of file.</P>
<P CLASS="Body">
<A NAME="pgfId=175714">
 </A>If seps is a string, it is interpreted as a set of characters, any sequence of which will separate one token from the next.  In this case leading and trailing separators in the input stream are discarded.</P>
<P CLASS="Body">
<A NAME="pgfId=175717">
 </A>If seps is an integer it is interpreted as a character code.  Tokens are taken to be sequences of characters separated by exactly one of that character.</P>
<P CLASS="Body">
<A NAME="pgfId=175720">
 </A>Terms must be a string.  It is interpreted as a set of characters, any one of which will terminate the gathering of tokens.  The character which terminated the gathering will be consumed.</P>
<P CLASS="Body">
<A NAME="pgfId=175721">
 </A>If file is not given the current value of stdin in the current scope will be used.</P>
<P CLASS="Body">
<A NAME="pgfId=175724">
 </A>If seps is not given the string &quot; \t&quot; is assumed.</P>
<P CLASS="Body">
<A NAME="pgfId=175726">
 </A>If terms is not given the string &quot;\n&quot; is assumed.</P>
<P CLASS="Body">
<A NAME="pgfId=175729">
 </A>For example:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175733"></A>forall (token in gettokens(currentfile()))
	printf(&quot;&lt;%s&gt;&quot;, token)
;   This    is my line    of data.
printf(&quot;\n&quot;);</PRE>
<P CLASS="Body">
<A NAME="pgfId=175739">
 </A>when run will print:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175743"></A>&lt;This&gt;&lt;is&gt;&lt;my&gt;&lt;line&gt;&lt;of&gt;&lt;data.&gt;</PRE>
<P CLASS="Body">
<A NAME="pgfId=175746">
 </A>Whereas: </P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175749"></A>forall (token in gettokens(currentfile(), ':', &quot;*&quot;))
	printf(&quot;&lt;%s&gt;&quot;, token)
;:abc::def:ghi:*
printf(&quot;\n&quot;);</PRE>
<P CLASS="Body">
<A NAME="pgfId=175754">
 </A>when run will print:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175756"></A>&lt;&gt;&lt;abc&gt;&lt;&gt;&lt;def&gt;&lt;ghi&gt;&lt;&gt;</PRE>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175757">
 </A><CODE CLASS="+Code">
string = gsub(string, string|regexp, string)</CODE>
<A NAME="gsub">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=177040">
 </A>gsub performs text substitution using regular expressions. It takes the first parameter, matches it against the second parameter and then replaces the matched portion of the string with the third parameter. If the second parameter is a string it is converted to a regular expression as if the regexp function had been called. Gsub does the replacement multiple times to replace all occurrances of the pattern. It returns the new string formed by the replacement. If there is no match this is original string. The replacement string may contain the special sequence &quot;\&amp;&quot; which is replaced by the string that matched the regular expression. Parenthesized portions of the regular expression may be matched by using \<I CLASS="+Italic">
n</I>
 where <I CLASS="+Italic">
n</I>
 is a decimal digit.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=177041">
 </A><CODE CLASS="+Code">
string = implode(array)</CODE>
<A NAME="implode">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=175758">
 </A>Returns a string formed from the concatenation of elements of array.  Integers in the array will be interpreted as character codes; strings in the array will be included in the concatenation directly.  Other types are ignored.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175760">
 </A><CODE CLASS="+Code">
struct = include(string [, scope])</CODE>
<A NAME="include">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=180047">
 </A>Parses the code contained in the file named by the string into the scope. If scope is not passed the current scope is used. Include always returns the scope into which the code was parsed. The file is opened by calling the current definition of the ICI fopen() function so path searching can be implemented by overriding that function.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=180046">
 </A><CODE CLASS="+Code">
value = int(any)</CODE>
<A NAME="int">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=175777">
 </A>Returns an integer interpretation of x, or 0 if no reasonable interpretation exists. x should be an int, a float, or a string, else 0 will be returned.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175781">
 </A><CODE CLASS="+Code">
subpart = interval(str_or_array, start [, length])</CODE>
<A NAME="interval">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=175784">
 </A>Returns a sub-interval of str_or_array, which may be either a string or an array.</P>
<P CLASS="Body">
<A NAME="pgfId=175787">
 </A>If start (an integer) is positive the sub-interval starts at that offset (offset 0 is the first element).  If start is negative the sub-interval starts that many elements from the end of the string (offset -1 is the last element, -2 the second last etc).</P>
<P CLASS="Body">
<A NAME="pgfId=175790">
 </A>If length is absent, all the elements from the start are included in the interval.  Otherwise that many elements are included (or till the end, whichever is smaller).</P>
<P CLASS="Body">
<A NAME="pgfId=175793">
 </A>For example, the last character in a string can be accessed with:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175796"></A>last = interval(str, -1);</PRE>
<P CLASS="Body">
<A NAME="pgfId=175798">
 </A>And the first three elements of an array with:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175800"></A>first3 = interval(ary, 0, 3);</PRE>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175801">
 </A><CODE CLASS="+Code">
isatom(any)</CODE>
<A NAME="isatom">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=175802">
 </A>Return 1 (one) if any is an atomic (read-only) object, else 0 (zero).  Note that integers, floats and strings are always atomic.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175804">
 </A><CODE CLASS="+Code">
array = keys(struct)</CODE>
<A NAME="keys">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=175805">
 </A>Returns an array of all the keys from struct.  The order is not predictable, but is repeatable if no elements are added or deleted from the struct between calls and is the same order as taken by a forall loop.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175806">
 </A><CODE CLASS="+Code">
float = log(x)</CODE>
<A NAME="log">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=175807">
 </A>Returns the natural logarithm of x (a float).</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175810">
 </A><CODE CLASS="+Code">
float = log10(x)</CODE>
<A NAME="log10">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=175813">
 </A>Returns the log base 10 of x (a float).</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175816">
 </A><CODE CLASS="+Code">
mem = mem(start, nwords [, wordz])</CODE>
<A NAME="mem">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=175819">
 </A>Returns a memory object which refers to a particular area of memory in the ICI interpreter's address space.  Note that this is a highly dangerous operation.  Many implementations will not include this function or restrict its use.  It is designed for diagnostics, embedded systems and controllers.  See the alloc function above.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=177157">
 </A><CODE CLASS="+Code">
file = mopen(mem [, mode])</CODE>
<A NAME="mopen">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=178475">
 </A>Returns a file, which when read will fetch successive bytes from the given memory object. The memory object must have an access size of one (see <I CLASS="+Italic">
alloc</I>
 and <I CLASS="+Italic">
mem</I>
 above). The file is read-only and the mode, if passed, must be one of <CODE CLASS="CourierBold">
&quot;r&quot;</CODE>
 or <CODE CLASS="CourierBold">
&quot;rb&quot;</CODE>
.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178470">
 </A><CODE CLASS="+Code">
int = nels(any)</CODE>
<A NAME="nels">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=177158">
 </A>Returns the number of elements in any.  The exact meaning depends on the type of any.  If any is an:</P>
<P CLASS="TagIn2cm">
<A NAME="pgfId=177159">
 </A><I CLASS="+Italic">
array</I>
	the length of the array is returned; if it is a</P>
<P CLASS="TagIn2cm">
<A NAME="pgfId=177160">
 </A><I CLASS="+Italic">
struct</I>
	the number of key/value pairs is returned; if it is a</P>
<P CLASS="TagIn2cm">
<A NAME="pgfId=177161">
 </A><I CLASS="+Italic">
set</I>
	the number of elements is returned; if it is a</P>
<P CLASS="TagIn2cm">
<A NAME="pgfId=177162">
 </A><I CLASS="+Italic">
string</I>
	the number of characters is returned; and if it is a</P>
<P CLASS="TagIn2cm">
<A NAME="pgfId=177163">
 </A><I CLASS="+Italic">
mem</I>
	the number of words (either 1, 2 or 4 byte quantities) is returned;</P>
<P CLASS="Body">
<A NAME="pgfId=177164">
 </A>and if it is anything else, one is returned.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175862">
 </A><CODE CLASS="+Code">
number = num(x)</CODE>
<A NAME="num">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=175865">
 </A>If x is an int or float, it is returned directly.  If x is a string it will be converted to an int or float depending on its appearance; applying octal and hex interpretations according to the normal ICI source parsing conventions.  (That is, if it starts with a 0x it will be interpreted as a hex number, else if it starts with a 0 it will be interpreted as an octal number, else it will be interpreted as a decimal number.)</P>
<P CLASS="Body">
<A NAME="pgfId=175868">
 </A>If x can not be interpreted as a number the error %s is not a number is generated.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175870">
 </A><CODE CLASS="+Code">
scope = parse(source [, scope])</CODE>
<A NAME="parse">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=175871">
 </A>Parses source in a new variable scope, or, if scope (a struct) is supplied, in that scope.  Source may either be a file or a string, and in either case it is the source of text for the parse.  If the parse is successful, the variables scope structure of the sub-module is returned.  If an explicit scope was supplied this will be that structure.</P>
<P CLASS="Body">
<A NAME="pgfId=175872">
 </A>If scope is not supplied a new struct is created for the auto variables.  This structure in turn is given a new structure as its super struct for the static variables.  Finally, this structure's super is set to the current static variables.  Thus the static variables of the current module form the externs of the sub-module.</P>
<P CLASS="Body">
<A NAME="pgfId=175874">
 </A>If scope is supplied it is used directly as the scope for the sub-module.  Thus the base structure will be the struct for autos, its super will be the struct for statics etc.</P>
<P CLASS="Body">
<A NAME="pgfId=175877">
 </A>For example:</P>
<P CLASS="Untitled">
<A NAME="pgfId=175879">
 </A>&nbsp;</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175880"></A>static x = 123;
parse(&quot;static x = 456;&quot;, scope());
printf(&quot;x = %d\n&quot;, x);</PRE>
<P CLASS="Body">
<A NAME="pgfId=175881">
 </A>When run will print:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175884"></A>x = 456</PRE>
<P CLASS="Body">
<A NAME="pgfId=175885">
 </A>Whereas:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175887"></A>static x = 123;
parse(&quot;static x = 456;&quot;);
printf(&quot;x = %d\n&quot;, x);</PRE>
<P CLASS="Body">
<A NAME="pgfId=175891">
 </A>When run will print:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175894"></A>x = 123</PRE>
<P CLASS="Body">
<A NAME="pgfId=175897">
 </A>Note that while the following will work:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175900"></A>parse(fopen(&quot;my-module.ici&quot;));</PRE>
<P CLASS="Body">
<A NAME="pgfId=175901">
 </A>It is preferable in a large program to use:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175902"></A>parse(file = fopen(&quot;my-module.ici&quot;));
close(file);</PRE>
<P CLASS="Body">
<A NAME="pgfId=175904">
 </A>In the first case the file will eventually be closed by garbage collection, but exactly when this will happen is unpredictable. The underlying system may only allow a limited number of simultaneous open files.  Thus if the program continues to open files in this fashion a system limit may be reached before the unused files are garbage collected.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175907">
 </A><CODE CLASS="+Code">
any = pop(array)</CODE>
<A NAME="pop">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=175910">
 </A>Returns the last element of array and reduces the length of array by one.  If the array was empty to start with, NULL is returned.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175913">
 </A><CODE CLASS="+Code">
file = popen(string, [flags])</CODE>
<A NAME="popen">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=178408">
 </A>Executes a new process, specified as a shell command line as for the <I CLASS="+Italic">
system</I>
 function, and returns a file that either reads or writes to the standard input or output of the process according to <I CLASS="+Italic">
mode</I>
. If mode is <CODE CLASS="CourierBold">
&quot;r&quot;</CODE>
 the reading from the file reads from the standard output of the process. If mode is <CODE CLASS="CourierBold">
&quot;w&quot;</CODE>
 writing to the file writes to the standard input of the process. If mode is not speicified it defaults to <CODE CLASS="CourierBold">
&quot;r&quot;</CODE>
.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178405">
 </A><CODE CLASS="+Code">
float = pow(x, y)</CODE>
<A NAME="pow">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=175916">
 </A>Returns x^y where both x and y are floats.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175919">
 </A><CODE CLASS="+Code">
printf([file,] fmt, args...)</CODE>
<A NAME="printf">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=175922">
 </A>Formats a string based on fmt and args as per sprintf (below) and outputs the result to the <I CLASS="+Italic">
file</I>
 or to the current value of the stdout variable in the current scope if the first parameter is not a file.  The current stdout must be a file.  See sprintf.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175924">
 </A><CODE CLASS="+Code">
any = push(array, any)</CODE>
<A NAME="push">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=175926">
 </A>Appends any to array, increasing its length in the process.  Returns any.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175927">
 </A><CODE CLASS="+Code">
put(string [, file])</CODE>
<A NAME="put">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=180261">
 </A>Outputs string to <I CLASS="+Italic">
file</I>
. If <I CLASS="+Italic">
file</I>
 is not passed the current value of <I CLASS="+Italic">
stdout</I>
 in the current scope is used.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=180260">
 </A><CODE CLASS="+Code">
int = rand([seed])</CODE>
<A NAME="rand">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=175930">
 </A>Returns an pseudo random integer in the range 0..0x7FFF.  If seed (an int) is supplied the random number generator is first seeded with that number.  The sequence is predictable based on a given seed.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175933">
 </A><CODE CLASS="+Code">
reclaim()</CODE>
<A NAME="reclaim">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=179108">
 </A>Force a garbage collection to occur.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=179107">
 </A><CODE CLASS="+Code">
re = regexp(string [, int])</CODE>
<A NAME="regexp">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=175936">
 </A>Returns a compiled regular expression derived from string  This is the method of generating regular expressions at run-time, as opposed to the direct lexical form. For example, the following three expressions are similar:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175938"></A>str ~ #*\.c#
str ~ regexp(&quot;*\\.c&quot;);
str ~ $regexp(&quot;*\\.c&quot;);</PRE>
<P CLASS="Body">
<A NAME="pgfId=175941">
 </A>except that the middle form computes the regular expression each time it is executed.  Note that when a regular expression includes a # character the regexp function must be used, as the direct lexical form has no method of escaping a #.</P>
<P CLASS="Body">
<A NAME="pgfId=184667">
 </A>The optional second parameter is a bit-set that controls various aspects of the compiled regular expression's behaviour.  This value is passed directly to the PCRE package's regular expression compilation function.  Presently no symbolic names are defined for the possible values and interested parties are directed to the PCRE documention included with the ICI source code.</P>
<P CLASS="Body">
<A NAME="pgfId=175942">
 </A>Note that regular expressions are intrinsically atomic.  Also note that  non-equal strings may sometimes compile to the same regular expression. </P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=179052">
 </A><CODE CLASS="+Code">
re = regexpi(string [, int])</CODE>
<A NAME="regexpi">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=179053">
 </A>Returns a compiled regular expression derived from string  that is case-insensitive. I.e., the regexp will match a string regardless of the case of alphabetic characters.  Literal regular expressions to perform case-insensitive matching may be constructed using the special PCRE notation for such purposes, see <A HREF="ici.html#17592" CLASS="XRef">
See The settings of PCRE_CASELESS, PCRE_MULTILINE, PCRE_DOTALL, and PCRE_EXTENDED can be changed from within the pattern by a sequence of Perl option letters enclosed between &quot;(?&quot; and &quot;)&quot;. The option letters are</A>.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175945">
 </A><CODE CLASS="+Code">
remove(string)</CODE>
<A NAME="remove">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=180008">
 </A>Deletes the file whose name is given in string.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=180007">
 </A><CODE CLASS="+Code">
current = scope([replacement])</CODE>
<A NAME="scope">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=175947">
 </A>Returns the current scope structure.  This is a struct whose base element holds the auto variables, the super of that hold the statics, the super of that holds the externs etc.  Note that this is a real reference to the current scope structure.  Changing, adding and deleting elements of these structures will affect the values and presence of variables in the current scope.</P>
<P CLASS="Body">
<A NAME="pgfId=175949">
 </A>If a replacement is given, that struct  replaces the current scope structure, with the obvious implications.  This should clearly be used with caution.  Replacing the current scope with a structure which has no reference to the standard functions also has the obvious effect.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=180000">
 </A><CODE CLASS="+Code">
int = seek(file, int, int)</CODE>
<A NAME="seek">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=180001">
 </A>Set the input/output position for a file and returns the new I/O position or -1 if an error ocurred. The arguments are the same as for the C library's fseek function. If the file object does not support setting the I/O position or the seek operation fails an error is raised.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175951">
 </A><CODE CLASS="+Code">
set = set(any...)</CODE>
<A NAME="set">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=175953">
 </A>Returns a set formed from all the arguments. For example:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175956"></A>set()</PRE>
<P CLASS="Body">
<A NAME="pgfId=175957">
 </A>will return a new empty set; and</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175960"></A>set(1, 2, &quot;a string&quot;)</PRE>
<P CLASS="Body">
<A NAME="pgfId=175962">
 </A>will return a new set with three elements, 1, 2, and &quot;the string&quot;.</P>
<P CLASS="Body">
<A NAME="pgfId=175964">
 </A>This is the run-time equivalent of the set literal. Thus the following two expressions are equivalent:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175966"></A>$set(1, 2, &quot;a string&quot;)</PRE>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=175969"></A>[set 1, 2, &quot;a string&quot;]</PRE>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175972">
 </A><CODE CLASS="+Code">
x = sin(angle)</CODE>
<A NAME="sin">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=175973">
 </A>Returns the sine of angle (a float interpreted in radians).</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=177182">
 </A><CODE CLASS="+Code">
file = sopen(string [, mode])</CODE>
<A NAME="sopen">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=175991">
 </A>Returns a file, which when read will fetch successive characters from the given string. The file is read-only and the mode, if passed, must be one of <CODE CLASS="CourierBold">
&quot;r&quot;</CODE>
 or <CODE CLASS="CourierBold">
&quot;rb&quot;</CODE>
.</P>
<P CLASS="Body">
<A NAME="pgfId=175994">
 </A>Files are, in general, system dependent.  This is the only standard routine which opens a file.  But on systems that support byte stream files, the function fopen will be set to the most appropriate method of opening a file for general use. The interpretation of mode is largely system dependent, but the strings &quot;r&quot;, &quot;w&quot;, and &quot;rw&quot; should be used for read, write, and read-write file access respectively.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=175996">
 </A><CODE CLASS="+Code">
sort(array, func)</CODE>
<A NAME="sort">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=177107">
 </A>Sort the content of the array using the heap sort algorithm with func as the comparison function. The comparison function is called with two elements of the array as parameters, <I CLASS="+Italic">
a</I>
 and <I CLASS="+Italic">
b</I>
. If <I CLASS="+Italic">
a</I>
 is equal to <I CLASS="+Italic">
b</I>
 the function should return zero. If <I CLASS="+Italic">
a</I>
 is less than <I CLASS="+Italic">
b</I>
, -1, and if <I CLASS="+Italic">
a</I>
 is greater than <I CLASS="+Italic">
b</I>
, 1.</P>
<P CLASS="Body">
<A NAME="pgfId=177132">
 </A>For example,</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=177133"></A>static cmp(a, b)</PRE>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=177135"></A>{</PRE>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=177136"></A>    if (a == b)</PRE>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=177137"></A>		return 0;</PRE>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=177138"></A>    if (a &lt; b)</PRE>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=177139"></A>		return -1;</PRE>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=177140"></A>    return 1;</PRE>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=177141"></A>}</PRE>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=177142"></A>&nbsp;</PRE>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=177143"></A>static a = array(1, 3, 2);</PRE>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=177144"></A>&nbsp;</PRE>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=177145"></A>sort(a, cmp);</PRE>
<P CLASS="Body">
<A NAME="pgfId=177119">
 </A><CODE CLASS="CourierBold">
</CODE>
&nbsp;</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178397">
 </A><CODE CLASS="+Code">
string = sprintf(fmt, args...)</CODE>
<A NAME="sprintf">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=175999">
 </A>Return a formatted string based on fmt (a string) and args.  Most of the usual % format escapes of ANSI C printf are supported.  In particular; the integer format letters diouxXc are supported, but if a float is provided it will be converted to an int.  The floating point format letters feEgG are supported, but if the argument is an int it will be converted to a float.  The string format letter, s is supported and requires a string.  Finally the % format to get a single % works.</P>
<P CLASS="Body">
<A NAME="pgfId=176002">
 </A>The flags, precision, and field width options are supported.  The indirect field width and precision options with * also work and the corresponding argument must be an int.</P>
<P CLASS="Body">
<A NAME="pgfId=176004">
 </A>For example:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=176006"></A>sprintf(&quot;%08X &lt;%4s&gt; &lt;%-4s&gt;&quot;, 123, &quot;ab&quot;, &quot;cd&quot;)</PRE>
<P CLASS="Body">
<A NAME="pgfId=176009">
 </A>will produce the string:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=176012"></A>0000007B &lt;  ab&gt; &lt;cd  &gt;</PRE>
<P CLASS="Body">
<A NAME="pgfId=176015">
 </A>and</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=176016"></A>sprintf(&quot;%0*X&quot;, 4, 123)</PRE>
<P CLASS="Body">
<A NAME="pgfId=176019">
 </A>will produce the string:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=176022"></A>007B</PRE>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=176023">
 </A><CODE CLASS="+Code">
x = sqrt(float)</CODE>
<A NAME="sqrt">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=176024">
 </A>Returns the square root of float.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=176025">
 </A><CODE CLASS="+Code">
string = string(any)</CODE>
<A NAME="string">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=176026">
 </A>Returns a short textual representation of any. If any is an int or float it is converted as if by a %d or %g format.  If it is a string it is returned directly.  Any other type will returns its type name surrounded by angle brackets, as in &lt;struct&gt;.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=176028">
 </A><CODE CLASS="+Code">
struct = struct([super,] key, value...)</CODE>
<A NAME="struct">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=176030">
 </A>Returns a new structure.  This is the run-time equivalent of the struct literal.  If there are an odd number of arguments the first is used as the super of the new struct; it must be a struct.  The remaining pairs of arguments are treated as key and value pairs to initialise the structure with; they may be of any type.  For example:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=176032"></A>struct()</PRE>
<P CLASS="Body">
<A NAME="pgfId=176035">
 </A>returns a new empty struct;</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=176038"></A>struct(anotherStruct)</PRE>
<P CLASS="Body">
<A NAME="pgfId=176041">
 </A>returns a new empty struct which has anotherStruct as its super;</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=176043"></A>struct(&quot;a&quot;, 1, &quot;b&quot;, 2)</PRE>
<P CLASS="Body">
<A NAME="pgfId=176045">
 </A>returns a new struct which has two entries a and b with the values 1 and 2; and</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=176047"></A>struct(anotherStruct, &quot;a&quot;, 1, &quot;b&quot;, 2)</PRE>
<P CLASS="Body">
<A NAME="pgfId=176050">
 </A>returns a new struct which has two entries a and b with the values 1 and 2 and a super of anotherStruct.</P>
<P CLASS="Body">
<A NAME="pgfId=176052">
 </A>Note that the super of the new struct is set after the assignments of the new elements have been made. Thus the initial elements given as arguments will not affect values in any super struct.</P>
<P CLASS="Body">
<A NAME="pgfId=176055">
 </A>The following two expressions are equivalent:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=176058"></A>$struct(anotherStruct, &quot;a&quot;, 1, &quot;b&quot;, 2)</PRE>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=176061"></A>[struct:anotherStruct, a = 1, b = 2]</PRE>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=177092">
 </A><CODE CLASS="+Code">
string = sub(string, string|regexp, string)</CODE>
<A NAME="sub">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=177093">
 </A>Sub performs text substitution using regular expressions. It takes the first parameter, matches it against the second parameter and then replaces the matched portion of the string with the third parameter. If the second parameter is a string it is converted to a regular expression as if the regexp function had been called. Sub does the replacement once (unlike gsub). It returns the new string formed by the replacement. If there is no match this is original string. The replacement string may contain the special sequence &quot;\&amp;&quot; which is replaced by the string that matched the regular expression. Parenthesized portions of the regular expression may be matched by using \<I CLASS="+Italic">
n</I>
 where <I CLASS="+Italic">
n</I>
 is a decimal digit.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=176062">
 </A><CODE CLASS="+Code">
current = super(struct [, replacement])</CODE>
<A NAME="super">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=176063">
 </A>Returns the current super struct of struct, and, if replacement is supplied, sets it to a new value.  If replacement is NULL any current super struct reference is cleared (that is, after this struct will have no super).</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=182195">
 </A><CODE CLASS="+Code">
x = tan(angle)</CODE>
<A NAME="tan">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=182221">
 </A>Returns the tangent of angle (a float interpreted in radians).</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=182222">
 </A><CODE CLASS="+Code">
foat = now()</CODE>
<A NAME="now">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=182223">
 </A>Returns the current time expressed as a signed float time in seconds since 0:00, 1st Jan 2000 UTC.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=182242">
 </A><CODE CLASS="+Code">
float|struct = calendar(struct|float)</CODE>
<A NAME="calendar">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=182243">
 </A>Converts between calendar time and arithmetic time. An arithmetic time is expressed as a signed float time in seconds since 0:00, 1st Jan 2000 UTC. The calendar time is expressed as a structure with fields revealing the local (including current daylight saving adjustment) calendar date and time. Fields in the calendar structure are:</P>
<P CLASS="TagIn2cm">
<A NAME="pgfId=182275">
 </A>second	The float number of seconds after the minute.</P>
<P CLASS="TagIn2cm">
<A NAME="pgfId=182279">
 </A>minute	The int number of minutes after the hour.</P>
<P CLASS="TagIn2cm">
<A NAME="pgfId=182280">
 </A>hour	The int number of hours since midnight.</P>
<P CLASS="TagIn2cm">
<A NAME="pgfId=182281">
 </A>day	The day of the month (1..31).</P>
<P CLASS="TagIn2cm">
<A NAME="pgfId=182282">
 </A>month	The int month number, Jan is 0.</P>
<P CLASS="TagIn2cm">
<A NAME="pgfId=182283">
 </A>year	The int year.</P>
<P CLASS="TagIn2cm">
<A NAME="pgfId=182284">
 </A>wday	The day since Sunday (0..6)</P>
<P CLASS="TagIn2cm">
<A NAME="pgfId=182340">
 </A>yday	Days since 1st Jan.</P>
<P CLASS="Body">
<A NAME="pgfId=182315">
 </A>When converting from a local calendar time to an arithmetic time, the fields sec, min, hour, mday, mon, year are used. They need not be restricted to their nomal ranges.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=182224">
 </A><CODE CLASS="+Code">
string = tochar(int)</CODE>
<A NAME="tochar">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=182225">
 </A>Returns a one character string made from the character code specified by int.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=180053">
 </A><CODE CLASS="+Code">
int = toint(string)</CODE>
<A NAME="toint">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=180052">
 </A>Returns the character code of the first character of string.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=176071">
 </A><CODE CLASS="+Code">
string = typeof(any)</CODE>
<A NAME="typeof">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=176072">
 </A>Returns the type name (a string) of any.  See the section on types above for the possible type names.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=176074">
 </A><CODE CLASS="+Code">
array = vstack()</CODE>
<A NAME="vstack">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=178520">
 </A>Returns a representation of the call stack of the current program at the time of the call. It can be used to perform stack tracebacks and related debugging operations. The result is an array of structures, each of which is a variable scope (see <I CLASS="+Italic">
scope</I>
) structure of succesively deeper nestings of the current function nesting.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178499">
 </A><CODE CLASS="+Code">
event = waitfor(event...)</CODE>
<A NAME="waitfor">
 </A></H4>
<P CLASS="Body">
<A NAME="pgfId=176077">
 </A>Blocks (waits) until an event indicated by any of its arguments occurs, then returns that argument.  The interpretation of an event depends on the nature of each argument.  A file argument is triggered when input is available on the file. A float argument waits for that many seconds to expire, an int for that many millisecond (they then return 0, not the argument given). Other interpretations are implementation dependent. Where several events occur simultaneously, the first as listed in the arguments will be returned.</P>
<P CLASS="Body">
<A NAME="pgfId=176080">
 </A>Note that in some implementations some file types may always appear ready for input, despite the fact that they are not.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=180032">
 </A>Command Line Arguments</H4>
<P CLASS="Body">
<A NAME="pgfId=180033">
 </A>Versions of ICI on systems that support passing parameters from the command line provide two predefined variables, argv and argc, for accessing these arguments.</P>
<P CLASS="Body">
<A NAME="pgfId=180149">
 </A>On Win32 platforms ICI performs wildcard expansion in the traditional MS-DOS fashion. Arguments containing wildcard meta-characters, `?' and `*', may be protected by enclosing them in single or double quotes.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=180034">
 </A>argv</H4>
<P CLASS="Body">
<A NAME="pgfId=180035">
 </A>An array of strings containing the command line arguments. The first element is the name of the ICI program and subsequent elements are the arguments passed to that program.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=180038">
 </A>argc</H4>
<P CLASS="Body">
<A NAME="pgfId=180039">
 </A>The count of the number of elements in argv. Initially equal to nels(argv).</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=177406">
 </A>Unix System Calls</H4>
<P CLASS="Body">
<A NAME="pgfId=177407">
 </A>Most Unix implementation of ICI provide access to many of the Unix system calls and other useful C library functions. Note that not all system calls are supported and those that are may be incompletely supported (e.g., <I CLASS="+Italic">
signal</I>
). Most system call functions return integers, zero if the call succeeded. Errors are reported using ICI's error handling and &quot;system calls&quot; will never return the -1 error return value. If an error is raised by a system call the value of &quot;error&quot; in the error handler will be the error message (as printed by the perror(3) function or returned by the ANSI C strerror() function).</P>
<P CLASS="Body">
<A NAME="pgfId=178009">
 </A>To assist in the use of system calls ICI pre-defines variables to hold the various flags and other values used when calling the system calls. These variables are equivalent to the macros used in C. Not all systems support all these variables. If the C header files do not define a value then ICI will not pre-define the variable.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=180009">
 </A>Win32 Support</H4>
<P CLASS="Body">
<A NAME="pgfId=180010">
 </A>The version of ICI for Microsoft's 32-bit Windows platforms (Win32)  supports many of these functions. Functions supported on Win32 platforms (Windows 95 and Windows NT) are marked with WIN32. In addition some functions are only available on Win32 platforms and are marked as so.</P>
<P CLASS="Body">
<A NAME="pgfId=177764">
 </A>The following list summarises the Unix system call interface pre-defined variables. See the documentation for the C macros for information as to their use.</P>
<P CLASS="Body">
<A NAME="pgfId=177770">
 </A>Values for open's <I CLASS="+Italic">
flags</I>
 parameter,</P>
<P CLASS="Untitled">
<A NAME="pgfId=177425">
 </A>O_RDONLY</P>
<P CLASS="Untitled">
<A NAME="pgfId=177428">
 </A>O_WRONLY</P>
<P CLASS="Untitled">
<A NAME="pgfId=177269">
 </A>O_RDWR</P>
<P CLASS="Untitled">
<A NAME="pgfId=177270">
 </A>O_APPEND</P>
<P CLASS="Untitled">
<A NAME="pgfId=177271">
 </A>O_CREAT</P>
<P CLASS="Untitled">
<A NAME="pgfId=177272">
 </A>O_TRUNC</P>
<P CLASS="Untitled">
<A NAME="pgfId=177273">
 </A>O_EXCL</P>
<P CLASS="Untitled">
<A NAME="pgfId=177274">
 </A>O_SYNC</P>
<P CLASS="Untitled">
<A NAME="pgfId=177275">
 </A>O_NDELAY</P>
<P CLASS="Untitled">
<A NAME="pgfId=177277">
 </A>O_NONBLOCK</P>
<P CLASS="Untitled">
<A NAME="pgfId=180011">
 </A>O_BINARY		(WIN32 only)</P>
<P CLASS="Untitled">
<A NAME="pgfId=180102">
 </A>&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId=180103">
 </A>Values for spawn's <I CLASS="+Italic">
mode</I>
 parameter,</P>
<P CLASS="Untitled">
<A NAME="pgfId=180104">
 </A>&nbsp;</P>
<P CLASS="Untitled">
<A NAME="pgfId=180096">
 </A>_P_WAIT		(WIN32 only)</P>
<P CLASS="Untitled">
<A NAME="pgfId=180097">
 </A>_P_NOWAIT		(WIN32 only)</P>
<P CLASS="Untitled">
<A NAME="pgfId=177279">
 </A>&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId=177771">
 </A>Values for access's <I CLASS="+Italic">
mode</I>
 parameter,</P>
<P CLASS="Untitled">
<A NAME="pgfId=177494">
 </A>R_OK</P>
<P CLASS="Untitled">
<A NAME="pgfId=177280">
 </A>W_OK</P>
<P CLASS="Untitled">
<A NAME="pgfId=177281">
 </A>X_OK</P>
<P CLASS="Untitled">
<A NAME="pgfId=177282">
 </A>F_OK</P>
<P CLASS="Untitled">
<A NAME="pgfId=177779">
 </A>&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId=177778">
 </A>Values for lseek's <I CLASS="+Italic">
whence</I>
 parameter,</P>
<P CLASS="Untitled">
<A NAME="pgfId=177485">
 </A>SEEK_SET</P>
<P CLASS="Untitled">
<A NAME="pgfId=177284">
 </A>SEEK_CUR</P>
<P CLASS="Untitled">
<A NAME="pgfId=177285">
 </A>SEEK_END</P>
<P CLASS="Body">
<A NAME="pgfId=177420">
 </A>&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId=177503">
 </A>The following list summarises the system interface functions. Following this is a detailed descriptions of each of them.</P>
<P CLASS="Untitled">
<A NAME="pgfId=177264">
 </A>	int =	access(string <I CLASS="+Italic">
[</I>
, int<I CLASS="+Italic">
]</I>
)</P>
<P CLASS="Untitled">
<A NAME="pgfId=177295">
 </A>	int = 	creat(string, int)</P>
<P CLASS="Untitled">
<A NAME="pgfId=180291">
 </A>	array = 	dir([string,] [string,] [regexp])</P>
<P CLASS="Untitled">
<A NAME="pgfId=177296">
 </A>	int =	dup(int <I CLASS="+Italic">
[</I>
, int<I CLASS="+Italic">
]</I>
)</P>
<P CLASS="Untitled">
<A NAME="pgfId=177297">
 </A>		exec(string, array)</P>
<P CLASS="Untitled">
<A NAME="pgfId=177685">
 </A>		exec(string, string...)</P>
<P CLASS="Untitled">
<A NAME="pgfId=177298">
 </A>	int =	lseek(int, int <I CLASS="+Italic">
[</I>
, int<I CLASS="+Italic">
]</I>
)</P>
<P CLASS="Untitled">
<A NAME="pgfId=177299">
 </A>	int = 	open(string, int <I CLASS="+Italic">
[</I>
, int<I CLASS="+Italic">
]</I>
)</P>
<P CLASS="Untitled">
<A NAME="pgfId=177300">
 </A>	array = 	pipe()</P>
<P CLASS="Untitled">
<A NAME="pgfId=177301">
 </A>	struct =	stat(string|int|file)</P>
<P CLASS="Untitled">
<A NAME="pgfId=177302">
 </A>	int =	wait()</P>
<P CLASS="Untitled">
<A NAME="pgfId=177303">
 </A>	string =	ctime(int)</P>
<P CLASS="Untitled">
<A NAME="pgfId=177304">
 </A>	int =	time()</P>
<P CLASS="Untitled">
<A NAME="pgfId=177305">
 </A>	file = 	fdopen(int)</P>
<P CLASS="Untitled">
<A NAME="pgfId=180075">
 </A>	string =	getcwd()</P>
<P CLASS="Untitled">
<A NAME="pgfId=177310">
 </A>		alarm(int)</P>
<P CLASS="Untitled">
<A NAME="pgfId=177311">
 </A>		acct(string)</P>
<P CLASS="Untitled">
<A NAME="pgfId=177312">
 </A>		chdir(string)</P>
<P CLASS="Untitled">
<A NAME="pgfId=177313">
 </A>		chmod(string, int)</P>
<P CLASS="Untitled">
<A NAME="pgfId=177314">
 </A>		chown(string, int, int)</P>
<P CLASS="Untitled">
<A NAME="pgfId=177315">
 </A>		chroot(string)</P>
<P CLASS="Untitled">
<A NAME="pgfId=177316">
 </A>		_close(int)</P>
<P CLASS="Untitled">
<A NAME="pgfId=177318">
 </A>		_exit(int)</P>
<P CLASS="Untitled">
<A NAME="pgfId=177319">
 </A>	int =	fork()</P>
<P CLASS="Untitled">
<A NAME="pgfId=177320">
 </A>	int =	getpid()</P>
<P CLASS="Untitled">
<A NAME="pgfId=177321">
 </A>	int = 	getpgrp()</P>
<P CLASS="Untitled">
<A NAME="pgfId=177823">
 </A>	int = 	getppid()</P>
<P CLASS="Untitled">
<A NAME="pgfId=177828">
 </A>	int = 	getuid()</P>
<P CLASS="Untitled">
<A NAME="pgfId=177324">
 </A>	int = 	geteuid()</P>
<P CLASS="Untitled">
<A NAME="pgfId=177325">
 </A>	int = 	getgid()</P>
<P CLASS="Untitled">
<A NAME="pgfId=177326">
 </A>	int = 	getegid()</P>
<P CLASS="Untitled">
<A NAME="pgfId=177327">
 </A>		kill(int, int)</P>
<P CLASS="Untitled">
<A NAME="pgfId=177328">
 </A>		link(string, string)</P>
<P CLASS="Untitled">
<A NAME="pgfId=177329">
 </A>		mkdir(string, int)</P>
<P CLASS="Untitled">
<A NAME="pgfId=177330">
 </A>		mknod(string, int, int)</P>
<P CLASS="Untitled">
<A NAME="pgfId=177331">
 </A>		nice(int)</P>
<P CLASS="Untitled">
<A NAME="pgfId=177332">
 </A>		pause()</P>
<P CLASS="Untitled">
<A NAME="pgfId=177335">
 </A>		rmdir(string)</P>
<P CLASS="Untitled">
<A NAME="pgfId=177336">
 </A>		setpgrp()</P>
<P CLASS="Untitled">
<A NAME="pgfId=177337">
 </A>		setuid(int)</P>
<P CLASS="Untitled">
<A NAME="pgfId=177338">
 </A>		setgid(int)</P>
<P CLASS="Untitled">
<A NAME="pgfId=177339">
 </A>		signal(int, int)</P>
<P CLASS="Untitled">
<A NAME="pgfId=177340">
 </A>		sync()</P>
<P CLASS="Untitled">
<A NAME="pgfId=177343">
 </A>		ulimit(int, int)</P>
<P CLASS="Untitled">
<A NAME="pgfId=177345">
 </A>		umask(int)</P>
<P CLASS="Untitled">
<A NAME="pgfId=177347">
 </A>		unlink(string)</P>
<P CLASS="Untitled">
<A NAME="pgfId=177354">
 </A>		clock()</P>
<P CLASS="Untitled">
<A NAME="pgfId=177355">
 </A>		system(string)</P>
<P CLASS="Untitled">
<A NAME="pgfId=177357">
 </A>		lockf(int, int, int)</P>
<P CLASS="Untitled">
<A NAME="pgfId=177359">
 </A>		sleep(int)</P>
<P CLASS="Untitled">
<A NAME="pgfId=180115">
 </A>	int =	spawn([int, ] string, string...)</P>
<P CLASS="Untitled">
<A NAME="pgfId=180116">
 </A>	int =	spawn([int, ] string, array)</P>
<P CLASS="Untitled">
<A NAME="pgfId=180112">
 </A>		rename(string, string)</P>
<P CLASS="Untitled">
<A NAME="pgfId=180113">
 </A>	struct =	passwd(int|string)</P>
<P CLASS="Untitled">
<A NAME="pgfId=180114">
 </A>	array =	passwd()</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=177949">
 </A><CODE CLASS="CourierBold">
int = access(string </CODE>
<I CLASS="+Italic">
[</I>
<CODE CLASS="CourierBold">
, int</CODE>
<I CLASS="+Italic">
]</I>
<CODE CLASS="CourierBold">
)</CODE>
</H4>
<P CLASS="Body">
<A NAME="pgfId=178002">
 </A>Call the access(2) function to determine the accessibility of a file. The first parameter is the pathname of the file system object to be tested. The second, optional, parameter is the <I CLASS="+Italic">
mode</I>
 (a bitwise combination of R_OK, W_OK and X_OK or the special value, F_OK). If <I CLASS="+Italic">
mode</I>
 is not passed F_OK is assumed. Access returns 0 if the file system object is accessible. Also supported on WIN32 platforms.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=177950">
 </A><CODE CLASS="CourierBold">
int = creat(string, int)</CODE>
</H4>
<P CLASS="Body">
<A NAME="pgfId=178030">
 </A>Create a new ordinary file with the given pathname and mode (permissions etc...) and return the file descriptor, open for writing, for the file. Also supported on WIN32 platforms.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=180344">
 </A><CODE CLASS="CourierBold">
array = dir([string,] [string,] [regexp])</CODE>
</H4>
<P CLASS="Body">
<A NAME="pgfId=180345">
 </A>The dir() function is used to read the contents of directories. It returns an array of strings being the names found in the directory. The first string parameter names a directory to read and defaults to &quot;.&quot; -- the current directory. The second string parameter controls which names are returned. It may be one of &quot;f&quot; -- return only the names of files, &quot;d&quot; -- return the names of sub-directories, or &quot;a&quot; -- return the names of all objects in the directory. The regexp parameter, if passed, is used to filter the returned names. Only names that match the regexp are returned. Note that when using dir() to traverse directory hierarchies that the &quot;.&quot; and &quot;..&quot; names are returned when listing the names of sub-directories, these will need to be avoided when traversing.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=180292">
 </A><CODE CLASS="CourierBold">
int = dup(int </CODE>
<I CLASS="+Italic">
[</I>
<CODE CLASS="CourierBold">
, int</CODE>
<I CLASS="+Italic">
]</I>
<CODE CLASS="CourierBold">
)</CODE>
</H4>
<P CLASS="Body">
<A NAME="pgfId=178089">
 </A>Duplicate a file descriptor by calling dup(2) or dup2(2) and return a new descriptor. If only a single parameter is passed dup(2) is called otherwise dup2(2) is called. Also supported on WIN32 platforms.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178051">
 </A><CODE CLASS="CourierBold">
exec(string, array)</CODE>
</H4>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178054">
 </A><CODE CLASS="CourierBold">
exec(string, string...)</CODE>
</H4>
<P CLASS="Body">
<A NAME="pgfId=178099">
 </A>Execute a new program in the current process. The first parameter to exec is the pathname of an executable file (the program). The remaining parameters are either; an array of strings defining the parameters to be passed to the program, or, a variable number of strings that are passed, in order, to the program as its parameters. The first form is similar to C's execv function and the second form to C's execl functions. Note that no searching of the user's path is performed and the environment passed to the program is that of the current process (i.e., both are implemented by calls to execv(2)). This function is available on Win32 platforms</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178057">
 </A><CODE CLASS="CourierBold">
int = lseek(int, int </CODE>
<I CLASS="+Italic">
[</I>
<CODE CLASS="CourierBold">
, int</CODE>
<I CLASS="+Italic">
]</I>
<CODE CLASS="CourierBold">
)</CODE>
</H4>
<P CLASS="Body">
<A NAME="pgfId=178250">
 </A>Set the read/write position for an open file. The first parameter is the file descriptor associated with the file system object, the second parameter the offset. The third is the <I CLASS="+Italic">
whence</I>
 value which determines how the new file position is calculated. The whence value may be one of SEEK_SET, SEEK_CUR or SEEK_END and defaults to SEEK_SET if not specified. Also supported on WIN32 platforms.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178060">
 </A><CODE CLASS="CourierBold">
int = open(string, int </CODE>
<I CLASS="+Italic">
[</I>
<CODE CLASS="CourierBold">
, int</CODE>
<I CLASS="+Italic">
]</I>
<CODE CLASS="CourierBold">
)</CODE>
</H4>
<P CLASS="Body">
<A NAME="pgfId=178251">
 </A>Open the named file for reading or writing depending upon the value of the second parameter, <I CLASS="+Italic">
flags</I>
, and return a file descriptor. The second parameter is a bitwise combination of the various O_ values (see above) and if this set includes the O_CREAT flag a third parameter, <I CLASS="+Italic">
mode</I>
, <B CLASS="+Bold">
must</B>
 also be supplied. Also supported on WIN32 platforms.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178063">
 </A><CODE CLASS="CourierBold">
array = pipe()</CODE>
</H4>
<P CLASS="Body">
<A NAME="pgfId=178252">
 </A>Create a pipe and return an array containing two, integer, file descriptors used to refer to the input and output endpoints of the pipe.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178066">
 </A><CODE CLASS="CourierBold">
struct = stat(string|int|file)</CODE>
</H4>
<P CLASS="Body">
<A NAME="pgfId=178253">
 </A>Obtain information on the named file system object, file descriptor or file underlying an ICI file object and return a struct containing that information. If the parameter is a file object that file object must refer to a file opened with ICI's <CODE CLASS="CourierBold">
fopen</CODE>
 function. The returned struct contains the following keys (which have the same names as the fields of the Unix statbuf structure with the leading &quot;st_&quot; prefix removed),</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=178311"></A>dev</PRE>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=178371"></A>ino</PRE>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=178314"></A>mode</PRE>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=178315"></A>nlink</PRE>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=178317"></A>uid</PRE>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=178344"></A>gid</PRE>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=178318"></A>rdev</PRE>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=178319"></A>size</PRE>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=178320"></A>atime</PRE>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=178321"></A>mtime</PRE>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=178322"></A>ctime</PRE>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=178323"></A>blksize</PRE>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=178324"></A>blocks</PRE>
<P CLASS="Body">
<A NAME="pgfId=178372">
 </A>&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId=178375">
 </A>All values are integers. Also supported on WIN32 platforms.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178108">
 </A><CODE CLASS="CourierBold">
int = wait()</CODE>
</H4>
<P CLASS="Body">
<A NAME="pgfId=178254">
 </A>Wait until a signal is received or a child process terminates or stops due to tracing and return the status returned by system call.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178111">
 </A><CODE CLASS="CourierBold">
string = ctime(int)</CODE>
</H4>
<P CLASS="Body">
<A NAME="pgfId=178255">
 </A>Convert a time value (see time, below) to a string of the form &quot;Sun Sep 16 01:03:52 1973\n&quot; and return that string. This is primarily of use when converting the time values returned by stat. Also supported on WIN32 platforms.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178114">
 </A><CODE CLASS="CourierBold">
int = time()</CODE>
</H4>
<P CLASS="Body">
<A NAME="pgfId=178256">
 </A>Return the time since 00:00:00 GMT,  Jan.  1,  1970, measured in seconds.  Also supported on WIN32 platforms.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178117">
 </A><CODE CLASS="CourierBold">
file = fdopen(int </CODE>
<I CLASS="+Italic">
[</I>
<CODE CLASS="CourierBold">
, mode</CODE>
<I CLASS="+Italic">
]</I>
<CODE CLASS="CourierBold">
)</CODE>
</H4>
<P CLASS="Body">
<A NAME="pgfId=178257">
 </A>Returns a file object that can be used to perform I/O on the specified file descriptor. The file is opened for reading or writing according to <I CLASS="+Italic">
mode</I>
 (see <I CLASS="+Italic">
fopen</I>
). If mode is specified <CODE CLASS="CourierBold">
&quot;r&quot;</CODE>
 (reading) is assumed.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178120">
 </A><CODE CLASS="CourierBold">
string = getcwd()</CODE>
</H4>
<P CLASS="Body">
<A NAME="pgfId=180077">
 </A>Returns the name of the current working directory. Also supported on WIN32 platforms.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=180076">
 </A><CODE CLASS="CourierBold">
alarm(int)</CODE>
</H4>
<P CLASS="Body">
<A NAME="pgfId=178261">
 </A>Schedule a SIGALRM signal to be posted to the current process in the specified number of seconds. If the parameter is zero any alarm is cancelled.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178123">
 </A><CODE CLASS="CourierBold">
acct(string)</CODE>
</H4>
<P CLASS="Body">
<A NAME="pgfId=178262">
 </A>Enable accounting on the specified file.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178126">
 </A><CODE CLASS="CourierBold">
chdir(string)</CODE>
</H4>
<P CLASS="Body">
<A NAME="pgfId=178263">
 </A>Change the process's current working directory to the specified path. Also supported on WIN32 platforms.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178129">
 </A><CODE CLASS="CourierBold">
chmod(string, int)</CODE>
</H4>
<P CLASS="Body">
<A NAME="pgfId=178264">
 </A>Change the mode of a file system object.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178132">
 </A><CODE CLASS="CourierBold">
chown(string, int, int)</CODE>
</H4>
<P CLASS="Body">
<A NAME="pgfId=178265">
 </A>Change the owner and group identifiers for a file system object.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178135">
 </A><CODE CLASS="CourierBold">
chroot(string)</CODE>
</H4>
<P CLASS="Body">
<A NAME="pgfId=178266">
 </A>Change root directory for process.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178138">
 </A><CODE CLASS="CourierBold">
_close(int)</CODE>
</H4>
<P CLASS="Body">
<A NAME="pgfId=178267">
 </A>Close a file descriptor. Also supported on WIN32 platforms.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178141">
 </A><CODE CLASS="CourierBold">
_exit(int)</CODE>
</H4>
<P CLASS="Body">
<A NAME="pgfId=178268">
 </A>Exit the current process returning an integer exit status to the parent. Also supported on WIN32 platforms.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178144">
 </A><CODE CLASS="CourierBold">
int = fork()</CODE>
</H4>
<P CLASS="Body">
<A NAME="pgfId=178269">
 </A>Create a new process. In the parent this returns the process identifier for the newly created process. In the newly created process it returns zero.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178150">
 </A><CODE CLASS="CourierBold">
int = getpid()</CODE>
</H4>
<P CLASS="Body">
<A NAME="pgfId=178270">
 </A>Get the process identifier for the current process.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178154">
 </A><CODE CLASS="CourierBold">
int = getpgrp()</CODE>
</H4>
<P CLASS="Body">
<A NAME="pgfId=178271">
 </A>Get the current process group identifier.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178159">
 </A><CODE CLASS="CourierBold">
int = getppid()</CODE>
</H4>
<P CLASS="Body">
<A NAME="pgfId=178272">
 </A>Get the parent process identifier.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178164">
 </A><CODE CLASS="CourierBold">
int = getuid()</CODE>
</H4>
<P CLASS="Body">
<A NAME="pgfId=178273">
 </A>Get the real user identifier of the owner of the current process.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178167">
 </A><CODE CLASS="CourierBold">
int = geteuid()</CODE>
</H4>
<P CLASS="Body">
<A NAME="pgfId=178274">
 </A>Get the effective user identifier for the owner of the current process.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178170">
 </A><CODE CLASS="CourierBold">
int = getgid()</CODE>
</H4>
<P CLASS="Body">
<A NAME="pgfId=178275">
 </A>Get the real group identifier for the current process.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178173">
 </A><CODE CLASS="CourierBold">
int = getegid()</CODE>
</H4>
<P CLASS="Body">
<A NAME="pgfId=178276">
 </A>Get the effective group identifier for the current process.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178176">
 </A><CODE CLASS="CourierBold">
kill(int, int)</CODE>
</H4>
<P CLASS="Body">
<A NAME="pgfId=178277">
 </A>Post a signal to a process.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178179">
 </A><CODE CLASS="CourierBold">
link(string, string)</CODE>
</H4>
<P CLASS="Body">
<A NAME="pgfId=178278">
 </A>Create a link to an existing file.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178182">
 </A><CODE CLASS="CourierBold">
mkdir(string, int)</CODE>
</H4>
<P CLASS="Body">
<A NAME="pgfId=178279">
 </A>Create a directory with the specified mode. Also supported on WIN32 platforms.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178185">
 </A><CODE CLASS="CourierBold">
mknod(string, int, int)</CODE>
</H4>
<P CLASS="Body">
<A NAME="pgfId=178280">
 </A>Create a special file.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178188">
 </A><CODE CLASS="CourierBold">
nice(int)</CODE>
</H4>
<P CLASS="Body">
<A NAME="pgfId=178281">
 </A>Change the <I CLASS="+Italic">
nice</I>
 value of a process.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178191">
 </A><CODE CLASS="CourierBold">
pause()</CODE>
</H4>
<P CLASS="Body">
<A NAME="pgfId=178282">
 </A>Wait until a signal is delivered to the process.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178194">
 </A><CODE CLASS="CourierBold">
rmdir(string)</CODE>
</H4>
<P CLASS="Body">
<A NAME="pgfId=178283">
 </A>Remove a directory. Also supported on WIN32 platforms.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178197">
 </A><CODE CLASS="CourierBold">
setpgrp()</CODE>
</H4>
<P CLASS="Body">
<A NAME="pgfId=178287">
 </A>Set the process group.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178200">
 </A><CODE CLASS="CourierBold">
setuid(int)</CODE>
</H4>
<P CLASS="Body">
<A NAME="pgfId=178288">
 </A>Set the real and effective user identifier for the current process.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178203">
 </A><CODE CLASS="CourierBold">
setgid(int)</CODE>
</H4>
<P CLASS="Body">
<A NAME="pgfId=178289">
 </A>Set the real and effective group identifier for the current process.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178206">
 </A><CODE CLASS="CourierBold">
signal(int, int)</CODE>
</H4>
<P CLASS="Body">
<A NAME="pgfId=178290">
 </A>Control signal handling in the process. Note at present handlers cannot be installed so signals are of limited use in ICI programs.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178209">
 </A><CODE CLASS="CourierBold">
sync()</CODE>
</H4>
<P CLASS="Body">
<A NAME="pgfId=178291">
 </A>Schedule in-memory file data to be written to disk.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178212">
 </A><CODE CLASS="CourierBold">
ulimit(int, int)</CODE>
</H4>
<P CLASS="Body">
<A NAME="pgfId=178292">
 </A>Get and set user limits.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178215">
 </A><CODE CLASS="CourierBold">
umask(int)</CODE>
</H4>
<P CLASS="Body">
<A NAME="pgfId=178293">
 </A>Set file creation mask.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178218">
 </A><CODE CLASS="CourierBold">
unlink(string)</CODE>
</H4>
<P CLASS="Body">
<A NAME="pgfId=178294">
 </A>Remove a file. Also supported on WIN32 platforms.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178224">
 </A><CODE CLASS="CourierBold">
system(string)</CODE>
</H4>
<P CLASS="Body">
<A NAME="pgfId=178296">
 </A>Execute a system command and return its exit status. Also supported on WIN32 platforms however using the system's command interpreter.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178230">
 </A><CODE CLASS="CourierBold">
sleep(int)</CODE>
</H4>
<P CLASS="Body">
<A NAME="pgfId=178298">
 </A>Suspend the process for the specified number of seconds.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=180117">
 </A>int = spawn([mode,] string, string...)</H4>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=180121">
 </A>int = spawn([mode, ] string, array)</H4>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=180146">
 </A>int = spawnp([mode,] string, string...)</H4>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=180147">
 </A>int = spawnp([mode, ] string, array)</H4>
<P CLASS="Body">
<A NAME="pgfId=180123">
 </A>Spawn a sub-process. The parameters, other than mode, are as for exec - the string is the name of the executable and the remaining parameters form the command line arguments passed to the executable.</P>
<P CLASS="Body">
<A NAME="pgfId=180126">
 </A>The mode parameter controls whether or not the parent process waits for the spawned process to termiante. If mode is _P_WAIT the call to spawn returns when the process terminates and the result of spawn is the process exit status. If mode is not passed or is _P_NOWAIT the call to spawn returns prior to the process terminating and the result is the Win32 process handle for the new process.</P>
<P CLASS="Body">
<A NAME="pgfId=180148">
 </A>The <I CLASS="+Italic">
spawnp</I>
 variant will search the directories listed in the PATH environment variable for the executable program. In all other respects it is indentical to spawn.</P>
<P CLASS="Body">
<A NAME="pgfId=180127">
 </A>This function is only available on Win32 platforms.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=180120">
 </A>rename(string, string)</H4>
<P CLASS="Body">
<A NAME="pgfId=180118">
 </A>Change the name of a file. The first parameter is the name of an existing file and the second is the new name that it is to be given.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=180130">
 </A>struct = passwd(int | string)</H4>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=180131">
 </A>array = passwd()</H4>
<P CLASS="Body">
<A NAME="pgfId=180132">
 </A>The passwd() function accesses the Unix password file (which may or may not be an actual file according to the local system configuration). With no parameters passwd() returns an array of all password file entries, each entry is a struct. With a parameter passwd() returns the entry for the specific user id., int parameter, or user name, string parameter. A password file entry is a struct with the following keys and values,</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=180133"></A>name			The user's login name, a string.</PRE>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=180134"></A>passwd			The user's encrypted password, a string. Note that some systems protect this (shadow password files) and this field may not be an actual encrypted password.</PRE>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=180135"></A>uid			The user id., an int.</PRE>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=180136"></A>gid			The user's default group, an int.</PRE>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=180137"></A>gecos			The so-called gecos field, a string.</PRE>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=180138"></A>dir			The user's home directory, a string.</PRE>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=180139"></A>shell			The user's shell (initial program), a string.</PRE>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=180140"></A>&nbsp;</PRE>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178233">
 </A>Sockets Interface</H4>
<P CLASS="Body">
<A NAME="pgfId=177242">
 </A>The <I CLASS="+Italic">
sockets</I>
 extension is available on systems that provide BSD-compatible sockets calls and for Win32 platforms. The extension allows ICI programs to access network functions. The sockets extension is generally compatible with the C sockets functions but uses types and calling semantics more akin to the ICI environment.</P>
<P CLASS="Body">
<A NAME="pgfId=178645">
 </A>The sockets extension introduces a new type, <I CLASS="+Italic">
socket</I>
, to hold socket objects. The new intrinsic function, <I CLASS="+Italic">
socket</I>
, returns a socket object.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178713">
 </A>Network Addresses</H4>
<P CLASS="Body">
<A NAME="pgfId=178720">
 </A>The sockets interfaces specifies IP network addresses using strings. Network addresses are of the form <I CLASS="+Italic">
port</I>
<B CLASS="+Bold">
@</B>
<I CLASS="+Italic">
 host</I>
 where the @host part is optional. The port may be specified as an integer number or a string which is looked up in the services database. If the port is a service name it may be in the form <I CLASS="+Italic">
name</I>
<B CLASS="+Bold">
/</B>
<I CLASS="+Italic">
protocol</I>
 with protocol being either <I CLASS="+Italic">
tcp</I>
 or <I CLASS="+Italic">
udp</I>
. The host portion of the address may be a domain name, an IP address in dotted decimal notation or one of the special addresses local (&quot;.&quot; - dot), any (&quot;?&quot;) or all (&quot;*&quot;). If the host portion is omitted the default host depends on the context. See the descriptions of the <I CLASS="+Italic">
connect</I>
 and <I CLASS="+Italic">
bind</I>
 functions below.</P>
<P CLASS="Body">
<A NAME="pgfId=178636">
 </A>The following list summarises the sockets interface functions. Following this is a detailed descriptions of each of them.</P>
<P CLASS="Untitled">
<A NAME="pgfId=177216">
 </A>	skt = 	socket(string)</P>
<P CLASS="Untitled">
<A NAME="pgfId=177371">
 </A>	skt = 	listen(skt)</P>
<P CLASS="Untitled">
<A NAME="pgfId=177372">
 </A>	skt = 	accept(skt)</P>
<P CLASS="Untitled">
<A NAME="pgfId=177373">
 </A>	skt = 	connect(skt, string)</P>
<P CLASS="Untitled">
<A NAME="pgfId=177374">
 </A>	skt = 	bind(skt, string)</P>
<P CLASS="Untitled">
<A NAME="pgfId=177375">
 </A>	struct = 	select([int,] set [, set [, set]])</P>
<P CLASS="Untitled">
<A NAME="pgfId=177376">
 </A>	int = 	getsockopt(skt, string)</P>
<P CLASS="Untitled">
<A NAME="pgfId=177377">
 </A>		setsockopt(skt, string, int)</P>
<P CLASS="Untitled">
<A NAME="pgfId=177378">
 </A>	string = 	domainname()</P>
<P CLASS="Untitled">
<A NAME="pgfId=177379">
 </A>	string = 	hostname()</P>
<P CLASS="Untitled">
<A NAME="pgfId=177380">
 </A>	string = 	username([int])</P>
<P CLASS="Untitled">
<A NAME="pgfId=177381">
 </A>	string = 	getpeername(skt)</P>
<P CLASS="Untitled">
<A NAME="pgfId=177382">
 </A>	string = 	getsockname(skt)</P>
<P CLASS="Untitled">
<A NAME="pgfId=177383">
 </A>		sendto(skt, string, string)</P>
<P CLASS="Untitled">
<A NAME="pgfId=177384">
 </A>	struct = 	recvfrom(skt, int)</P>
<P CLASS="Untitled">
<A NAME="pgfId=177385">
 </A>		send(skt, string)</P>
<P CLASS="Untitled">
<A NAME="pgfId=177386">
 </A>	string = 	recv(skt, int)</P>
<P CLASS="Untitled">
<A NAME="pgfId=177387">
 </A>	int = 	getportno(skt)</P>
<P CLASS="Untitled">
<A NAME="pgfId=177388">
 </A>	string = 	gethostbyname(string)</P>
<P CLASS="Untitled">
<A NAME="pgfId=177390">
 </A>	int = 	sktno(skt)</P>
<P CLASS="Untitled">
<A NAME="pgfId=177391">
 </A>	file = 	sktopen(skt [, mode])</P>
<P CLASS="Untitled">
<A NAME="pgfId=180028">
 </A>	array =	socketpair()</P>
<P CLASS="Untitled">
<A NAME="pgfId=180029">
 </A>&nbsp;</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178728">
 </A>skt = socket(string)</H4>
<P CLASS="Body">
<A NAME="pgfId=178729">
 </A>Create and return a new socket object of the specified protocol. The string, the protocol, may be one of <I CLASS="+Italic">
tcp</I>
 or <I CLASS="+Italic">
udp</I>
. For example,</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=178742"></A>skt = socket(&quot;tcp&quot;);</PRE>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178730">
 </A>skt = accept(skt)</H4>
<P CLASS="Body">
<A NAME="pgfId=178754">
 </A>Accept a connection to a TCP socket and return a new socket for that connection.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178753">
 </A>skt = listen(skt)</H4>
<P CLASS="Body">
<A NAME="pgfId=178731">
 </A>Allow connections to a TCP socket. Returns the socket passed.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178732">
 </A>skt = connect(skt, address)</H4>
<P CLASS="Body">
<A NAME="pgfId=178733">
 </A>Establish a TCP connection to the specified address or associate the address with as the destination for messages on a UDP socket. If the host portion of the address is not specified &quot;.&quot; (dot) is used to connect to the local host. The original socket is returned.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178740">
 </A>skt = bind(skt [, address|int])</H4>
<P CLASS="Body">
<A NAME="pgfId=178741">
 </A>Associate a local address for the socket (TCP or UDP). If the address is not specified the system selects an unused local port number for the socket. If the host portion of the address is not specified &quot;?&quot; (any) is used. If the address is passed as an integer it specifies the port number to be bound, the host portion is &quot;?&quot;. Bind returns the socket parameter.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178762">
 </A>struct = select([int,] set|NULL [, set|NULL [, set|NULL]])</H4>
<P CLASS="Body">
<A NAME="pgfId=178763">
 </A>Check sockets for I/O readiness with optional timeout. Select may be passed up to three sets of sockets that are checked for readiness to perform I/O. The first set holds the sockets to test for input pending, the second set the sockets to test for output able and the third set the sockets to test for exceptional states. NULL may be passed in place of a set parameter to avoid passing empty sets. An integer may also appear in the parameter list. This integer specifies the number of milliseconds to wait for the sockets to become ready. If a zero timeout is passed the sockets are polled to test their state. If no timeout is passed the call blocks until at least one of the sockets is ready for I/O.</P>
<P CLASS="Body">
<A NAME="pgfId=178775">
 </A>The result of select is a struct containing three sets, of sockets, identified by the keys <CODE CLASS="+Code">
read</CODE>
, <CODE CLASS="+Code">
write</CODE>
 and <CODE CLASS="+Code">
except</CODE>
.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178788">
 </A>int = getsockopt(skt, string, int)</H4>
<P CLASS="Body">
<A NAME="pgfId=178789">
 </A>Retrieve the value of a socket <I CLASS="+Italic">
option</I>
. A socket may have various attributes associated with it. These are accessed via the getsockopt and setsockopt functions. The attributes are identified using string keys from the following list,</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=178793"></A>debug</PRE>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=178796"></A>reuseaddr</PRE>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=178797"></A>keepalive</PRE>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=178798"></A>dontroute</PRE>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=178799"></A>useloopback</PRE>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=178800"></A>linger</PRE>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=178801"></A>broadcast</PRE>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=178802"></A>oobinline</PRE>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=178803"></A>sndbuf</PRE>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=178804"></A>rcvbuf</PRE>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=178805"></A>type</PRE>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=178806"></A>error</PRE>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178851">
 </A>&nbsp;</H4>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178852">
 </A>setsockopt(skt, string, int)</H4>
<P CLASS="Body">
<A NAME="pgfId=178853">
 </A>Set a socket option (see getsockopt for option names) to the integer value.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178854">
 </A>string = domainname()</H4>
<P CLASS="Body">
<A NAME="pgfId=178855">
 </A>Return the domain name of the current host.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178856">
 </A>string = hostname()</H4>
<P CLASS="Body">
<A NAME="pgfId=178857">
 </A>Return the name of the current host.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178858">
 </A>string = username([int])</H4>
<P CLASS="Body">
<A NAME="pgfId=178859">
 </A>Return the name of the owner of the current process or if an integer, user number, is passed, of that user.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178860">
 </A>string = getpeername(skt)</H4>
<P CLASS="Body">
<A NAME="pgfId=178861">
 </A>Return the address of the <I CLASS="+Italic">
peer</I>
 of a TCP socket.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178865">
 </A>string = getsockname(skt)</H4>
<P CLASS="Body">
<A NAME="pgfId=178866">
 </A>Return the local address of a socket.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178870">
 </A>sendto(skt, string, string)</H4>
<P CLASS="Body">
<A NAME="pgfId=178871">
 </A>Send the data in the second parameter to the specified address.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178872">
 </A>array = socketpair()</H4>
<P CLASS="Body">
<A NAME="pgfId=180031">
 </A>Returns an array containing a pair of connected sockets.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=180030">
 </A>struct = recvfrom(skt, int)</H4>
<P CLASS="Body">
<A NAME="pgfId=178873">
 </A>Receive a message on a socket and return a struct containing the data of the message, in string, and the source address of the data. The int parameter gives the maximum number of bytes to receive. The result is a struct with the keys <CODE CLASS="+Code">
msg</CODE>
 and <CODE CLASS="+Code">
addr</CODE>
 used to access the returned information.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178876">
 </A>send(skt, string)</H4>
<P CLASS="Body">
<A NAME="pgfId=178877">
 </A>Send the content of the string on a socket.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178878">
 </A>string = recv(skt, int)</H4>
<P CLASS="Body">
<A NAME="pgfId=178881">
 </A>Receive data from a socket and return it as a string. The int parameter fives the maximum size of message that will be received.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178885">
 </A>int = getportno(skt)</H4>
<P CLASS="Body">
<A NAME="pgfId=178889">
 </A>Return the local port number assigned to a TCP or UDP socket.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178890">
 </A>string = gethostbyname(string)</H4>
<P CLASS="Body">
<A NAME="pgfId=178891">
 </A>Match a network address against the hosts database and return a hostname.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178892">
 </A>int = sktno(skt)</H4>
<P CLASS="Body">
<A NAME="pgfId=178893">
 </A>Return the file descriptor associated with a socket.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=178894">
 </A>file = sktopen(skt [, mode])</H4>
<P CLASS="Body">
<A NAME="pgfId=178895">
 </A>Open a socket as a file, for input or output according to <I CLASS="+Italic">
mode</I>
 (see <I CLASS="+Italic">
fopen</I>
). This function is not available on WIN32 platforms.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=179113">
 </A>Regular Expression Syntax</H4>
<P CLASS="Body">
<A NAME="pgfId=183099">
 </A>ICI uses Philip Hazel's PCRE (Perl-compatible regular expressions) package.  The following is extracted from the file pcre.3.txt included with the PCRE distribution.  This document is intended to be used with the PCRE C functions and makes reference to a number of constants that may be used as option specifiers to the C functions (all such constants are prefixed with the string &quot;PCRE_&quot;).  These constants are not available in the ICI interface at time of writing although the regexp() function does allow a numeric option specific to be passed.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184287">
 </A><A NAME="35920">
 </A>The syntax and semantics of the regular expressions supported by PCRE are described below. Regular expressions are also described in the Perl documentation and in a number of other books, some of which have copious examples. Jeffrey Friedl's &quot;Mastering Regular Expressions&quot;, published by O'Reilly (ISBN 1-56592-257-3), covers them in great detail.  The description here is intended as reference documentation.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184292">
 </A>A regular expression is a pattern that is matched against a subject string from left to right. Most characters stand for themselves in a pattern, and match the corresponding characters in the subject. As a trivial example, the pattern</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184293">
 </A>  The quick brown fox</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184294">
 </A>matches a portion of a subject string that is identical to itself. The power of regular expressions comes from the ability to include alternatives and repetitions in the pattern.  These are encoded in the pattern by the use of meta-characters, which do not stand for themselves but instead are interpreted in some special way.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184295">
 </A>There are two different sets of meta-characters: those  that are  recognized anywhere in the pattern except within square brackets, and those that are recognized in square  brackets. Outside square brackets, the meta-characters are as follows:</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184296">
 </A>  \      general escape character with several uses</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184297">
 </A>  ^      assert start of  subject  (or  line,  in  multiline mode)</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184298">
 </A>  $      assert end of subject (or line, in multiline mode)</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184299">
 </A>  .      match any character except newline (by default)</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184300">
 </A>  [      start character class definition</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184301">
 </A>  |      start of alternative branch</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184302">
 </A>  (      start subpattern</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184303">
 </A>  )      end subpattern</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184304">
 </A>  ?      extends the meaning of (</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184592">
 </A>          also 0 or 1 quantifier</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184593">
 </A>          also quantifier minimizer</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184305">
 </A>  *      0 or more quantifier</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184306">
 </A>  +      1 or more quantifier</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184307">
 </A>  {      start min/max quantifier</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184308">
 </A>Part of a pattern that is in square brackets is called a &quot;character class&quot;.  In a character class the only meta-characters are:</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184309">
 </A>  \      general escape character</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184310">
 </A>  ^      negate the class, but only if the first character</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184311">
 </A>  -      indicates character range</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184312">
 </A>  ]      terminates the character class</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184313">
 </A>The following sections describe  the  use  of  each  of  the meta-characters.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184315">
 </A>BACKSLASH</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184316">
 </A>The backslash character has several uses. Firstly, if it  is followed  by  a  non-alphameric character, it takes away any special  meaning  that  character  may  have.  This  use  of backslash  as  an  escape  character applies both inside and outside character classes.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184317">
 </A>For example, if you want to match a &quot;*&quot; character, you write &quot;\*&quot; in the pattern. This applies whether or not the following character would otherwise be interpreted as a meta-character, so it is always safe to precede a non-alphameric with &quot;\&quot; to specify that it stands for itself.  In particular, if you want to match a backslash, you write &quot;\\&quot;.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184318">
 </A>If a pattern is compiled with the PCRE_EXTENDED option, whitespace in the pattern (other than in a character class) and characters between a &quot;#&quot; outside a character class and the next newline character are ignored. An escaping backslash can be used to include a whitespace or &quot;#&quot; character as part of the pattern.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184319">
 </A>A second use of backslash provides a way of encoding non-printing characters in patterns in a visible manner. There is no restriction on the appearance of non-printing characters, apart from the binary zero that terminates a pattern, but when a pattern is being prepared by text editing, it is usually easier to use one of the following escape sequences than the binary character it represents:</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184320">
 </A>  \a     alarm, that is, the BEL character (hex 07)</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184321">
 </A>  \cx    &quot;control-x&quot;, where x is any character</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184322">
 </A>  \e     escape (hex 1B)</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184323">
 </A>  \f     formfeed (hex 0C)</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184324">
 </A>  \n     newline (hex 0A)</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184325">
 </A>  \r     carriage return (hex 0D)</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184326">
 </A>  \t     tab (hex 09)</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184327">
 </A>  \xhh   character with hex code hh</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184328">
 </A>  \ddd   character with octal code ddd, or backreference</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184329">
 </A>The precise effect of &quot;\cx&quot; is as follows: if &quot;x&quot; is a lower case  letter,  it  is converted to upper case. Then bit 6 of the character (hex 40) is inverted.  Thus &quot;\cz&quot; becomes  hex 1A, but &quot;\c{&quot; becomes hex 3B, while &quot;\c;&quot; becomes hex 7B.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184330">
 </A>After &quot;\x&quot;, up to two hexadecimal digits are  read  (letters can be in upper or lower case).</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184331">
 </A>After &quot;\0&quot; up to two further octal digits are read. In  both cases,  if  there are fewer than two digits, just those that are present are used. Thus the sequence &quot;\0\x\07&quot;  specifies two binary zeros followed by a BEL character.  Make sure you supply two digits after the initial zero  if  the  character that follows is itself an octal digit.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184332">
 </A>The handling of a backslash followed by a digit other than 0 is  complicated.   Outside  a character class, PCRE reads it and any following digits as a decimal number. If the  number is  less  than  10, or if there have been at least that many previous capturing left parentheses in the  expression,  the entire  sequence is taken as a back reference. A description of how this works is given later, following  the  discussion of parenthesized subpatterns.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184333">
 </A>Inside a character class, or if the decimal number is greater than 9 and there have not been that many capturing subpatterns, PCRE re-reads up to three octal digits following the backslash, and generates a single byte from the least significant 8 bits of the value. Any subsequent digits stand for themselves.  For example:</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184597">
 </A>  \040   is another way of writing a space</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184598">
 </A>  \40    is the same, provided there are fewer than 40             previous capturing subpatterns</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184599">
 </A>  \7     is always a back reference</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184337">
 </A>  \11    might be a back reference, or another way of             writing a tab</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184338">
 </A>  \011   is always a tab</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184339">
 </A>  \0113  is a tab followed by the character &quot;3&quot;</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184340">
 </A>  \113   is the character with octal code 113 (since there             can be no more than 99 back references)</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184341">
 </A>  \377   is a byte consisting entirely of 1 bits</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184342">
 </A>  \81    is either a back reference, or a binary zero followed by the two characters &quot;8&quot; and &quot;1&quot;</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184343">
 </A>Note that octal values of 100 or greater must not be introduced by a leading zero, because no more than three octal digits are ever read.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184344">
 </A>All the sequences that define a single  byte  value  can  be used both inside and outside character classes. In addition, inside a character class, the sequence &quot;\b&quot;  is  interpreted as  the  backspace  character  (hex 08). Outside a character class it has a different meaning (see below).</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184345">
 </A>The third use of backslash is for specifying generic character types:</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184346">
 </A>  \d     any decimal digit</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184347">
 </A>  \D     any character that is not a decimal digit any whitespace character</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184348">
 </A>  \S     any character that is not a whitespace character</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184349">
 </A>  \w     any &quot;word&quot; character</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184350">
 </A>  \W     any &quot;non-word&quot; character</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184351">
 </A>Each pair of escape sequences partitions the complete set of characters  into  two  disjoint  sets.  Any  given character matches one, and only one, of each pair.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184352">
 </A>A &quot;word&quot; character is any letter or digit or the underscore character, that is, any character which can be part of a Perl &quot;word&quot;. The definition of letters and digits is controlled by PCRE's character tables, and may vary if locale-specific matching is taking place (see &quot;Locale support&quot; above). For example, in the &quot;fr&quot; (French) locale, some character codes greater than 128 are used for accented letters, and these are matched by \w.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184353">
 </A>These character type sequences can appear  both  inside  and outside  character classes. They each match one character of the appropriate type. If the current matching  point  is  at the end of the subject string, all of them fail, since there is no character to match.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184354">
 </A>The fourth use of backslash is for certain simple assertions. An assertion specifies a condition that has to be met at a particular point in a match, without consuming any characters from the subject string. The use of subpatterns for more complicated assertions is described below.  The backslashed assertions are</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184355">
 </A>  \b     word boundary</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184356">
 </A>  \B     not a word boundary</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184357">
 </A>  \A     start of subject (independent of multiline mode)</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184358">
 </A>  \Z     end of subject or newline at  end  (independent  of multiline mode)</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184359">
 </A>  \z     end of subject (independent of multiline mode)</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184360">
 </A>These assertions may not appear in  character  classes  (but note that &quot;\b&quot; has a different meaning, namely the backspace character, inside a character class).</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184361">
 </A>A word boundary is a position in the  subject  string  where the current character and the previous character do not both match \w or \W (i.e. one matches \w and  the  other  matches \W),  or the start or end of the string if the first or last character matches \w, respectively.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184362">
 </A>The \A, \Z, and \z assertions differ from the traditional circumflex and dollar (described below) in that they only ever match at the very start and end of the subject string, whatever options are set.  They are not affected by the PCRE_NOTBOL or PCRE_NOTEOL options. If the startoffset argument of pcre_exec() is non-zero, \A can never match. The difference between \Z and \z is that \Z matches before a newline that is the last character of the string as well as at the end of the string, whereas \z matches only at the end.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184363">
 </A>&nbsp;</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184364">
 </A>CIRCUMFLEX AND DOLLAR</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184365">
 </A>Outside a character class, in the default matching mode, the circumflex character is an assertion which is true only if the current matching point is at the start of the subject string.  If the startoffset argument of pcre_exec() is non-zero, circumflex can never match. Inside a character class, circumflex has an entirely different meaning (see below).</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184366">
 </A>Circumflex need not be the first character of the pattern if a number of alternatives are involved, but it should be the first thing in each alternative in which it appears if the pattern is ever to match that branch. If all possible alternatives start with a circumflex, that is, if the pattern is constrained to match only at the start of the subject, it is said to be an &quot;anchored&quot; pattern. (There are also other constructs that can cause a pattern to be anchored.)</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184367">
 </A>A dollar character is an assertion which is true only if the current  matching point is at the end of the subject string, or immediately before a newline character that is  the  last character in the string (by default). Dollar need not be the last character of the pattern if a  number  of  alternatives are  involved,  but it should be the last item in any branch in which it appears.  Dollar has no  special  meaning  in  a character class.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184368">
 </A>The meaning of dollar can be changed so that it matches only at   the   very   end   of   the   string,  by  setting  the PCRE_DOLLAR_ENDONLY option at compile or matching time. This does not affect the \Z assertion.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184369">
 </A>The meanings of the circumflex and dollar characters are changed if the PCRE_MULTILINE option is set. When this is the case, they match immediately after and immediately before an internal &quot;\n&quot; character, respectively, in addition to matching at the start and end of the subject string.  For example, the pattern /^abc$/ matches the subject string &quot;def\nabc&quot; in multiline mode, but not otherwise.  Consequently, patterns that are anchored in single line mode because all branches start with &quot;^&quot; are not anchored in multiline mode, and a match for circumflex is possible when the startoffset argument of pcre_exec() is non-zero.  The PCRE_DOLLAR_ENDONLY option is ignored if PCRE_MULTILINE is set.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184370">
 </A>Note that the sequences \A, \Z, and \z can be used to  match the  start  and end of the subject in both modes, and if all branches of a pattern start with \A is it  always  anchored, whether PCRE_MULTILINE is set or not.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184371">
 </A>&nbsp;</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184372">
 </A>FULL STOP (PERIOD, DOT)</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184373">
 </A>Outside a character class, a dot in the pattern matches any one character in the subject, including a non-printing character, but not (by default) newline.  If the PCRE_DOTALL option is set, then dots match newlines as well. The handling of dot is entirely independent of the handling of circumflex and dollar, the only relationship being that they both involve newline characters.  Dot has no special meaning in a character class.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184374">
 </A>&nbsp;</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184375">
 </A>SQUARE BRACKETS</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184376">
 </A>An opening square bracket introduces a character class, terminated by a closing square bracket.  A closing square bracket on its own is not special.  If a closing square bracket is required as a member of the class, it should be the first data character in the class (after an initial circumflex, if present) or escaped with a backslash.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184377">
 </A>A character class matches a single character in the subject; the character must be in the set of characters defined by the class, unless the first character in the class is a circumflex, in which case the subject character must not be in the set defined by the class. If a circumflex is actually required as a member of the class, ensure it is not the first character, or escape it with a backslash.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184378">
 </A>For example, the character class [aeiou] matches any lower case vowel, while [^aeiou] matches any character that is not a lower case vowel. Note that a circumflex is just a convenient notation for specifying the characters which are in the class by enumerating those that are not. It is not an assertion: it still consumes a character from the subject string, and fails if the current pointer is at the end of the string.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184379">
 </A>When caseless matching is set, any letters in a class represent both their upper case and lower case versions, so for example, a caseless [aeiou] matches &quot;A&quot; as well as &quot;a&quot;, and a caseless [^aeiou] does not match &quot;A&quot;, whereas a caseful version would.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184380">
 </A>The newline character is never treated in any special way in character  classes,  whatever the setting of the PCRE_DOTALL or PCRE_MULTILINE options is. A  class  such  as  [^a]  will always match a newline.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184381">
 </A>The minus (hyphen) character can be used to specify a range of characters in a character class.  For example, [d-m] matches any letter between d and m, inclusive.  If a minus character is required in a class, it must be escaped with a backslash or appear in a position where it cannot be interpreted as indicating a range, typically as the first or last character in the class.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184382">
 </A>It is not possible to have the literal character &quot;]&quot; as the end character of a range.  A pattern such as [W-]46] is interpreted as a class of two characters (&quot;W&quot; and &quot;-&quot;) followed by a literal string &quot;46]&quot;, so it would match &quot;W46]&quot; or &quot;-46]&quot;. However, if the &quot;]&quot; is escaped with a backslash it is interpreted as the end of range, so [W-\]46] is interpreted as a single class containing a range followed by two separate characters. The octal or hexadecimal representation of &quot;]&quot; can also be used to end a range.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184383">
 </A>Ranges operate in ASCII collating sequence. They can also be used  for  characters  specified  numerically,  for  example [\000-\037]. If a range that includes letters is  used  when caseless  matching  is set, it matches the letters in either case. For example, [W-c] is equivalent  to  [][\^_`wxyzabc], matched  caselessly,  and  if  character tables for the &quot;fr&quot; locale are in use, [\xc8-\xcb] matches accented E characters in both cases.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184384">
 </A>The character types \d, \D, \s, \S, \w, and \W may also appear in a character class, and add the characters that they match to the class. For example, [\dABCDEF] matches any hexadecimal digit.  A circumflex can conveniently be used with the upper case character types to specify a more restricted set of characters than the matching lower case type.  For example, the class [^\W_] matches any letter or digit, but not underscore.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184385">
 </A>All non-alphameric characters other than \,  -,  ^  (at  the start)  and  the  terminating ] are non-special in character classes, but it does no harm if they are escaped.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184386">
 </A>&nbsp;</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184387">
 </A>VERTICAL BAR</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184388">
 </A>Vertical bar characters are  used  to  separate  alternative patterns. For example, the pattern</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184389">
 </A>  gilbert|sullivan</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184390">
 </A>matches either &quot;gilbert&quot; or &quot;sullivan&quot;. Any number of alternatives may appear, and an empty alternative is permitted (matching the empty string).  The matching process tries each alternative in turn, from left to right, and the first one that succeeds is used. If the alternatives are within a subpattern (defined below), &quot;succeeds&quot; means matching the rest of the main pattern as well as the alternative in the subpattern.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184699">
 </A>&nbsp;</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184392">
 </A>INTERNAL OPTION SETTING</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184393">
 </A><A NAME="17592">
 </A>The settings of PCRE_CASELESS, PCRE_MULTILINE,  PCRE_DOTALL, and  PCRE_EXTENDED can be changed from within the pattern by a sequence of Perl option letters enclosed between &quot;(?&quot;  and &quot;)&quot;. The option letters are</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184394">
 </A>  i  for PCRE_CASELESS</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184691">
 </A>  m  for PCRE_MULTILINE</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184695">
 </A>  s  for PCRE_DOTALL</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184696">
 </A>  x  for PCRE_EXTENDED</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184395">
 </A>For example, (?im) sets caseless, multiline matching. It  is also possible to unset these options by preceding the letter with a hyphen, and a combined setting and unsetting such  as (?im-sx),  which sets PCRE_CASELESS and PCRE_MULTILINE while unsetting PCRE_DOTALL and PCRE_EXTENDED, is also  permitted. If  a  letter  appears both before and after the hyphen, the option is unset.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184396">
 </A>The scope of these option changes depends on  where  in  the pattern  the  setting  occurs. For settings that are outside any subpattern (defined below), the effect is the same as if the  options were set or unset at the start of matching. The following patterns all behave in exactly the same way:</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184397">
 </A>  (?i)abc   a(?i)bc   ab(?i)c   abc(?i)</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184398">
 </A>which in turn is the same as compiling the pattern abc with PCRE_CASELESS set.  In other words, such &quot;top level&quot; settings apply to the whole pattern (unless there are other changes inside subpatterns). If there is more than one setting of the same option at top level, the rightmost setting is used.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184399">
 </A>If an option change occurs inside a subpattern,  the  effect is  different.  This is a change of behaviour in Perl 5.005. An option change inside a subpattern affects only that  part of the subpattern that follows it, so</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184400">
 </A>  (a(?i)b)c</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184401">
 </A>matches  abc  and  aBc  and  no  other   strings   (assuming PCRE_CASELESS  is  not used).  By this means, options can be made to have different settings in different  parts  of  the pattern.  Any  changes  made  in one alternative do carry on into subsequent branches within  the  same  subpattern.  For example,</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184402">
 </A>  (a(?i)b|c)</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184403">
 </A>matches &quot;ab&quot;, &quot;aB&quot;, &quot;c&quot;, and &quot;C&quot;, even though when  matching &quot;C&quot; the first branch is abandoned before the option setting. This is because the effects of  option  settings  happen  at compile  time. There would be some very weird behaviour otherwise.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184404">
 </A>The PCRE-specific options PCRE_UNGREEDY and  PCRE_EXTRA  can be changed in the same way as the Perl-compatible options by using the characters U and X  respectively.  The  (?X)  flag setting  is  special in that it must always occur earlier in the pattern than any of the additional features it turns on, even when it is at top level. It is best put at the start.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184405">
 </A>&nbsp;</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184406">
 </A>SUBPATTERNS</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184407">
 </A>Subpatterns are delimited by parentheses (round brackets), which can be nested.  Marking part of a pattern as a subpattern does two things:</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184408">
 </A>1. It localizes a set of alternatives. For example, the pattern</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184409">
 </A>  cat(aract|erpillar|)</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184410">
 </A>matches one of the words &quot;cat&quot;, &quot;cataract&quot;, or &quot;caterpillar&quot;.  Without the parentheses, it would match &quot;cataract&quot;, &quot;erpillar&quot; or the empty string.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184411">
 </A>2. It sets up the subpattern as a capturing subpattern (as defined above).  When the whole pattern matches, that portion of the subject string that matched the subpattern is passed back to the caller via the ovector argument of pcre_exec(). Opening parentheses are counted from left to right (starting from 1) to obtain the numbers of the capturing subpatterns.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184412">
 </A>For example, if the string &quot;the red king&quot; is matched against the pattern</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184413">
 </A>  the ((red|white) (king|queen))</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184414">
 </A>the captured substrings are &quot;red king&quot;, &quot;red&quot;,  and  &quot;king&quot;, and are numbered 1, 2, and 3.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184415">
 </A>The fact that plain parentheses fulfil two functions is not always helpful.  There are often times when a grouping subpattern is required without a capturing requirement.  If an opening parenthesis is followed by &quot;?:&quot;, the subpattern does not do any capturing, and is not counted when computing the number of any subsequent capturing subpatterns. For example, if the string &quot;the white queen&quot; is matched against the pattern</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184416">
 </A>  the ((?:red|white) (king|queen))</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184417">
 </A>the captured substrings are &quot;white queen&quot; and &quot;queen&quot;, and are numbered 1 and 2. The maximum number of captured substrings is 99, and the maximum number of all subpatterns, both capturing and non-capturing, is 200.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184418">
 </A>As a  convenient  shorthand,  if  any  option  settings  are required  at  the  start  of a non-capturing subpattern, the option letters may appear between the &quot;?&quot; and the &quot;:&quot;.  Thus the two patterns</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184419">
 </A>  (?i:saturday|sunday)</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184420">
 </A>  (?:(?i)saturday|sunday)</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184421">
 </A>match exactly the same set of strings.  Because  alternative branches  are  tried from left to right, and options are not reset until the end of the subpattern is reached, an  option setting  in  one  branch does affect subsequent branches, so the above patterns match &quot;SUNDAY&quot; as well as &quot;Saturday&quot;.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184422">
 </A>&nbsp;</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184423">
 </A>REPETITION</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184424">
 </A>Repetition is specified by quantifiers, which can follow any of the following items:</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184425">
 </A>  a single character, possibly escaped</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184426">
 </A>  the . metacharacter</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184427">
 </A>  a character class</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184428">
 </A>  a back reference (see next section)</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184429">
 </A>  a parenthesized subpattern (unless it is  an  assertion - see below)</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184430">
 </A>The general repetition quantifier specifies  a  minimum  and maximum  number  of  permitted  matches,  by  giving the two numbers in curly brackets (braces), separated  by  a  comma. The  numbers  must be less than 65536, and the first must be less than or equal to the second. For example:</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184431">
 </A>  z{2,4}</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184432">
 </A>matches &quot;zz&quot;, &quot;zzz&quot;, or &quot;zzzz&quot;. A closing brace on  its  own is not a special character. If the second number is omitted, but the comma is present, there is no upper  limit;  if  the second number and the comma are both omitted, the quantifier specifies an exact number of required matches. Thus</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184433">
 </A>  [aeiou]{3,}</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184434">
 </A>matches at least 3 successive vowels,  but  may  match  many more, while</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184435">
 </A>  \d{8}</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184436">
 </A>matches exactly 8 digits.  An opening curly bracket that appears in a position where a quantifier is not allowed, or one that does not match the syntax of a quantifier, is taken as a literal character. For example, {,6} is not a quantifier, but a literal string of four characters.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184437">
 </A>The quantifier {0} is permitted, causing the  expression  to behave  as  if the previous item and the quantifier were not present.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184438">
 </A>For convenience (and  historical  compatibility)  the  three most common quantifiers have single-character abbreviations:</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184439">
 </A>  *    is equivalent to {0,}</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184440">
 </A>  +    is equivalent to {1,}</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184441">
 </A>  ?    is equivalent to {0,1}</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184442">
 </A>It is possible to construct infinite loops  by  following  a subpattern  that  can  match no characters with a quantifier that has no upper limit, for example:</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184443">
 </A>  (a?)*</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184444">
 </A>Earlier versions of Perl and PCRE used to give an  error  at compile  time  for such patterns. However, because there are cases where this  can  be  useful,  such  patterns  are  now accepted,  but  if  any repetition of the subpattern does in fact match no characters, the loop is forcibly broken.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184445">
 </A>By default, the quantifiers are &quot;greedy&quot;, that is, they match as much as possible (up to the maximum number of permitted times), without causing the rest of the pattern to fail. The classic example of where this gives problems is in trying to match comments in C programs. These appear between the sequences /* and */ and within the sequence, individual * and / characters may appear. An attempt to match C comments by applying the pattern</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184446">
 </A>  /\*.*\*/</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184447">
 </A>to the string</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184448">
 </A>  /* first command */  not comment  /* second comment */</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184449">
 </A>fails, because it matches  the  entire  string  due  to  the greediness of the .*  item.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184450">
 </A>However, if a quantifier is followed  by  a  question  mark, then it ceases to be greedy, and instead matches the minimum number of times possible, so the pattern</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184451">
 </A>  /\*.*?\*/</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184452">
 </A>does the right thing with the C comments. The meaning of the various quantifiers is not otherwise changed, just the preferred number of matches.  Do not confuse this use of question mark with its use as a quantifier in its own right.  Because it has two uses, it can sometimes appear doubled, as in</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184453">
 </A>  \d??\d</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184454">
 </A>which matches one digit by preference, but can match two  if that is the only way the rest of the pattern matches.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184455">
 </A>If the PCRE_UNGREEDY option is set (an option which  is  not available  in  Perl)  then the quantifiers are not greedy by default, but individual ones can be made greedy by following them  with  a  question mark. In other words, it inverts the default behaviour.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184456">
 </A>When a parenthesized subpattern is quantified with a minimum repeat count that is greater than 1 or with a limited maximum, more store is required for the compiled pattern, in proportion to the size of the minimum or maximum.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184457">
 </A>If a pattern starts with .* or .{0,} and the PCRE_DOTALL option (equivalent to Perl's /s) is set, thus allowing the .  to match newlines, then the pattern is implicitly anchored, because whatever follows will be tried against every character position in the subject string, so there is no point in retrying the overall match at any position after the first.  PCRE treats such a pattern as though it were preceded by \A.  In cases where it is known that the subject string contains no newlines, it is worth setting PCRE_DOTALL when the pattern begins with .* in order to obtain this optimization, or alternatively using ^ to indicate anchoring explicitly.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184458">
 </A>When a capturing subpattern is repeated, the value  captured is  the  substring  that  matched  the  final iteration. For example, after</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184459">
 </A>  (tweedle[dume]{3}\s*)+</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184460">
 </A>has matched &quot;tweedledum tweedledee&quot; the value of the captured substring is &quot;tweedledee&quot;.  However, if there are nested capturing subpatterns, the corresponding captured values may have been set in previous iterations. For example, after</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184461">
 </A>  /(a|(b))+/</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184462">
 </A>matches &quot;aba&quot; the value of the second captured substring  is &quot;b&quot;.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184463">
 </A>&nbsp;</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184464">
 </A>BACK REFERENCES</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184465">
 </A>Outside a character class, a backslash followed by  a  digit greater  than  0  (and  possibly  further  digits) is a back reference to a capturing subpattern  earlier  (i.e.  to  its left)  in  the  pattern,  provided there have been that many previous capturing left parentheses.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184466">
 </A>However, if the decimal number following the backslash is less than 10, it is always taken as a back reference, and causes an error only if there are not that many capturing left parentheses in the entire pattern. In other words, the parentheses that are referenced need not be to the left of the reference for numbers less than 10. See the section entitled &quot;Backslash&quot; above for further details of the handling of digits following a backslash.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184467">
 </A>A back reference matches whatever actually matched the capturing subpattern in the current subject string, rather than anything matching the subpattern itself. So the pattern</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184468">
 </A>  (sens|respons)e and \1ibility</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184469">
 </A>matches &quot;sense and sensibility&quot; and &quot;response and responsibility&quot;, but not &quot;sense and responsibility&quot;. If caseful matching is in force at the time of the back reference, then the case of letters is relevant. For example,</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184470">
 </A>  ((?i)rah)\s+\1</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184471">
 </A>matches &quot;rah rah&quot; and &quot;RAH RAH&quot;, but  not  &quot;RAH  rah&quot;,  even though  the  original  capturing subpattern is matched caselessly.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184472">
 </A>There may be more than one back reference to the same subpattern.  If a subpattern has not actually been used in a particular match, then any back references to it always fail. For example, the pattern</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184473">
 </A>  (a|(bc))\2</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184474">
 </A>always fails if it starts to match  &quot;a&quot;  rather  than  &quot;bc&quot;. Because  there  may  be up to 99 back references, all digits following the backslash are taken as  part  of  a  potential back reference number. If the pattern continues with a digit character, then some delimiter must be used to terminate the back reference. If the PCRE_EXTENDED option is set, this can be whitespace.  Otherwise an empty comment can be used.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184475">
 </A>A back reference that occurs inside the parentheses to which it  refers  fails when the subpattern is first used, so, for example, (a\1) never matches.  However, such references  can be useful inside repeated subpatterns. For example, the pattern</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184476">
 </A>  (a|b\1)+</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184477">
 </A>matches any number of &quot;a&quot;s and also &quot;aba&quot;, &quot;ababaa&quot; etc.  At each iteration of the subpattern, the back reference matches the character string corresponding to the previous iteration.  In order for this to work, the pattern must be such that the first iteration does not need to match the back reference.  This can be done using alternation, as in the example above, or by a quantifier with a minimum of zero.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184478">
 </A>&nbsp;</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184479">
 </A>ASSERTIONS</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184480">
 </A>An assertion is a test on the characters following or preceding the current matching point that does not actually consume any characters. The simple assertions coded as \b, \B, \A, \Z, \z, ^ and $ are described above. More complicated assertions are coded as subpatterns.  There are two kinds: those that look ahead of the current position in the subject string, and those that look behind it.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184481">
 </A>An assertion subpattern is matched in the normal way, except that  it  does not cause the current matching position to be changed. Lookahead assertions start with  (?=  for  positive assertions and (?! for negative assertions. For example,</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184482">
 </A>  \w+(?=;)</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184483">
 </A>matches a word followed by a semicolon, but does not include the semicolon in the match, and</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184484">
 </A>  foo(?!bar)</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184485">
 </A>matches any occurrence of &quot;foo&quot;  that  is  not  followed  by &quot;bar&quot;. Note that the apparently similar pattern</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184486">
 </A>  (?!foo)bar</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184487">
 </A>does not find an occurrence of &quot;bar&quot;  that  is  preceded  by something other than &quot;foo&quot;; it finds any occurrence of &quot;bar&quot; whatsoever, because the assertion  (?!foo)  is  always  true when  the  next  three  characters  are  &quot;bar&quot;. A lookbehind assertion is needed to achieve this effect.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184488">
 </A>Look-behind assertions start with (?&lt;= for positive assertions and (?&lt;! for negative assertions. For example,</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184489">
 </A>  (?&lt;!foo)bar</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184490">
 </A>does find an occurrence of &quot;bar&quot; that  is  not  preceded  by &quot;foo&quot;. The contents of a lookbehind assertion are restricted such that all the strings  it  matches  must  have  a  fixed length.  However, if there are several alternatives, they do not all have to have the same fixed length. Thus</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184491">
 </A>  (?&lt;=bullock|donkey)</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184492">
 </A>is permitted, but</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184493">
 </A>  (?&lt;!dogs?|cats?)</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184494">
 </A>causes an error at compile time. Branches that match different length strings are permitted only at the top level of a lookbehind assertion. This is an extension compared with Perl 5.005, which requires all branches to match the same length of string. An assertion such as</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184495">
 </A>  (?&lt;=ab(c|de))</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184496">
 </A>is not permitted, because its single top-level branch can match two different lengths, but it is acceptable if rewritten to use two top-level branches:</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184497">
 </A>  (?&lt;=abc|abde)</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184498">
 </A>The implementation of lookbehind assertions is, for each alternative, to temporarily move the current position back by the fixed width and then try to match.  If there are insufficient characters before the current position, the match is deemed to fail.  Lookbehinds in conjunction with once-only subpatterns can be particularly useful for matching at the ends of strings; an example is given at the end of the section on once-only subpatterns.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184499">
 </A>Several assertions (of any sort) may  occur  in  succession. For example,</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184500">
 </A>  (?&lt;=\d{3})(?&lt;!999)foo</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184501">
 </A>matches &quot;foo&quot; preceded by three digits that are  not  &quot;999&quot;. Notice  that each of the assertions is applied independently at the same point in the subject string. First  there  is  a check  that  the  previous  three characters are all digits, then there is a check that the same three characters are not &quot;999&quot;.   This  pattern  does not match &quot;foo&quot; preceded by six characters, the first of which are digits and the last three of  which  are  not  &quot;999&quot;.  For  example,  it doesn't match &quot;123abcfoo&quot;. A pattern to do that is</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184502">
 </A>  (?&lt;=\d{3}...)(?&lt;!999)foo</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184503">
 </A>This time the first assertion looks  at  the  preceding  six characters,  checking  that  the first three are digits, and then the second assertion checks that  the  preceding  three characters are not &quot;999&quot;.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184504">
 </A>Assertions can be nested in any combination. For example,</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184505">
 </A>  (?&lt;=(?&lt;!foo)bar)baz</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184506">
 </A>matches an occurrence of &quot;baz&quot; that  is  preceded  by  &quot;bar&quot; which in turn is not preceded by &quot;foo&quot;, while</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184507">
 </A>  (?&lt;=\d{3}(?!999)...)foo</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184508">
 </A>is another pattern which matches  &quot;foo&quot;  preceded  by  three digits and any three characters that are not &quot;999&quot;.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184509">
 </A>Assertion subpatterns are not capturing subpatterns, and may not  be  repeated,  because  it makes no sense to assert the same thing several times. If any kind of assertion  contains capturing  subpatterns  within it, these are counted for the purposes of numbering the capturing subpatterns in the whole pattern.   However,  substring capturing is carried out only for positive assertions, because it does not make sense  for negative assertions.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184510">
 </A>Assertions count towards the maximum  of  200  parenthesized subpatterns.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184511">
 </A>&nbsp;</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184512">
 </A>ONCE-ONLY SUBPATTERNS</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184513">
 </A>With both maximizing and minimizing repetition, failure of what follows normally causes the repeated item to be re-evaluated to see if a different number of repeats allows the rest of the pattern to match. Sometimes it is useful to prevent this, either to change the nature of the match, or to cause it fail earlier than it otherwise might, when the author of the pattern knows there is no point in carrying on.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184514">
 </A>Consider, for example, the pattern \d+foo  when  applied  to the subject line</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184515">
 </A>  123456bar</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184516">
 </A>After matching all 6 digits and then failing to match &quot;foo&quot;, the normal action of the matcher is to try again with only 5 digits matching the \d+ item, and then with 4,  and  so  on, before ultimately failing. Once-only subpatterns provide the means for specifying that once a portion of the pattern  has matched,  it  is  not to be re-evaluated in this way, so the matcher would give up immediately on failing to match  &quot;foo&quot; the  first  time.  The  notation  is another kind of special parenthesis, starting with (?&gt; as in this example:</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184517">
 </A>  (?&gt;\d+)bar</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184518">
 </A>This kind of parenthesis &quot;locks up&quot; the part of the pattern it contains once it has matched, and a failure further into the pattern is prevented from backtracking into it.  Backtracking past it to previous items, however, works as normal.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184519">
 </A>An alternative description is that a subpattern of this type matches the string of characters that an identical standalone pattern would match, if anchored at the current point in the subject string.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184520">
 </A>Once-only subpatterns are not capturing subpatterns.  Simple cases such as the above example can be thought of as a maximizing repeat that must swallow everything it can.  So, while both \d+ and \d+? are prepared to adjust the number of digits they match in order to make the rest of the pattern match, (?&gt;\d+) can only match an entire sequence of digits.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184521">
 </A>This construction can of course contain arbitrarily complicated subpatterns, and it can be nested.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184522">
 </A>Once-only subpatterns can be used in conjunction with look-behind assertions to specify efficient matching at the end of the subject string. Consider a simple pattern such as</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184523">
 </A>  abcd$</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184524">
 </A>when applied to a long  string  which  does  not  match  it. Because matching proceeds from left to right, PCRE will look for each &quot;a&quot; in the subject and then  see  if  what  follows matches the rest of the pattern. If the pattern is specified as</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184525">
 </A>  ^.*abcd$</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184526">
 </A>then the initial .* matches the entire string at first, but when this fails, it backtracks to match all but the last character, then all but the last two characters, and so on.  Once again the search for &quot;a&quot; covers the entire string, from right to left, so we are no better off. However, if the pattern is written as</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184527">
 </A>  ^(?&gt;.*)(?&lt;=abcd)</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184528">
 </A>then there can be no backtracking for the .*  item;  it  can match  only  the  entire  string.  The subsequent lookbehind assertion does a single test on the last four characters. If it  fails,  the  match  fails immediately. For long strings, this approach makes a significant difference to the processing time.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184529">
 </A>&nbsp;</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184530">
 </A>CONDITIONAL SUBPATTERNS</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184531">
 </A>It is possible to cause the matching process to obey a subpattern conditionally or to choose between two alternative subpatterns, depending on the result of an assertion, or whether a previous capturing subpattern matched or not. The two possible forms of conditional subpattern are</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184532">
 </A>  (?(condition)yes-pattern)</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184533">
 </A>  (?(condition)yes-pattern|no-pattern)</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184534">
 </A>If the condition is satisfied, the yes-pattern is used; otherwise the no-pattern (if present) is used. If there are more than two alternatives in the subpattern, a compile-time error occurs.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184535">
 </A>There are two kinds of condition. If the text between the parentheses consists of a sequence of digits, then the condition is satisfied if the capturing subpattern of that number has previously matched. Consider the following pattern, which contains non-significant white space to make it more readable (assume the PCRE_EXTENDED option) and to divide it into three parts for ease of discussion:</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184536">
 </A>  ( \( )?    [^()]+    (?(1) \) )</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184537">
 </A>The first part matches an optional opening parenthesis,  and if  that character is present, sets it as the first captured substring. The second part matches one  or  more  characters that  are  not  parentheses. The third part is a conditional subpattern that tests whether the first set  of  parentheses matched  or  not.  If  they did, that is, if subject started with an opening parenthesis, the condition is true,  and  so the  yes-pattern  is  executed  and a closing parenthesis is required. Otherwise, since no-pattern is  not  present,  the subpattern  matches  nothing.  In  other words, this pattern matches a sequence of non-parentheses,  optionally  enclosed in parentheses.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184538">
 </A>If the condition is not a sequence of digits, it must be an assertion. This may be a positive or negative lookahead or lookbehind assertion. Consider this pattern, again containing non-significant white space, and with the two alternatives on the second line:</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184539">
 </A>  (?(?=[^a-z]*[a-z])</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184540">
 </A>  \d{2}[a-z]{3}-\d{2}  |  \d{2}-\d{2}-\d{2} )</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184541">
 </A>The condition is a positive lookahead assertion that matches an optional sequence of non-letters followed by a letter. In other words, it tests for  the  presence  of  at  least  one letter  in the subject. If a letter is found, the subject is matched against  the  first  alternative;  otherwise  it  is matched  against the second. This pattern matches strings in one of the two forms dd-aaa-dd or dd-dd-dd,  where  aaa  are letters and dd are digits.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184542">
 </A>&nbsp;</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184543">
 </A>COMMENTS</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184544">
 </A>The sequence (?# marks the start of a comment which continues up to the next closing parenthesis. Nested parentheses are not permitted. The characters that make up a comment play no part in the pattern matching at all.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184545">
 </A>If the PCRE_EXTENDED option is set, an unescaped # character outside a character class introduces a comment that continues up to the next newline character in the pattern.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184546">
 </A>&nbsp;</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184547">
 </A>PERFORMANCE</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184548">
 </A>Certain items that may appear in patterns are more efficient than  others.  It is more efficient to use a character class like [aeiou] than a set of alternatives such as (a|e|i|o|u). In  general,  the  simplest  construction  that provides the required behaviour is usually the  most  efficient.  Jeffrey Friedl's  book contains a lot of discussion about optimizing regular expressions for efficient performance.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184549">
 </A>When a pattern begins with .* and the PCRE_DOTALL option  is set,  the  pattern  is implicitly anchored by PCRE, since it can match only at the start of a subject string. However, if PCRE_DOTALL  is not set, PCRE cannot make this optimization, because the . metacharacter does not then match  a  newline, and if the subject string contains newlines, the pattern may match from the character immediately following one  of  them instead of from the very start. For example, the pattern</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184550">
 </A>  (.*) second</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184551">
 </A>matches the subject &quot;first\nand second&quot; (where \n stands for a newline character) with the first captured substring being &quot;and&quot;. In order to do this, PCRE  has  to  retry  the  match starting after every newline in the subject.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184552">
 </A>If you are using such a pattern with subject strings that do not  contain  newlines,  the best performance is obtained by setting PCRE_DOTALL, or starting the  pattern  with  ^.*  to indicate  explicit anchoring. That saves PCRE from having to scan along the subject looking for a newline to restart at.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184553">
 </A>Beware of patterns that contain nested  indefinite  repeats. These  can  take a long time to run when applied to a string that does not match. Consider the pattern fragment</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184554">
 </A>  (a+)*</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184555">
 </A>This can match &quot;aaaa&quot; in 33 different ways, and this number increases very rapidly as the string gets longer. (The * repeat can match 0, 1, 2, 3, or 4 times, and for each of those cases other than 0, the + repeats can match different numbers of times.) When the remainder of the pattern is such that the entire match is going to fail, PCRE has in principle to try every possible variation, and this can take an extremely long time.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184556">
 </A>An optimization catches some of the more simple  cases  such as</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184557">
 </A>  (a+)*b</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184558">
 </A>where a literal character follows. Before embarking  on  the standard matching procedure, PCRE checks that there is a &quot;b&quot; later in the subject string, and if there is not,  it  fails the  match  immediately. However, when there is no following literal this optimization cannot be used. You  can  see  the difference by comparing the behaviour of</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184559">
 </A>  (a+)*\d</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184560">
 </A>with the pattern above. The former gives  a  failure  almost instantly  when  applied  to a whole line of &quot;a&quot; characters, whereas the latter takes an appreciable  time  with  strings longer than about 20 characters.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184562">
 </A>AUTHOR</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184563">
 </A>Philip Hazel &lt;ph10@cam.ac.uk&gt;</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184564">
 </A>University Computing Service,</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184565">
 </A>New Museums Site,</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184566">
 </A>Cambridge CB2 3QG, England.</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184567">
 </A>Phone: +44 1223 334714</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184568">
 </A>Last updated: 29 July 1999</P>
<P CLASS="Copied-Body">
<A NAME="pgfId=184569">
 </A>Copyright (c) 1997-1999 University of Cambridge.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=180396">
 </A>&nbsp;</H4>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=188288">
 </A>Undefined variables and dynamic loading</H4>
<P CLASS="Body">
<A NAME="pgfId=180536">
 </A>During execution, should the ICI execution engine fail to find a variable within the current scope, it will attempt to load a library based on the name of that variable. Such a library may be a host specific dynamically loaded native machine code library, an ICI module, or both.</P>
<P CLASS="Body">
<A NAME="pgfId=180537">
 </A>In attempting to load an ICI module, a file name of the form:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=180415"></A>icivar.ici</PRE>
<P CLASS="Body">
<A NAME="pgfId=180431">
 </A>is considered, where var is the as yet undefined variable name. This file is searched for on the current host specific search path. If found, a new extern, static and auto scope is established and the new extern scope struct is assigned to var in the outermost writable scope available. That outermost writable scope also forms the super of the new extern scope. The module is then parsed with the given scope, after which the variable lookup is repeated. In normal practice this will mean that the loaded module has an outer scope holding all the normal ICI primitives and a new empty extern scope. The intent of this mechanism is that the loaded module should define all its published functions in its extern scope. References by an invoking program to functions and other objects of the loaded module would always be made explicitly through the var which references the module. For example, a program might contain the fragment:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=180444"></A>query = cgi.decode_query();
cgi.start_page(&quot;Query results&quot;);</PRE>
<P CLASS="Body">
<A NAME="pgfId=180454">
 </A>where &quot;cgi&quot; is undefined, but the file icicgi.ici exists on the search path and includes function definitions such as:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=180466"></A>extern
decode_query()
{
	...
}</PRE>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=180476"></A>extern
start_page(title)
{
	...
}</PRE>
<P CLASS="Body">
<A NAME="pgfId=180477">
 </A>Upon first encountering the variable cgi in the code fragment the module icicgi.ici will be parsed and its extern scope assigned to the new variable cgi in the outermost scope of the program (that is, the most global scope). The lookup of the variable cgi is then repeated, this time finding the structure which contains the function decode_query. The second, and all subsequent, use of the variable cgi will be satisfied immediately from the already loaded module.</P>
<P CLASS="Body">
<A NAME="pgfId=180490">
 </A>In attempting to load a host specific dynamically loaded native machine code library, a file name of the form:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=180491"></A>icivar.ext</PRE>
<P CLASS="Body">
<A NAME="pgfId=180488">
 </A>is considered, where var is the as yet undefined variable name and ext is the normal host extension for such libraries. This file is searched for on the current host specific search path. If found the file is loaded into the ICI interpreter's address space using the local host's dynamic library loading mechanism. An initialisation function in the loaded library may return an ICI object (see below). Should an object be returned, it is assigned to var in the outermost writable scope available. Further, should the returned variable be a structure, additional loading of an ICI module of the same name is allowed (as described above) and the returned struct forms the structure for externs in that load.</P>
</DIV>
<DIV>
<H4 CLASS="Heading2">
<A NAME="pgfId=180615">
 </A>The basics of writing dynamic loading native machine code modules</H4>
<P CLASS="Body">
<A NAME="pgfId=180612">
 </A>This description is bare-bones and assumes a knowledge of ICI's internals.</P>
<P CLASS="Body">
<A NAME="pgfId=181731">
 </A>The loaded library must contain a function of the following name and declaration:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=181745"></A>object_t *
ici_var_library_init()
{
	...
}</PRE>
<P CLASS="Body">
<A NAME="pgfId=180575">
 </A>where var is the as yet undefined variable name. This is the initialisation function which is called when the library is loaded. This function should return an ICI object, or NULL on error, in which case the ICI error variable must be set. The returned object will be assigned to var as described above.</P>
<P CLASS="Body">
<A NAME="pgfId=181934">
 </A>Modules of the dynamically loaded library which include ICI header files must have the directory holding the ICI header files on their include search path and have two preprocessor definitions established before any of the ICI headers are included (they are typically defined in the makefile or project settings). These are:</P>
<P CLASS="TagIn4cm">
<A NAME="pgfId=181935">
 </A>CONFIG_FILE	Which must be defined to be the name of the ICI configuration file which is specific to this installation. The defined value should include double quotes around the name. For example:</P>
<PRE CLASS="CodeIn4cm"><A NAME="pgfId=181944"></A>	&quot;conf-w32.h&quot;</PRE>
<P CLASS="TagIn4cm">
<A NAME="pgfId=181948">
 </A>	is the file used by Windows, and this would be defined on the command line or in the project settings with:</P>
<PRE CLASS="CodeIn4cm"><A NAME="pgfId=181952"></A>	/DCONFIG_FILE=\&quot;conf-w32.h\&quot;</PRE>
<P CLASS="TagIn4cm">
<A NAME="pgfId=181956">
 </A> ICI_DLL	Which must simply be defined. This causes certain changes in the nature of data declarations in the ICI header files which are required on some systems (such as Windows) to allow imported data references.</P>
<P CLASS="Body">
<A NAME="pgfId=181960">
 </A>The following sample module, mbox.c, illistrates a typical form for a simple dynamically loaded ICI module.  </P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=182012"></A>#include &lt;windows.h&gt;
#include &quot;func.h&quot;
#include &quot;struct.h&quot;

/*
 * mbox_msg =&gt; mbox.msg(string) from ICI
 *
 * Pops up a modal message box with the given string in it and waits for the
 * use to hit OK. Returns NULL.
 */
int
mbox_msg()
{
    char    *msg;

    if (typecheck(&quot;s&quot;, &amp;msg))
	return 1;
    MessageBox(NULL, msg, (LPCTSTR)&quot;ICI&quot;, MB_OK | MB_SETFOREGROUND);
    return null_ret();
}

/*
 * Object stubs for our intrinsic functions.
 */
cfunc_t	mbox_cfuncs[] =
{
    {CF_OBJ,	&quot;msg&quot;,	mbox_msg},
    {CF_OBJ}
};

/*
 * ici_mbox_library_init
 *
 * Initialisation routine called on load of this module into the ICI
 * interpreters address space. Creates and returns a struct which will
 * be assigned to &quot;mbox&quot;. This struct contains references to our
 * intrinsic functions.
 */
object_t *
ici_mbox_library_init()
{
    struct_t	*s;

    if ((s = new_struct()) == NULL)
	return NULL;
    if (ici_assign_cfuncs(s, mbox_cfuncs))
	return NULL;
    return objof(s);
}</PRE>
<P CLASS="Body">
<A NAME="pgfId=182013">
 </A>The following simple Makefile illustrates forms suitable for compiling this module into a DLL under Windows. Note in particular the defines in the CFLAGS and the use of /export in the link line to make the function ici_mbox_library_init externally visible.</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=182014"></A>CFLAGS	= -I.. /DCONFIG_FILE=\&quot;conf-w32.h\&quot; /DICI_DLL

OBJS	= mbox.obj
LIBS	= ../ici.lib user32.lib

icimbox.dll	: $(OBJS)
		link /dll /out:$@ $(OBJS) /export:ici_mbox_library_init $(LIBS)</PRE>
<P CLASS="Body">
<A NAME="pgfId=181967">
 </A>Note that there is no direct supprt for the /export option in the MS Developer Studio link settings panel, but it can be entered directly in the Project Options text box.</P>
<P CLASS="Body">
<A NAME="pgfId=182079">
 </A>The following Makefile achieves an equivalent result under Solaris:</P>
<PRE CLASS="CodeIn1cm"><A NAME="pgfId=182031"></A>CC	= gcc -pipe -g
CFLAGS	= -fpic -I.. -DCONFIG_FILE='&quot;conf-sun.h&quot;' -DICI_DLL

OBJS	= mbox.o

icimbox.so		: $(OBJS)
		ld -o $@ -dc -dp $(OBJS)</PRE>
</DIV>
</DIV>
</DIV>
</DIV>
<HR>
<DIV CLASS="footnotes">
<DIV CLASS="footnote">
<P CLASS="Footnote">
<SPAN CLASS="footnoteNumber">
1.</SPAN>
<A NAME="pgfId=175518">
 </A>Literal aggregates are analagous to literal strings in K&amp;R C.  And likewise they have the property that modifications to the literal are persistent. Returning to the original use of the literal after it has been modified does not magically restore it to its original value.</P>
</DIV>
<DIV CLASS="footnote">
<P CLASS="Footnote">
<SPAN CLASS="footnoteNumber">
2.</SPAN>
<A NAME="pgfId=175519">
 </A>The precedences and rules are identical to those of C.</P>
</DIV>
<DIV CLASS="footnote">
<P CLASS="Untitled">
<SPAN CLASS="footnoteNumber">
3.</SPAN>
<A NAME="pgfId=175520">
 </A>Note that, unlike C, function definitions must be prefixed by a storage class.  As executable code may occur anywhere, this is required to distinguish them from a function call.</P>
</DIV>
<DIV CLASS="footnote">
<P CLASS="Untitled">
<SPAN CLASS="footnoteNumber">
4.</SPAN>
<A NAME="pgfId=175521">
 </A>As in LISP.</P>
</DIV>
<DIV CLASS="footnote">
<P CLASS="Footnote">
<SPAN CLASS="footnoteNumber">
5.</SPAN>
<A NAME="pgfId=175522">
 </A>Note that this is different from C where the result is always completely resolved to a 0 or 1. Use !! to force a 0/1 value from a generic true/false.</P>
</DIV>
</DIV>
</BODY>
</HTML>
