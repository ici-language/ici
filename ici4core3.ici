
/*
 * min - return the minimum of all parameters
 */
extern
min(v)
{
    auto        vargs = [array];
    auto        rc;

    rc = v;
    forall (v in vargs)
        if (v < rc)
            rc = v;
    return rc;
}

/*
 * max - return the maximum value of all parameters
 */
extern
max(v)
{
    auto        vargs = [array];
    auto        rc;

    rc = v;
    forall (v in vargs)
        if (v > rc)
            rc = v;
    return rc;
}

/*
 * Raise an error for an incorrect argument argument passed to a function.
 * Mimics the interpreter's internal routine to do the same thing.
 */
static
argerror(f, n, t)
{
    fail(sprintf("argument %d of %s() incorrectly supplied as %s", n, f, t));
}

/*
 * Raise an error for an incorrect number of arguments to a function.
 * Mimics the interpreter's internal routine.
 */
static
argcount(f, n, a)
{
    fail(sprintf("%d arguments given to %s, but it takes %d", a, f, n));
}

/*
 * typecheck - validate arguments via format string
 *
 * Parameters:
 *      f       A string, the name of function calling typecheck. This is
 *              used when raising errors about too few arguments or an
 *              argument being of incorrect type.
 *
 *      XXXX    This can be removed now that ICI has _funcname_. Typecheck
 *              can all vstack() to find the caller's name, if it has
 *              one, and issue the appropriate message.
 *
 *      fmt     A format string specifying the types for the
 *              arguments, each character represents a single
 *              argument. If there are too few arguments or
 *              arguments of incorrect type an error is raised.
 *              The following characters are used,
 *
 *                      i       int
 *                      s       string
 *                      f       float
 *                      d       struct
 *                      a       array
 *                      u       file
 *                      r       regexp
 *
 *      args    An array of the parameters to be validated.
 *
 * Returns:
 *      A struct containing two keys, "args" - an array of the actual
 *      validated parameters - and "vargs" - an array containing any
 *      remaining parameters.
 */
extern
typecheck(f, fmt, args)
{
    auto        o;
    auto        c;
    auto        res;
    auto        i;
    auto        n;
    auto        map = [struct
        i = "int",
        s = "string",
        f = "float",
        d = "struct",
        a = "array",
        u = "file",
        r = "regexp",
    ];
    i = 0;
    n = nels(args);
    res = array();
    if (nargs(fmt) != nargs(args))
        argcount(f, nels(fmt), i);
    forall (c in fmt)
    {
        o = args[i];
        if (!(c = map[c]))
            fail("invalid type specifier in typecheck() format string");
        if ((t = typeof(o)) != c)
            argerror(i, f, t);
        push(res, o);
    }
    return struct("args", res, "vargs", interval(args, i));
}

static TM_SUBTYPE = 0x003F;
static TM_TYPE    = 0x07C0;
static TM_PREC    = 0x7800;
static TYPE(n)      {return n << 6;}
static PREC(n)      {return n << 11;}

static tokens = [struct
{
#define TM_SUBTYPE      0x003F          /* 6 bits. */
#define TM_TYPE         0x07C0          /* 5 bits. */
#define TM_PREC         0x7800          /* 4 bits, 0 is high (tight bind).*/
#define t_subtype(t)    ((t) & TM_SUBTYPE)
#define t_type(t)       ((t) & TM_TYPE)
#define t_prec(t)       (((t) & TM_PREC) >> 11)
#define TYPE(n)         ((n) << 6)
#define PREC(n)         ((n) << 11)

    (TYPE(0)) = "none",
    (TYPE(1)) = "name",
    (TYPE(2)) = "string",
    (TYPE(3)) = ";",
    (TYPE(4)) = "eof",
#define T_INT           TYPE(6)
#define T_FLOAT         TYPE(7)
#define T_BINOP         TYPE(8)     /* Has sub-types, see below. */
#define T_ERROR         TYPE(9)
#define T_NULL          TYPE(10)
#define T_ONROUND       TYPE(11)
#define T_OFFROUND      TYPE(12)
#define T_ONCURLY       TYPE(13)
#define T_OFFCURLY      TYPE(14)
#define T_ONSQUARE      TYPE(15)
#define T_OFFSQUARE     TYPE(16)
#define T_DOT           TYPE(17)
#define T_PTR           TYPE(18)
#define T_EXCLAM        TYPE(19)
#define T_PLUSPLUS      TYPE(20)
#define T_MINUSMINUS    TYPE(21)
#define T_CONST         TYPE(22)
#define T_PRIMARYCOLON  TYPE(23)
/*#define T_2COLON        TYPE(24)*/
#define T_DOLLAR        TYPE(25)
#define T_COLONCARET    TYPE(26)
/*#define       T_OFFCURLYOFFSQ TYPE(27)*/
#define T_AT            TYPE(28)
#define T_BINAT         TYPE(29)
/* Maximum value        TYPE(31) */

/*
 * T_BINOP sub types.
 */
#define T_ASTERIX       (PREC(0)|T_BINOP|1)
#define T_SLASH         (PREC(0)|T_BINOP|2)
#define T_PERCENT       (PREC(0)|T_BINOP|3)
#define T_PLUS          (PREC(1)|T_BINOP|4)
#define T_MINUS         (PREC(1)|T_BINOP|5)
#define T_GRTGRT        (PREC(2)|T_BINOP|6)
#define T_LESSLESS      (PREC(2)|T_BINOP|7)
#define T_LESS          (PREC(3)|T_BINOP|8)
#define T_GRT           (PREC(3)|T_BINOP|9)
#define T_LESSEQ        (PREC(3)|T_BINOP|10)
#define T_GRTEQ         (PREC(3)|T_BINOP|11)
#define T_EQEQ          (PREC(4)|T_BINOP|12)
#define T_EXCLAMEQ      (PREC(4)|T_BINOP|13)
#define T_TILDE         (PREC(4)|T_BINOP|14)
#define T_EXCLAMTILDE   (PREC(4)|T_BINOP|15)
#define T_2TILDE        (PREC(4)|T_BINOP|16)
#define T_3TILDE        (PREC(4)|T_BINOP|17)
#define T_AND           (PREC(5)|T_BINOP|18)
#define T_CARET         (PREC(6)|T_BINOP|19)
#define T_BAR           (PREC(7)|T_BINOP|20)
#define T_ANDAND        (PREC(8)|T_BINOP|21)
#define T_BARBAR        (PREC(9)|T_BINOP|22)
#define T_COLON         (PREC(10)|T_BINOP|23)
#define T_QUESTION      (PREC(11)|T_BINOP|24)
#define T_EQ            (PREC(12)|T_BINOP|25)
#define T_COLONEQ       (PREC(12)|T_BINOP|26)
#define T_PLUSEQ        (PREC(12)|T_BINOP|27)
#define T_MINUSEQ       (PREC(12)|T_BINOP|28)
#define T_ASTERIXEQ     (PREC(12)|T_BINOP|29)
#define T_SLASHEQ       (PREC(12)|T_BINOP|30)
#define T_PERCENTEQ     (PREC(12)|T_BINOP|31)
#define T_GRTGRTEQ      (PREC(12)|T_BINOP|32)
#define T_LESSLESSEQ    (PREC(12)|T_BINOP|33)
#define T_ANDEQ         (PREC(12)|T_BINOP|34)
#define T_CARETEQ       (PREC(12)|T_BINOP|35)
#define T_BAREQ         (PREC(12)|T_BINOP|36)
#define T_2TILDEEQ      (PREC(12)|T_BINOP|37)
#define T_LESSEQGRT     (PREC(12)|T_BINOP|38)
#define T_COMMA         (PREC(13)|T_BINOP|39)
#define BINOP_MAX       39
}

extern
getlextoken(f)
{
    
}