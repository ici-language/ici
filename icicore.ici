/*
 * ICI core language extension file. This provides "core language" features
 * that are not coded in C. It is always parsed on interpreter startup,
 * so we try to keep it short. Most functions are just stubs that will
 * get replaced by code from further modules if they are called.
 */

/*
 * Record our extern and the global scope so we can promote our externs
 * to global visibility (because we are special). We know our extern's super
 * is the global scope because we are part of the interpreter initialisation.
 */
static externs, globals;
externs = super(super(scope()));
globals = super(externs);

/*
 * func = get(lib, func-name)
 *
 * Update one of our extern functions with a replacement version from
 * the given lib, and also patch it into the global scope like the rest
 * of our externs.
 *
 * This is used to implement auto-replacement of stub functions with
 * the real code, which we would rather not parse until it is proved
 * required. It is not completely transparent. If someone records our
 * fuction before calling it, they will always go through this code.
 * But if they just call it by name, it will go through this code the
 * first time, and go directly on subsequent calls.
 */
static
get(lib, func)
{
    return globals[func] = externs[func] = lib[func];
}

extern pi = 3.1415926535897932;
extern false = 0;
extern true = 1;
extern pathjoin(){auto vargs; return call(get(core2, "pathjoin"), vargs);}
extern dirname(){auto vargs; return call(get(core2, "dirname"), vargs);}
extern basename(){auto vargs; return call(get(core2, "basename"), vargs);}
extern pfopen(){auto vargs; return call(get(core2, "pfopen"), vargs);}
extern use(){auto vargs; return call(get(core2, "use"), vargs);}
extern min(){auto vargs; return call(get(core3, "min"), vargs);}
extern max(){auto vargs; return call(get(core3, "max"), vargs);}
extern argerror(){auto vargs; return call(get(core3, "argerror"), vargs);}
extern argcount(){auto vargs; return call(get(core3, "argcount"), vargs);}
extern typecheck(){auto vargs; return call(get(core3, "typecheck"), vargs);}

/*
 * The ici struct defines some information about the interpreter.
 * ###This should be generated from compilation info in C.
 */
extern  ici = @[struct
    version = "4.0.0",
    features = @[set
        "math",
        "waitfor",
        "system",
        "pipes",
        "skt",
        "dir",
        "passwd",
        "debug",
        "signals",
    ],
    icipath = ".:/usr/local/lib/ici3",
];

/*
 * Functions to return scope levels. These all operate with the scope of
 * the caller, unlike scope() which operates its scope. If a parameter
 * is passed it is assumed to be a typical scope structure.
 * ###NB: These should move to C, vstack does a copy.
 */
extern
autos(scope)
{
    if (!scope)
        scope = top(vstack(), -1);
    return scope;
}

extern
statics(scope)
{
    if (!scope)
        scope = top(vstack(), -1);
    return super(scope);
}

extern
externs(scope)
{
    if (!scope)
        scope = top(vstack(), -1);
    return super(super(scope));
}

/*
 * int = cmp(a, b)
 *
 * Return -1, 0 or 1 depending on whether a is less than, equal to, or
 * greater than b. This is coded in ICI because it is a real pain to
 * organise access to the code that does < and > in C.
 */
extern
cmp(a, b)
{
    return a < b ? -1 : a > b;
}

/*
 * Promote all our externs to global visibility.
 */
auto v, k;
forall (v, k in externs)
    globals[k] = v;

